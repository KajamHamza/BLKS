"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./hooks/useBlocksProgram.ts":
/*!***********************************!*\
  !*** ./hooks/useBlocksProgram.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PostRating: function() { return /* binding */ PostRating; },\n/* harmony export */   useBlocksProgram: function() { return /* binding */ useBlocksProgram; }\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/wallet-adapter-react */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/useConnection.js\");\n/* harmony import */ var _solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @solana/wallet-adapter-react */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/useWallet.js\");\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n/* harmony import */ var borsh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! borsh */ \"(app-pages-browser)/./node_modules/borsh/lib/index.js\");\n/* harmony import */ var borsh__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(borsh__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_hot_toast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-hot-toast */ \"(app-pages-browser)/./node_modules/react-hot-toast/dist/index.mjs\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/config */ \"(app-pages-browser)/./config/index.ts\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\n\n\n\n// Your deployed program ID - configured from environment\nconst PROGRAM_ID = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(_config__WEBPACK_IMPORTED_MODULE_3__.config.solana.programId);\n// Add debug mode for testing without actual blockchain transactions\nconst DEBUG_MODE = \"development\" === \"development\";\nvar ContractInstruction;\n// Instruction enum matching your Rust contract\n(function(ContractInstruction) {\n    ContractInstruction[ContractInstruction[\"CreateProfile\"] = 0] = \"CreateProfile\";\n    ContractInstruction[ContractInstruction[\"UpdateProfile\"] = 1] = \"UpdateProfile\";\n    ContractInstruction[ContractInstruction[\"CreatePost\"] = 2] = \"CreatePost\";\n    ContractInstruction[ContractInstruction[\"LikePost\"] = 3] = \"LikePost\";\n    ContractInstruction[ContractInstruction[\"CommentOnPost\"] = 4] = \"CommentOnPost\";\n    ContractInstruction[ContractInstruction[\"FollowProfile\"] = 5] = \"FollowProfile\";\n    ContractInstruction[ContractInstruction[\"UnfollowProfile\"] = 6] = \"UnfollowProfile\";\n    ContractInstruction[ContractInstruction[\"CreateCommunity\"] = 7] = \"CreateCommunity\";\n    ContractInstruction[ContractInstruction[\"JoinCommunity\"] = 8] = \"JoinCommunity\";\n})(ContractInstruction || (ContractInstruction = {}));\nvar PostRating;\n(function(PostRating) {\n    PostRating[PostRating[\"None\"] = 0] = \"None\";\n    PostRating[PostRating[\"Bronze\"] = 1] = \"Bronze\";\n    PostRating[PostRating[\"Silver\"] = 2] = \"Silver\";\n    PostRating[PostRating[\"Gold\"] = 3] = \"Gold\";\n    PostRating[PostRating[\"Platinum\"] = 4] = \"Platinum\";\n    PostRating[PostRating[\"Diamond\"] = 5] = \"Diamond\";\n    PostRating[PostRating[\"Ace\"] = 6] = \"Ace\";\n    PostRating[PostRating[\"Conqueror\"] = 7] = \"Conqueror\";\n})(PostRating || (PostRating = {}));\n// Create Profile instruction data class\nclass CreateProfileInstruction {\n    constructor(fields){\n        this.username = fields.username;\n        this.bio = fields.bio;\n        this.profile_image = fields.profile_image;\n        this.cover_image = fields.cover_image;\n    }\n}\n// Create Post instruction data class\nclass CreatePostInstruction {\n    constructor(fields){\n        this.content = fields.content;\n        this.images = fields.images;\n    }\n}\n// Like Post instruction data class\nclass LikePostInstruction {\n    constructor(fields){\n        this.post_id = fields.post_id;\n    }\n}\n// Comment On Post instruction data class\nclass CommentOnPostInstruction {\n    constructor(fields){\n        this.content = fields.content;\n        this.parent_id = fields.parent_id;\n    }\n}\n// Bookmark Post instruction data class\nclass BookmarkPostInstruction {\n    constructor(fields){\n        this.post_id = fields.post_id;\n    }\n}\n// Profile struct for deserialization - matching Rust exactly\nclass ProfileAccount {\n    constructor(fields){\n        this.is_initialized = fields.is_initialized;\n        this.owner = fields.owner;\n        this.username = fields.username;\n        this.bio = fields.bio;\n        this.profile_image = fields.profile_image;\n        this.cover_image = fields.cover_image;\n        this.created_at = fields.created_at;\n        this.followers_count = fields.followers_count;\n        this.following_count = fields.following_count;\n        this.user_credit_rating = fields.user_credit_rating;\n        this.posts_count = fields.posts_count;\n        this.last_post_timestamp = fields.last_post_timestamp;\n        this.daily_post_count = fields.daily_post_count;\n        this.is_verified = fields.is_verified;\n    }\n}\n// Post struct for deserialization - matching Rust exactly\nclass PostAccount {\n    constructor(fields){\n        this.is_initialized = fields.is_initialized;\n        this.id = fields.id;\n        this.author = fields.author;\n        this.content = fields.content;\n        this.timestamp = fields.timestamp;\n        this.likes = fields.likes;\n        this.comments = fields.comments;\n        this.mirrors = fields.mirrors;\n        this.images = fields.images;\n        this.rating = fields.rating;\n        this.in_kill_zone = fields.in_kill_zone;\n    }\n}\n// Borsh schemas\nconst createProfileSchema = new Map([\n    [\n        CreateProfileInstruction,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"username\",\n                    \"string\"\n                ],\n                [\n                    \"bio\",\n                    \"string\"\n                ],\n                [\n                    \"profile_image\",\n                    \"string\"\n                ],\n                [\n                    \"cover_image\",\n                    \"string\"\n                ]\n            ]\n        }\n    ]\n]);\nconst createPostSchema = new Map([\n    [\n        CreatePostInstruction,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"content\",\n                    \"string\"\n                ],\n                [\n                    \"images\",\n                    [\n                        \"string\"\n                    ]\n                ]\n            ]\n        }\n    ]\n]);\nconst likePostSchema = new Map([\n    [\n        LikePostInstruction,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"post_id\",\n                    \"u64\"\n                ]\n            ]\n        }\n    ]\n]);\nconst commentOnPostSchema = new Map([\n    [\n        CommentOnPostInstruction,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"content\",\n                    \"string\"\n                ],\n                [\n                    \"parent_id\",\n                    \"u64\"\n                ]\n            ]\n        }\n    ]\n]);\nconst bookmarkPostSchema = new Map([\n    [\n        BookmarkPostInstruction,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"post_id\",\n                    \"u64\"\n                ]\n            ]\n        }\n    ]\n]);\nconst profileAccountSchema = new Map([\n    [\n        ProfileAccount,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"is_initialized\",\n                    \"u8\"\n                ],\n                [\n                    \"owner\",\n                    [\n                        32\n                    ]\n                ],\n                [\n                    \"username\",\n                    \"string\"\n                ],\n                [\n                    \"bio\",\n                    \"string\"\n                ],\n                [\n                    \"profile_image\",\n                    \"string\"\n                ],\n                [\n                    \"cover_image\",\n                    \"string\"\n                ],\n                [\n                    \"created_at\",\n                    \"u64\"\n                ],\n                [\n                    \"followers_count\",\n                    \"u64\"\n                ],\n                [\n                    \"following_count\",\n                    \"u64\"\n                ],\n                [\n                    \"user_credit_rating\",\n                    \"i64\"\n                ],\n                [\n                    \"posts_count\",\n                    \"u64\"\n                ],\n                [\n                    \"last_post_timestamp\",\n                    \"u64\"\n                ],\n                [\n                    \"daily_post_count\",\n                    \"u64\"\n                ],\n                [\n                    \"is_verified\",\n                    \"u8\"\n                ]\n            ]\n        }\n    ]\n]);\nconst postAccountSchema = new Map([\n    [\n        PostAccount,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"is_initialized\",\n                    \"u8\"\n                ],\n                [\n                    \"id\",\n                    \"u64\"\n                ],\n                [\n                    \"author\",\n                    [\n                        32\n                    ]\n                ],\n                [\n                    \"content\",\n                    \"string\"\n                ],\n                [\n                    \"timestamp\",\n                    \"u64\"\n                ],\n                [\n                    \"likes\",\n                    \"u64\"\n                ],\n                [\n                    \"comments\",\n                    \"u64\"\n                ],\n                [\n                    \"mirrors\",\n                    \"u64\"\n                ],\n                [\n                    \"images\",\n                    [\n                        \"string\"\n                    ]\n                ],\n                [\n                    \"rating\",\n                    \"u8\"\n                ],\n                [\n                    \"in_kill_zone\",\n                    \"u8\"\n                ]\n            ]\n        }\n    ]\n]);\n// Community struct for deserialization\nclass CommunityAccount {\n    constructor(fields){\n        this.is_initialized = fields.is_initialized;\n        this.id = fields.id;\n        this.creator = fields.creator;\n        this.name = fields.name;\n        this.description = fields.description;\n        this.avatar = fields.avatar;\n        this.rules = fields.rules;\n        this.member_count = fields.member_count;\n        this.created_at = fields.created_at;\n        this.is_private = fields.is_private;\n    }\n}\n// Create Community instruction\nclass CreateCommunityInstruction {\n    constructor(fields){\n        this.name = fields.name;\n        this.description = fields.description;\n        this.avatar = fields.avatar;\n        this.rules = fields.rules;\n    }\n}\n// Follow Profile instruction\nclass FollowProfileInstruction {\n    constructor(fields){\n        // Ensure we have a proper PublicKey instance\n        let publicKey;\n        if (fields.profile_id instanceof _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey) {\n            publicKey = fields.profile_id;\n        } else if (typeof fields.profile_id === \"string\") {\n            publicKey = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(fields.profile_id);\n        } else {\n            throw new Error(\"Invalid profile_id type: \".concat(typeof fields.profile_id));\n        }\n        this.profile_id = publicKey.toBuffer();\n    }\n}\nconst createCommunitySchema = new Map([\n    [\n        CreateCommunityInstruction,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"name\",\n                    \"string\"\n                ],\n                [\n                    \"description\",\n                    \"string\"\n                ],\n                [\n                    \"avatar\",\n                    \"string\"\n                ],\n                [\n                    \"rules\",\n                    [\n                        \"string\"\n                    ]\n                ]\n            ]\n        }\n    ]\n]);\nconst followProfileSchema = new Map([\n    [\n        FollowProfileInstruction,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"profile_id\",\n                    [\n                        32\n                    ]\n                ]\n            ]\n        }\n    ]\n]);\nconst communityAccountSchema = new Map([\n    [\n        CommunityAccount,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"is_initialized\",\n                    \"u8\"\n                ],\n                [\n                    \"id\",\n                    \"u64\"\n                ],\n                [\n                    \"creator\",\n                    [\n                        32\n                    ]\n                ],\n                [\n                    \"name\",\n                    \"string\"\n                ],\n                [\n                    \"description\",\n                    \"string\"\n                ],\n                [\n                    \"avatar\",\n                    \"string\"\n                ],\n                [\n                    \"rules\",\n                    [\n                        \"string\"\n                    ]\n                ],\n                [\n                    \"member_count\",\n                    \"u64\"\n                ],\n                [\n                    \"created_at\",\n                    \"u64\"\n                ],\n                [\n                    \"is_private\",\n                    \"u8\"\n                ]\n            ]\n        }\n    ]\n]);\n// Cache for profile lookups to avoid repeated blockchain calls\nconst profileCache = new Map();\nconst CACHE_DURATION = 60000 // 1 minute for memory cache (increased from 30 seconds)\n;\n// Posts cache\nlet postsCache = null;\nconst POSTS_CACHE_DURATION = 30000 // 30 seconds for posts cache (increased from 10 seconds)\n;\n// localStorage cache configuration - Updated to support multiple profiles\nconst LOCALSTORAGE_CACHE_PREFIX = \"blocks_profile_\";\nconst LOCALSTORAGE_CACHE_DURATION = 10 * 60 * 1000 // 10 minutes for localStorage cache (increased from 5 minutes)\n;\n// localStorage cache utilities - Updated to support multiple profiles\nconst saveProfileToLocalStorage = (walletAddress, profile)=>{\n    try {\n        const cacheKey = \"\".concat(LOCALSTORAGE_CACHE_PREFIX).concat(walletAddress);\n        const cacheData = {\n            profile,\n            timestamp: Date.now(),\n            walletAddress\n        };\n        localStorage.setItem(cacheKey, JSON.stringify(cacheData));\n        console.log(\"\\uD83D\\uDCBE Profile cached to localStorage for \".concat(walletAddress.slice(0, 8)));\n    } catch (error) {\n        console.warn(\"Failed to save profile to localStorage:\", error);\n    }\n};\nconst getProfileFromLocalStorage = (walletAddress)=>{\n    try {\n        const cacheKey = \"\".concat(LOCALSTORAGE_CACHE_PREFIX).concat(walletAddress);\n        const cached = localStorage.getItem(cacheKey);\n        if (!cached) return null;\n        const cacheData = JSON.parse(cached);\n        // Check if cache is expired\n        if (Date.now() - cacheData.timestamp > LOCALSTORAGE_CACHE_DURATION) {\n            console.log(\"⏰ Cache expired for \".concat(walletAddress.slice(0, 8), \", clearing\"));\n            localStorage.removeItem(cacheKey);\n            return null;\n        }\n        console.log(\"⚡ Using cached profile from localStorage for \".concat(walletAddress.slice(0, 8)));\n        return cacheData.profile;\n    } catch (error) {\n        console.warn(\"Failed to read profile from localStorage:\", error);\n        const cacheKey = \"\".concat(LOCALSTORAGE_CACHE_PREFIX).concat(walletAddress);\n        localStorage.removeItem(cacheKey);\n        return null;\n    }\n};\nconst clearProfileCache = (walletAddress)=>{\n    // Clear memory cache\n    if (walletAddress) {\n        profileCache.delete(walletAddress);\n        // Clear localStorage cache for specific user\n        const cacheKey = \"\".concat(LOCALSTORAGE_CACHE_PREFIX).concat(walletAddress);\n        localStorage.removeItem(cacheKey);\n    } else {\n        profileCache.clear();\n        // Clear all localStorage profile caches\n        const keys = Object.keys(localStorage);\n        keys.forEach((key)=>{\n            if (key.startsWith(LOCALSTORAGE_CACHE_PREFIX)) {\n                localStorage.removeItem(key);\n            }\n        });\n    }\n    // Clear posts cache\n    postsCache = null;\n    console.log(\"\\uD83D\\uDDD1️ Profile and posts cache cleared\");\n};\n// Simple in-memory comment storage (resets on page refresh)\nlet commentsStorage = {};\n// Comment account tracking - store comment account addresses to distinguish from posts\nconst getCommentAccountsKey = ()=>\"comment_accounts\";\nconst getCommentMappingKey = ()=>\"comment_to_post_mapping\";\n// Store comment account address and its parent post ID\nconst trackCommentAccount = (commentAccountAddress, parentPostId)=>{\n    try {\n        // Track comment accounts\n        const commentAccountsKey = getCommentAccountsKey();\n        const existingAccounts = localStorage.getItem(commentAccountsKey);\n        const commentAccounts = existingAccounts ? JSON.parse(existingAccounts) : [];\n        if (!commentAccounts.includes(commentAccountAddress)) {\n            commentAccounts.push(commentAccountAddress);\n            localStorage.setItem(commentAccountsKey, JSON.stringify(commentAccounts));\n        }\n        // Track comment to post mapping\n        const mappingKey = getCommentMappingKey();\n        const existingMapping = localStorage.getItem(mappingKey);\n        const commentMapping = existingMapping ? JSON.parse(existingMapping) : {};\n        commentMapping[commentAccountAddress] = parentPostId;\n        localStorage.setItem(mappingKey, JSON.stringify(commentMapping));\n        console.log(\"\\uD83D\\uDCDD Tracked comment account \".concat(commentAccountAddress.slice(0, 8), \" for post \").concat(parentPostId));\n    } catch (error) {\n        console.error(\"Failed to track comment account:\", error);\n    }\n};\n// Check if an account address is a comment\nconst isCommentAccount = (accountAddress)=>{\n    try {\n        const commentAccountsKey = getCommentAccountsKey();\n        const existingAccounts = localStorage.getItem(commentAccountsKey);\n        const commentAccounts = existingAccounts ? JSON.parse(existingAccounts) : [];\n        return commentAccounts.includes(accountAddress);\n    } catch (error) {\n        return false;\n    }\n};\n// Get parent post ID for a comment account\nconst getParentPostId = (commentAccountAddress)=>{\n    try {\n        const mappingKey = getCommentMappingKey();\n        const existingMapping = localStorage.getItem(mappingKey);\n        const commentMapping = existingMapping ? JSON.parse(existingMapping) : {};\n        return commentMapping[commentAccountAddress] || null;\n    } catch (error) {\n        return null;\n    }\n};\n// User likes tracking - store in localStorage\nconst getUserLikesKey = (walletAddress)=>\"user_likes_\".concat(walletAddress);\n// Get user's liked posts from localStorage\nconst getUserLikedPosts = (walletAddress)=>{\n    try {\n        const likesKey = getUserLikesKey(walletAddress);\n        const existingLikes = localStorage.getItem(likesKey);\n        return existingLikes ? JSON.parse(existingLikes) : [];\n    } catch (error) {\n        console.error(\"Failed to get user likes:\", error);\n        return [];\n    }\n};\n// Add post to user's liked posts\nconst addUserLike = (walletAddress, postId)=>{\n    try {\n        const likesKey = getUserLikesKey(walletAddress);\n        const existingLikes = getUserLikedPosts(walletAddress);\n        if (!existingLikes.includes(postId)) {\n            existingLikes.push(postId);\n            localStorage.setItem(likesKey, JSON.stringify(existingLikes));\n        }\n    } catch (error) {\n        console.error(\"Failed to add user like:\", error);\n    }\n};\n// Remove post from user's liked posts\nconst removeUserLike = (walletAddress, postId)=>{\n    try {\n        const likesKey = getUserLikesKey(walletAddress);\n        const existingLikes = getUserLikedPosts(walletAddress);\n        const updatedLikes = existingLikes.filter((id)=>id !== postId);\n        localStorage.setItem(likesKey, JSON.stringify(updatedLikes));\n    } catch (error) {\n        console.error(\"Failed to remove user like:\", error);\n    }\n};\n// Check if user has liked a post\nconst hasUserLikedPost = (walletAddress, postId)=>{\n    const userLikes = getUserLikedPosts(walletAddress);\n    return userLikes.includes(postId);\n};\n// User follows tracking - store in localStorage\nconst getUserFollowsKey = (walletAddress)=>\"user_follows_\".concat(walletAddress);\n// Get user's followed profiles from localStorage\nconst getUserFollowedProfiles = (walletAddress)=>{\n    try {\n        const followsKey = getUserFollowsKey(walletAddress);\n        const existingFollows = localStorage.getItem(followsKey);\n        return existingFollows ? JSON.parse(existingFollows) : [];\n    } catch (error) {\n        console.error(\"Failed to get user follows:\", error);\n        return [];\n    }\n};\n// Add profile to user's followed profiles\nconst addUserFollow = (walletAddress, profileOwnerKey)=>{\n    try {\n        console.log(\"\\uD83D\\uDCDD Adding follow: \".concat(walletAddress.slice(0, 8), \" -> \").concat(profileOwnerKey.slice(0, 8)));\n        const followsKey = getUserFollowsKey(walletAddress);\n        const existingFollows = getUserFollowedProfiles(walletAddress);\n        console.log(\"  Follow key: \".concat(followsKey));\n        console.log(\"  Existing follows: \".concat(JSON.stringify(existingFollows)));\n        console.log(\"  Adding profile: \".concat(profileOwnerKey));\n        if (!existingFollows.includes(profileOwnerKey)) {\n            existingFollows.push(profileOwnerKey);\n            localStorage.setItem(followsKey, JSON.stringify(existingFollows));\n            console.log(\"  Updated follows: \".concat(JSON.stringify(existingFollows)));\n            console.log(\"\\uD83D\\uDCDD Tracked follow: \".concat(walletAddress.slice(0, 8), \" -> \").concat(profileOwnerKey.slice(0, 8)));\n        } else {\n            console.log(\"  Already following this profile\");\n        }\n    } catch (error) {\n        console.error(\"Failed to add user follow:\", error);\n    }\n};\n// Remove profile from user's followed profiles\nconst removeUserFollow = (walletAddress, profileOwnerKey)=>{\n    try {\n        console.log(\"\\uD83D\\uDCDD Removing follow: \".concat(walletAddress.slice(0, 8), \" -> \").concat(profileOwnerKey.slice(0, 8)));\n        const followsKey = getUserFollowsKey(walletAddress);\n        const existingFollows = getUserFollowedProfiles(walletAddress);\n        console.log(\"  Follow key: \".concat(followsKey));\n        console.log(\"  Existing follows: \".concat(JSON.stringify(existingFollows)));\n        console.log(\"  Removing profile: \".concat(profileOwnerKey));\n        const updatedFollows = existingFollows.filter((key)=>key !== profileOwnerKey);\n        localStorage.setItem(followsKey, JSON.stringify(updatedFollows));\n        console.log(\"  Updated follows: \".concat(JSON.stringify(updatedFollows)));\n        console.log(\"\\uD83D\\uDCDD Removed follow: \".concat(walletAddress.slice(0, 8), \" -> \").concat(profileOwnerKey.slice(0, 8)));\n    } catch (error) {\n        console.error(\"Failed to remove user follow:\", error);\n    }\n};\n// Check if user is following a profile\nconst isUserFollowingProfile = (walletAddress, profileOwnerKey)=>{\n    try {\n        console.log(\"\\uD83D\\uDD0D Checking if \".concat(walletAddress.slice(0, 8), \" follows \").concat(profileOwnerKey.slice(0, 8)));\n        const userFollows = getUserFollowedProfiles(walletAddress);\n        const isFollowing = userFollows.includes(profileOwnerKey);\n        console.log(\"  User follows: \".concat(JSON.stringify(userFollows)));\n        console.log(\"  Looking for: \".concat(profileOwnerKey));\n        console.log(\"  Result: \".concat(isFollowing));\n        return isFollowing;\n    } catch (error) {\n        console.error(\"Failed to check follow status:\", error);\n        return false;\n    }\n};\nfunction useBlocksProgram() {\n    const { connection } = (0,_solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_4__.useConnection)();\n    const { publicKey, sendTransaction } = (0,_solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_5__.useWallet)();\n    // Get profile PDA\n    const getProfilePDA = async (userPublicKey, username)=>{\n        const [profilePDA] = await _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey.findProgramAddress([\n            userPublicKey.toBuffer(),\n            Buffer.from(\"profile\"),\n            Buffer.from(username)\n        ], PROGRAM_ID);\n        return profilePDA;\n    };\n    // Get post PDA\n    const getPostPDA = async (userPublicKey, postId)=>{\n        const [postPDA] = await _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey.findProgramAddress([\n            userPublicKey.toBuffer(),\n            Buffer.from(\"post\"),\n            Buffer.from(postId.toString())\n        ], PROGRAM_ID);\n        return postPDA;\n    };\n    // Helper function to check if program exists\n    const checkProgramExists = async ()=>{\n        try {\n            const programInfo = await connection.getAccountInfo(PROGRAM_ID);\n            return programInfo !== null && programInfo.executable;\n        } catch (error) {\n            console.error(\"Error checking program existence:\", error);\n            return false;\n        }\n    };\n    // Helper function to check SOL balance\n    const checkSOLBalance = async ()=>{\n        if (!publicKey) return 0;\n        try {\n            const balance = await connection.getBalance(publicKey);\n            return balance / _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.LAMPORTS_PER_SOL;\n        } catch (error) {\n            console.error(\"Error checking SOL balance:\", error);\n            return 0;\n        }\n    };\n    // Convert ProfileAccount to Profile interface\n    const convertProfileAccount = (profileAccount)=>{\n        // Calculate UCR based on activity\n        const calculateUCR = (profile)=>{\n            const postsCount = Number(profile.posts_count);\n            const followersCount = Number(profile.followers_count);\n            const followingCount = Number(profile.following_count);\n            // Base UCR calculation algorithm\n            let ucr = 1.0 // Start with base rating\n            ;\n            // Posts factor (0.1 points per post, max 2.0 points)\n            const postsScore = Math.min(postsCount * 0.1, 2.0);\n            // Followers factor (0.05 points per follower, max 1.5 points)\n            const followersScore = Math.min(followersCount * 0.05, 1.5);\n            // Following/followers ratio (healthy ratio = bonus)\n            let ratioBonus = 0;\n            if (followersCount > 0 && followingCount > 0) {\n                const ratio = followersCount / followingCount;\n                if (ratio >= 0.5 && ratio <= 2.0) {\n                    ratioBonus = 0.3;\n                }\n            }\n            // Account age factor (older accounts get bonus)\n            const accountAge = Date.now() - Number(profile.created_at) * 1000;\n            const daysOld = accountAge / (1000 * 60 * 60 * 24);\n            const ageBonus = Math.min(daysOld / 30 * 0.2, 1.0) // 0.2 points per month, max 1.0\n            ;\n            // Verification bonus\n            const verificationBonus = profile.is_verified === 1 ? 0.5 : 0;\n            // Activity factor (posting regularly)\n            const lastPostAge = Date.now() - Number(profile.last_post_timestamp) * 1000;\n            const daysSinceLastPost = lastPostAge / (1000 * 60 * 60 * 24);\n            const activityBonus = daysSinceLastPost < 7 ? 0.3 : daysSinceLastPost < 30 ? 0.1 : 0;\n            ucr = ucr + postsScore + followersScore + ratioBonus + ageBonus + verificationBonus + activityBonus;\n            // Cap at 5.0 max\n            return Math.min(ucr, 5.0);\n        };\n        return {\n            isInitialized: profileAccount.is_initialized === 1,\n            owner: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(profileAccount.owner),\n            username: profileAccount.username,\n            bio: profileAccount.bio,\n            profileImage: profileAccount.profile_image,\n            coverImage: profileAccount.cover_image,\n            createdAt: Number(profileAccount.created_at) * 1000,\n            followersCount: Number(profileAccount.followers_count),\n            followingCount: Number(profileAccount.following_count),\n            userCreditRating: calculateUCR(profileAccount),\n            postsCount: Number(profileAccount.posts_count),\n            lastPostTimestamp: Number(profileAccount.last_post_timestamp) * 1000,\n            dailyPostCount: Number(profileAccount.daily_post_count),\n            isVerified: profileAccount.is_verified === 1\n        };\n    };\n    // Convert PostAccount to Post interface\n    const convertPostAccount = (postAccount)=>{\n        return {\n            isInitialized: postAccount.is_initialized === 1,\n            id: Number(postAccount.id),\n            author: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(postAccount.author),\n            content: postAccount.content,\n            timestamp: Number(postAccount.timestamp) * 1000,\n            likes: Number(postAccount.likes),\n            comments: Number(postAccount.comments),\n            mirrors: Number(postAccount.mirrors),\n            images: postAccount.images,\n            rating: postAccount.rating,\n            inKillZone: postAccount.in_kill_zone === 1\n        };\n    };\n    // Create user profile - REAL IMPLEMENTATION\n    const createProfile = async (username, bio, profileImage, coverImage)=>{\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83D\\uDD0D Running pre-flight checks...\");\n            const balance = await checkSOLBalance();\n            console.log(\"\\uD83D\\uDCB0 SOL Balance: \".concat(balance));\n            if (balance < 0.1) {\n                throw new Error(\"Insufficient SOL balance: \".concat(balance, \". You need at least 0.1 SOL for transaction fees and account creation.\"));\n            }\n            const programExists = await checkProgramExists();\n            console.log(\"\\uD83D\\uDCCB Program exists: \".concat(programExists));\n            if (!programExists) {\n                throw new Error(\"Program not found at address: \".concat(PROGRAM_ID.toString(), \". Make sure the program is deployed on \").concat(_config__WEBPACK_IMPORTED_MODULE_3__.config.solana.network, \".\"));\n            }\n            console.log(\"✅ Pre-flight checks passed\");\n            const profilePDA = await getProfilePDA(publicKey, username);\n            console.log(\"\\uD83D\\uDCCD Profile PDA: \".concat(profilePDA.toString()));\n            const instructionData = new CreateProfileInstruction({\n                username,\n                bio,\n                profile_image: profileImage,\n                cover_image: coverImage\n            });\n            const createProfileVariant = Buffer.from([\n                0\n            ]);\n            const serializedData = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.serialize)(createProfileSchema, instructionData);\n            const fullInstructionData = Buffer.concat([\n                createProfileVariant,\n                Buffer.from(serializedData)\n            ]);\n            const instruction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: profilePDA,\n                        isSigner: false,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.SystemProgram.programId,\n                        isSigner: false,\n                        isWritable: false\n                    }\n                ],\n                programId: PROGRAM_ID,\n                data: fullInstructionData\n            });\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction().add(instruction);\n            const { blockhash } = await connection.getLatestBlockhash(\"processed\");\n            transaction.recentBlockhash = blockhash;\n            transaction.feePayer = publicKey;\n            const simulation = await connection.simulateTransaction(transaction);\n            if (simulation.value.err) {\n                throw new Error(\"Transaction simulation failed: \".concat(JSON.stringify(simulation.value.err)));\n            }\n            const signature = await sendTransaction(transaction, connection, {\n                skipPreflight: false,\n                preflightCommitment: \"processed\",\n                maxRetries: 3\n            });\n            await connection.confirmTransaction({\n                signature,\n                blockhash,\n                lastValidBlockHeight: (await connection.getLatestBlockhash()).lastValidBlockHeight\n            }, \"processed\");\n            // Invalidate cache after profile creation\n            clearProfileCache(publicKey.toString());\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.success(\"Profile created successfully!\");\n            return signature;\n        } catch (error) {\n            console.error(\"❌ Profile creation error:\", error);\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Transaction failed: \".concat(error.message || \"Unknown error\"));\n            throw error;\n        }\n    };\n    // Production-ready profile detection with localStorage caching - Improved for multiple users\n    const getProfile = async (userPublicKey)=>{\n        const cacheKey = userPublicKey.toString();\n        try {\n            // 1. Check localStorage cache first (fastest)\n            const cachedProfile = getProfileFromLocalStorage(cacheKey);\n            if (cachedProfile !== null) {\n                // Also update memory cache\n                profileCache.set(cacheKey, cachedProfile);\n                setTimeout(()=>profileCache.delete(cacheKey), CACHE_DURATION);\n                return cachedProfile;\n            }\n            // 2. Check memory cache\n            if (profileCache.has(cacheKey)) {\n                const cached = profileCache.get(cacheKey);\n                return cached !== null && cached !== void 0 ? cached : null;\n            }\n            // 3. Fetch from blockchain (slowest)\n            console.log(\"\\uD83D\\uDD0D Fetching profile from blockchain for: \".concat(userPublicKey.toString().slice(0, 8), \"...\"));\n            const accounts = await connection.getProgramAccounts(PROGRAM_ID);\n            console.log(\"\\uD83D\\uDCCA Found \".concat(accounts.length, \" program accounts to scan for profiles\"));\n            let profilesFound = 0;\n            // Scan through accounts to find user's profile\n            for (const { account, pubkey } of accounts){\n                try {\n                    if (account.data.length === 0) continue;\n                    // Try manual parsing first\n                    const profileAccount = manualParseProfile(account.data);\n                    if (!profileAccount) continue;\n                    profilesFound++;\n                    const accountOwner = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(profileAccount.owner);\n                    // Check if this profile belongs to the user we're looking for\n                    if (profileAccount.is_initialized === 1 && accountOwner.equals(userPublicKey)) {\n                        console.log('\\uD83C\\uDFAF FOUND PROFILE! Username: \"'.concat(profileAccount.username, '\" for ').concat(userPublicKey.toString().slice(0, 8)));\n                        console.log('\\uD83D\\uDCF8 Profile Image URL: \"'.concat(profileAccount.profile_image, '\"'));\n                        console.log('\\uD83D\\uDDBC️ Cover Image URL: \"'.concat(profileAccount.cover_image, '\"'));\n                        console.log(\"\\uD83D\\uDCCA Profile Data:\", {\n                            username: profileAccount.username,\n                            bio: profileAccount.bio,\n                            profileImage: profileAccount.profile_image,\n                            coverImage: profileAccount.cover_image,\n                            postsCount: Number(profileAccount.posts_count),\n                            followersCount: Number(profileAccount.followers_count),\n                            isVerified: profileAccount.is_verified === 1\n                        });\n                        const profile = convertProfileAccount(profileAccount);\n                        // Cache in both memory and localStorage\n                        profileCache.set(cacheKey, profile);\n                        setTimeout(()=>profileCache.delete(cacheKey), CACHE_DURATION);\n                        saveProfileToLocalStorage(cacheKey, profile);\n                        return profile;\n                    }\n                } catch (error) {\n                    continue;\n                }\n            }\n            console.log(\"\\uD83D\\uDCCA Scanned \".concat(profilesFound, \" profiles, no match found for user: \").concat(userPublicKey.toString().slice(0, 8)));\n            // No profile found - cache null result to avoid repeated scans\n            profileCache.set(cacheKey, null);\n            setTimeout(()=>profileCache.delete(cacheKey), CACHE_DURATION);\n            saveProfileToLocalStorage(cacheKey, null);\n            return null;\n        } catch (error) {\n            console.error(\"Error fetching profile for \".concat(userPublicKey.toString().slice(0, 8), \":\"), error);\n            return null;\n        }\n    };\n    // Get profile by username (for specific lookups)\n    const getProfileByUsername = async (userPublicKey, username)=>{\n        try {\n            const profilePDA = await getProfilePDA(userPublicKey, username);\n            const accountInfo = await connection.getAccountInfo(profilePDA);\n            if (!accountInfo || !accountInfo.data || accountInfo.data.length === 0) {\n                return null;\n            }\n            // Now try manual parsing\n            const profileAccount = manualParseProfile(accountInfo.data);\n            if (profileAccount) {\n                console.log(\"✅ Successfully manually parsed profile:\", {\n                    username: profileAccount.username,\n                    bio: profileAccount.bio,\n                    isInitialized: profileAccount.is_initialized === 1,\n                    owner: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(profileAccount.owner).toString(),\n                    profileImage: profileAccount.profile_image,\n                    coverImage: profileAccount.cover_image,\n                    postsCount: Number(profileAccount.posts_count)\n                });\n                return convertProfileAccount(profileAccount);\n            } else {\n                console.log(\"❌ Manual parsing failed\");\n                return null;\n            }\n        } catch (error) {\n            return null;\n        }\n    };\n    // Get posts - SIMPLIFIED without complex filtering\n    const getPosts = async ()=>{\n        try {\n            // Check cache first\n            if (postsCache && Date.now() - postsCache.timestamp < POSTS_CACHE_DURATION) {\n                console.log(\"⚡ Using cached posts\");\n                return postsCache.posts;\n            }\n            console.log(\"\\uD83D\\uDD0D Fetching posts from blockchain...\");\n            const accounts = await connection.getProgramAccounts(PROGRAM_ID);\n            const posts = [];\n            console.log(\"\\uD83D\\uDCCA Scanning \".concat(accounts.length, \" program accounts for posts...\"));\n            for (const { account, pubkey } of accounts){\n                try {\n                    if (account.data.length === 0) continue;\n                    // Skip if this is a known comment account\n                    if (isCommentAccount(pubkey.toString())) {\n                        console.log(\"⏭️ Skipping comment account: \".concat(pubkey.toString().slice(0, 8)));\n                        continue;\n                    }\n                    const postAccount = manualParsePost(account.data);\n                    if (postAccount && postAccount.is_initialized === 1 && postAccount.content) {\n                        const post = convertPostAccount(postAccount);\n                        posts.push(post);\n                        console.log('\\uD83D\\uDCDD Found post: \"'.concat(post.content.substring(0, 50), '...\" by ').concat(post.author.toString()));\n                    }\n                } catch (error) {\n                    continue;\n                }\n            }\n            posts.sort((a, b)=>b.timestamp - a.timestamp);\n            console.log(\"✅ Loaded \".concat(posts.length, \" posts from blockchain (comments filtered out)\"));\n            // Cache the results\n            postsCache = {\n                posts,\n                timestamp: Date.now()\n            };\n            return posts;\n        } catch (error) {\n            console.error(\"Error fetching posts:\", error);\n            return [];\n        }\n    };\n    // Get comments for a specific post - REAL BLOCKCHAIN IMPLEMENTATION\n    const getCommentsForPost = async (postId)=>{\n        try {\n            console.log(\"\\uD83D\\uDD0D Getting comments for post ID \".concat(postId, \" from blockchain...\"));\n            // Scan all program accounts to find comments for this post\n            const accounts = await connection.getProgramAccounts(PROGRAM_ID);\n            const comments = [];\n            console.log(\"\\uD83D\\uDCCA Scanning \".concat(accounts.length, \" program accounts for comments...\"));\n            for (const { account, pubkey } of accounts){\n                try {\n                    if (account.data.length === 0) continue;\n                    // Check if this account is a known comment account for our target post\n                    if (isCommentAccount(pubkey.toString())) {\n                        const parentPostId = getParentPostId(pubkey.toString());\n                        if (parentPostId === postId) {\n                            // This is a comment for our target post\n                            const postAccount = manualParsePost(account.data);\n                            if (postAccount && postAccount.is_initialized === 1 && postAccount.content) {\n                                console.log('\\uD83D\\uDCAC Found comment: \"'.concat(postAccount.content.substring(0, 30), '...\" for post ').concat(postId));\n                                // Get the comment author's profile\n                                const authorPublicKey = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(postAccount.author);\n                                const authorProfile = await getProfile(authorPublicKey);\n                                const comment = {\n                                    id: Number(postAccount.id),\n                                    parentPostId: postId,\n                                    author: authorPublicKey,\n                                    content: postAccount.content,\n                                    timestamp: Number(postAccount.timestamp) * 1000,\n                                    likes: Number(postAccount.likes),\n                                    authorProfile: authorProfile\n                                };\n                                comments.push(comment);\n                            }\n                        }\n                    }\n                } catch (error) {\n                    continue;\n                }\n            }\n            // Also include any comments from in-memory storage (for immediate display after posting)\n            const memoryComments = commentsStorage[postId] || [];\n            // Combine and deduplicate comments\n            const allComments = [\n                ...comments\n            ];\n            // Add memory comments that aren't already in blockchain comments\n            for (const memoryComment of memoryComments){\n                const exists = allComments.some((c)=>c.author.equals(memoryComment.author) && c.content === memoryComment.content && Math.abs(c.timestamp - memoryComment.timestamp) < 10000 // Within 10 seconds\n                );\n                if (!exists) {\n                    allComments.push(memoryComment);\n                }\n            }\n            // Sort by timestamp (oldest first for comments)\n            allComments.sort((a, b)=>a.timestamp - b.timestamp);\n            console.log(\"✅ Found \".concat(allComments.length, \" comments for post \").concat(postId, \" (\").concat(comments.length, \" from blockchain, \").concat(memoryComments.length, \" from memory)\"));\n            return allComments;\n        } catch (error) {\n            console.error(\"Error fetching comments from blockchain:\", error);\n            // Fallback to in-memory storage\n            const memoryComments = commentsStorage[postId] || [];\n            console.log(\"⚠️ Fallback: returning \".concat(memoryComments.length, \" comments from memory\"));\n            return memoryComments;\n        }\n    };\n    // Store comment - SIMPLIFIED\n    const storeComment = (parentPostId, comment)=>{\n        try {\n            console.log(\"\\uD83D\\uDCBE Storing comment for post \".concat(parentPostId, \":\"), comment.content.substring(0, 30));\n            if (!commentsStorage[parentPostId]) {\n                commentsStorage[parentPostId] = [];\n            }\n            commentsStorage[parentPostId].push(comment);\n            console.log(\"✅ Stored comment. Post \".concat(parentPostId, \" now has \").concat(commentsStorage[parentPostId].length, \" comments\"));\n        } catch (error) {\n            console.error(\"Failed to store comment:\", error);\n        }\n    };\n    // Create post - REAL IMPLEMENTATION\n    const createPost = async function(content) {\n        let images = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83D\\uDD0D Creating post with content:\", content);\n            // Check SOL balance\n            const balance = await checkSOLBalance();\n            if (balance < 0.05) {\n                throw new Error(\"Insufficient SOL balance: \".concat(balance, \". You need at least 0.05 SOL for transaction fees and account creation.\"));\n            }\n            // Get user's profile PDA - we need this for the instruction\n            const userProfile = await getProfile(publicKey);\n            if (!userProfile) {\n                throw new Error(\"You must create a profile before posting\");\n            }\n            // Get user's current post count to generate the correct post ID\n            // The Rust contract increments posts_count first, then uses that as the post ID\n            const postId = userProfile.postsCount + 1;\n            const postPDA = await getPostPDA(publicKey, postId);\n            console.log(\"\\uD83D\\uDCCD Post PDA: \".concat(postPDA.toString(), \" for post ID: \").concat(postId));\n            // Generate a new keypair for the post account\n            // The Rust contract uses invoke with system_instruction::create_account\n            // This means the post account MUST be a keypair that signs the transaction\n            const postKeypair = _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Keypair.generate();\n            console.log(\"\\uD83D\\uDCCD Post Account: \".concat(postKeypair.publicKey.toString()));\n            // Get profile PDA for the user (we need the actual username)\n            // Try to find the profile account among all program accounts\n            const accounts = await connection.getProgramAccounts(PROGRAM_ID);\n            let userProfilePDA = null;\n            for (const { account, pubkey } of accounts){\n                try {\n                    const profileAccount = manualParseProfile(account.data);\n                    if (profileAccount && profileAccount.is_initialized === 1 && new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(profileAccount.owner).equals(publicKey)) {\n                        userProfilePDA = pubkey;\n                        console.log(\"\\uD83D\\uDCCD User Profile PDA: \".concat(userProfilePDA.toString()));\n                        break;\n                    }\n                } catch (error) {\n                    continue;\n                }\n            }\n            if (!userProfilePDA) {\n                throw new Error(\"Could not find your profile PDA. Please refresh and try again.\");\n            }\n            const instructionData = new CreatePostInstruction({\n                content,\n                images\n            });\n            const createPostVariant = Buffer.from([\n                2\n            ]) // CreatePost enum index\n            ;\n            const serializedData = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.serialize)(createPostSchema, instructionData);\n            const fullInstructionData = Buffer.concat([\n                createPostVariant,\n                Buffer.from(serializedData)\n            ]);\n            console.log(\"\\uD83D\\uDD22 Instruction data length: \".concat(fullInstructionData.length, \" bytes\"));\n            const instruction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: postKeypair.publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: userProfilePDA,\n                        isSigner: false,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.SystemProgram.programId,\n                        isSigner: false,\n                        isWritable: false\n                    }\n                ],\n                programId: PROGRAM_ID,\n                data: fullInstructionData\n            });\n            console.log(\"\\uD83D\\uDCDD Transaction instruction created\");\n            console.log(\"\\uD83D\\uDD11 Keys:\", instruction.keys.map((k)=>({\n                    pubkey: k.pubkey.toString(),\n                    isSigner: k.isSigner,\n                    isWritable: k.isWritable\n                })));\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction().add(instruction);\n            const { blockhash } = await connection.getLatestBlockhash(\"processed\");\n            transaction.recentBlockhash = blockhash;\n            transaction.feePayer = publicKey;\n            // Sign transaction before simulation\n            transaction.partialSign(postKeypair);\n            // Simulate transaction \n            const simulation = await connection.simulateTransaction(transaction);\n            console.log(\"\\uD83C\\uDFAF Transaction simulation:\", simulation);\n            if (simulation.value.err) {\n                throw new Error(\"Transaction simulation failed: \".concat(JSON.stringify(simulation.value.err)));\n            }\n            // Send transaction with post keypair as additional signer\n            const signature = await sendTransaction(transaction, connection, {\n                skipPreflight: false,\n                preflightCommitment: \"processed\",\n                maxRetries: 3,\n                signers: [\n                    postKeypair\n                ]\n            });\n            console.log(\"\\uD83D\\uDCCB Transaction signature: \".concat(signature));\n            await connection.confirmTransaction({\n                signature,\n                blockhash,\n                lastValidBlockHeight: (await connection.getLatestBlockhash()).lastValidBlockHeight\n            }, \"processed\");\n            // Invalidate cache after post creation (profile post count changed)\n            clearProfileCache(publicKey.toString());\n            postsCache = null // Also clear posts cache to show new post immediately\n            ;\n            console.log(\"✅ Post created successfully!\");\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.success(\"Post created successfully!\");\n            return signature;\n        } catch (error) {\n            var _error_message, _error_message1;\n            console.error(\"❌ Post creation error:\", error);\n            if ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"insufficient funds\")) {\n                const balance = await checkSOLBalance();\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Insufficient SOL: \".concat(balance.toFixed(4), \" SOL. Need at least 0.05 SOL for fees.\"));\n            } else if ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes(\"simulation failed\")) {\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Transaction would fail: Check account setup and balance\");\n                console.error(\"Simulation error details:\", error.message);\n            } else {\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Failed to create post: \".concat(error.message || \"Unknown error\"));\n            }\n            throw error;\n        }\n    };\n    // Like post - REAL IMPLEMENTATION - Fixed to find actual post accounts\n    const likePost = async (postId, postAuthor)=>{\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83D\\uDD0D Attempting to like post ID \".concat(postId, \" by author \").concat(postAuthor.toString().slice(0, 8), \"...\"));\n            // Check SOL balance first\n            const balance = await checkSOLBalance();\n            console.log(\"\\uD83D\\uDCB0 Current SOL balance: \".concat(balance));\n            if (balance < 0.01) {\n                throw new Error(\"Insufficient SOL balance: \".concat(balance, \". Need at least 0.01 SOL for transaction fees.\"));\n            }\n            // Find the actual post account and author's profile account by scanning all program accounts\n            console.log(\"\\uD83D\\uDD0D Searching for post ID \".concat(postId, \" by author \").concat(postAuthor.toString().slice(0, 8), \"...\"));\n            const accounts = await connection.getProgramAccounts(PROGRAM_ID);\n            let postAccountAddress = null;\n            let postAccount = null;\n            let authorProfileAddress = null;\n            // First pass: find the post account\n            for (const { account, pubkey } of accounts){\n                try {\n                    const parsedPost = manualParsePost(account.data);\n                    if (parsedPost && parsedPost.is_initialized === 1 && Number(parsedPost.id) === postId && new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(parsedPost.author).equals(postAuthor)) {\n                        postAccountAddress = pubkey;\n                        postAccount = parsedPost;\n                        console.log(\"\\uD83C\\uDFAF Found post ID \".concat(postId, \" at address: \").concat(pubkey.toString()));\n                        break;\n                    }\n                } catch (error) {\n                    continue;\n                }\n            }\n            if (!postAccountAddress || !postAccount) {\n                throw new Error(\"Post ID \".concat(postId, \" by author \").concat(postAuthor.toString().slice(0, 8), \" not found on blockchain\"));\n            }\n            // Second pass: find the author's profile account\n            console.log(\"\\uD83D\\uDD0D Searching for author's profile: \".concat(postAuthor.toString().slice(0, 8), \"...\"));\n            for (const { account, pubkey } of accounts){\n                try {\n                    const parsedProfile = manualParseProfile(account.data);\n                    if (parsedProfile && parsedProfile.is_initialized === 1 && new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(parsedProfile.owner).equals(postAuthor)) {\n                        authorProfileAddress = pubkey;\n                        console.log(\"✅ Found author profile account: \".concat(pubkey.toString()));\n                        break;\n                    }\n                } catch (error) {\n                    continue;\n                }\n            }\n            if (!authorProfileAddress) {\n                throw new Error(\"Author's profile not found for \".concat(postAuthor.toString().slice(0, 8)));\n            }\n            console.log('\\uD83D\\uDCDD Post data verified: \"'.concat(postAccount.content.slice(0, 30), '...\" with ').concat(Number(postAccount.likes), \" likes\"));\n            const instructionData = new LikePostInstruction({\n                post_id: BigInt(postId)\n            });\n            const likePostVariant = Buffer.from([\n                3\n            ]) // LikePost instruction variant\n            ;\n            const serializedData = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.serialize)(likePostSchema, instructionData);\n            const fullInstructionData = Buffer.concat([\n                likePostVariant,\n                Buffer.from(serializedData)\n            ]);\n            console.log(\"\\uD83D\\uDD22 Instruction data: variant [3], serialized length: \".concat(serializedData.length, \", total: \").concat(fullInstructionData.length, \" bytes\"));\n            const instruction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: publicKey,\n                        isSigner: true,\n                        isWritable: false\n                    },\n                    {\n                        pubkey: postAccountAddress,\n                        isSigner: false,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: authorProfileAddress,\n                        isSigner: false,\n                        isWritable: true\n                    }\n                ],\n                programId: PROGRAM_ID,\n                data: fullInstructionData\n            });\n            console.log(\"\\uD83D\\uDD11 Transaction accounts:\");\n            console.log(\"  User (liker): \".concat(publicKey.toString(), \" (signer, readonly)\"));\n            console.log(\"  Post: \".concat(postAccountAddress.toString(), \" (not signer, writable)\"));\n            console.log(\"  Author Profile: \".concat(authorProfileAddress.toString(), \" (not signer, writable)\"));\n            console.log(\"  Program: \".concat(PROGRAM_ID.toString()));\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction().add(instruction);\n            const { blockhash } = await connection.getLatestBlockhash(\"processed\");\n            transaction.recentBlockhash = blockhash;\n            transaction.feePayer = publicKey;\n            // Simulate transaction before sending\n            console.log(\"\\uD83C\\uDFAF Simulating transaction...\");\n            const simulation = await connection.simulateTransaction(transaction);\n            console.log(\"\\uD83D\\uDCCA Simulation result:\", simulation);\n            if (simulation.value.err) {\n                throw new Error(\"Transaction simulation failed: \".concat(JSON.stringify(simulation.value.err)));\n            }\n            console.log(\"✅ Transaction simulation successful\");\n            console.log(\"\\uD83D\\uDE80 Sending transaction...\");\n            const signature = await sendTransaction(transaction, connection, {\n                skipPreflight: false,\n                preflightCommitment: \"processed\",\n                maxRetries: 3\n            });\n            console.log(\"\\uD83D\\uDCCB Transaction sent with signature: \".concat(signature));\n            console.log(\"⏳ Confirming transaction...\");\n            await connection.confirmTransaction({\n                signature,\n                blockhash,\n                lastValidBlockHeight: (await connection.getLatestBlockhash()).lastValidBlockHeight\n            }, \"processed\");\n            console.log(\"✅ Transaction confirmed! Post liked successfully!\");\n            // Track user like in localStorage\n            if (publicKey) {\n                addUserLike(publicKey.toString(), postId);\n                console.log(\"\\uD83D\\uDCDD Tracked like for user \".concat(publicKey.toString().slice(0, 8), \" on post \").concat(postId));\n            }\n            // Clear posts cache to force refresh\n            postsCache = null;\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.success(\"Post liked!\");\n            return signature;\n        } catch (error) {\n            var _error_message, _error_message1, _error_message2;\n            console.error(\"❌ Like post error:\", error);\n            // More specific error messages\n            if ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"insufficient funds\")) {\n                const balance = await checkSOLBalance();\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Insufficient SOL: \".concat(balance.toFixed(4), \" SOL. Need at least 0.01 SOL for fees.\"));\n            } else if ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes(\"simulation failed\")) {\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Transaction would fail: Check post exists and wallet has permission\");\n                console.error(\"Simulation error details:\", error.message);\n            } else if ((_error_message2 = error.message) === null || _error_message2 === void 0 ? void 0 : _error_message2.includes(\"not found on blockchain\")) {\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Post not found on blockchain\");\n            } else {\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Failed to like post: \".concat(error.message || \"Unknown error\"));\n            }\n            throw error;\n        }\n    };\n    // Unlike post - REAL IMPLEMENTATION\n    const unlikePost = async (postId, postAuthor)=>{\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83D\\uDC4E Attempting to unlike post ID \".concat(postId, \" by author \").concat(postAuthor.toString().slice(0, 8), \"...\"));\n            // Check SOL balance first\n            const balance = await checkSOLBalance();\n            console.log(\"\\uD83D\\uDCB0 Current SOL balance: \".concat(balance));\n            if (balance < 0.01) {\n                throw new Error(\"Insufficient SOL balance: \".concat(balance, \". Need at least 0.01 SOL for transaction fees.\"));\n            }\n            // Find the actual post account and author's profile account by scanning all program accounts\n            console.log(\"\\uD83D\\uDD0D Searching for post ID \".concat(postId, \" by author \").concat(postAuthor.toString().slice(0, 8), \"...\"));\n            const accounts = await connection.getProgramAccounts(PROGRAM_ID);\n            let postAccountAddress = null;\n            let postAccount = null;\n            let authorProfileAddress = null;\n            // First pass: find the post account\n            for (const { account, pubkey } of accounts){\n                try {\n                    // Skip comment accounts\n                    if (isCommentAccount(pubkey.toString())) continue;\n                    const parsedPost = manualParsePost(account.data);\n                    if (parsedPost && parsedPost.is_initialized === 1 && Number(parsedPost.id) === postId && new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(parsedPost.author).equals(postAuthor)) {\n                        postAccountAddress = pubkey;\n                        postAccount = parsedPost;\n                        console.log(\"\\uD83C\\uDFAF Found post ID \".concat(postId, \" at address: \").concat(pubkey.toString()));\n                        break;\n                    }\n                } catch (error) {\n                    continue;\n                }\n            }\n            if (!postAccountAddress || !postAccount) {\n                throw new Error(\"Post ID \".concat(postId, \" by author \").concat(postAuthor.toString().slice(0, 8), \" not found on blockchain\"));\n            }\n            // Second pass: find the author's profile account\n            console.log(\"\\uD83D\\uDD0D Searching for author's profile: \".concat(postAuthor.toString().slice(0, 8), \"...\"));\n            for (const { account, pubkey } of accounts){\n                try {\n                    const parsedProfile = manualParseProfile(account.data);\n                    if (parsedProfile && parsedProfile.is_initialized === 1 && new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(parsedProfile.owner).equals(postAuthor)) {\n                        authorProfileAddress = pubkey;\n                        console.log(\"✅ Found author profile account: \".concat(pubkey.toString()));\n                        break;\n                    }\n                } catch (error) {\n                    continue;\n                }\n            }\n            if (!authorProfileAddress) {\n                throw new Error(\"Author's profile not found for \".concat(postAuthor.toString().slice(0, 8)));\n            }\n            console.log('\\uD83D\\uDCDD Post data verified: \"'.concat(postAccount.content.slice(0, 30), '...\" with ').concat(Number(postAccount.likes), \" likes\"));\n            // For unlike, we'll use the same instruction as like (the smart contract should handle the toggle)\n            const instructionData = new LikePostInstruction({\n                post_id: BigInt(postId)\n            });\n            const likePostVariant = Buffer.from([\n                3\n            ]) // LikePost instruction variant (same for unlike)\n            ;\n            const serializedData = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.serialize)(likePostSchema, instructionData);\n            const fullInstructionData = Buffer.concat([\n                likePostVariant,\n                Buffer.from(serializedData)\n            ]);\n            const instruction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: publicKey,\n                        isSigner: true,\n                        isWritable: false\n                    },\n                    {\n                        pubkey: postAccountAddress,\n                        isSigner: false,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: authorProfileAddress,\n                        isSigner: false,\n                        isWritable: true\n                    }\n                ],\n                programId: PROGRAM_ID,\n                data: fullInstructionData\n            });\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction().add(instruction);\n            const { blockhash } = await connection.getLatestBlockhash(\"processed\");\n            transaction.recentBlockhash = blockhash;\n            transaction.feePayer = publicKey;\n            console.log(\"\\uD83D\\uDE80 Sending unlike transaction...\");\n            const signature = await sendTransaction(transaction, connection, {\n                skipPreflight: false,\n                preflightCommitment: \"processed\",\n                maxRetries: 3\n            });\n            await connection.confirmTransaction({\n                signature,\n                blockhash,\n                lastValidBlockHeight: (await connection.getLatestBlockhash()).lastValidBlockHeight\n            }, \"processed\");\n            console.log(\"✅ Transaction confirmed! Post unliked successfully!\");\n            // Remove user like from localStorage\n            if (publicKey) {\n                removeUserLike(publicKey.toString(), postId);\n                console.log(\"\\uD83D\\uDCDD Removed like for user \".concat(publicKey.toString().slice(0, 8), \" on post \").concat(postId));\n            }\n            // Clear posts cache to force refresh\n            postsCache = null;\n            return signature;\n        } catch (error) {\n            console.error(\"❌ Unlike post error:\", error);\n            throw error;\n        }\n    };\n    // Check specific profile PDA - for debugging profile detection issues\n    const checkProfileAtPDA = async (pdaAddress)=>{\n        try {\n            console.log(\"\\uD83D\\uDD0D Checking specific PDA: \".concat(pdaAddress));\n            const pda = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(pdaAddress);\n            const accountInfo = await connection.getAccountInfo(pda);\n            if (!accountInfo) {\n                console.log(\"❌ No account found at PDA: \".concat(pdaAddress));\n                return;\n            }\n            console.log(\"✅ Account exists! Owner: \".concat(accountInfo.owner.toString(), \", Size: \").concat(accountInfo.data.length, \" bytes\"));\n            // Inspect raw data\n            console.log(\"\\uD83D\\uDD0D Raw data (first 100 bytes):\", Array.from(accountInfo.data.slice(0, 100)));\n            if (accountInfo.owner.equals(PROGRAM_ID)) {\n                console.log(\"✅ Account is owned by our program\");\n                try {\n                    // Try manual parsing to understand the structure\n                    let offset = 0;\n                    const is_initialized = accountInfo.data[offset];\n                    offset += 1;\n                    console.log(\"\\uD83D\\uDCCA is_initialized: \".concat(is_initialized));\n                    const owner = accountInfo.data.slice(offset, offset + 32);\n                    offset += 32;\n                    console.log(\"\\uD83D\\uDCCA owner: \".concat(new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(owner).toString()));\n                    // Try to read the username length (Borsh string format: 4 bytes length + string)\n                    const usernameLength = accountInfo.data.readUInt32LE(offset);\n                    offset += 4;\n                    console.log(\"\\uD83D\\uDCCA username length: \".concat(usernameLength));\n                    if (usernameLength > 0 && usernameLength < 100) {\n                        const username = accountInfo.data.slice(offset, offset + usernameLength).toString(\"utf8\");\n                        console.log('\\uD83D\\uDCCA username: \"'.concat(username, '\"'));\n                    }\n                    // Now try manual parsing\n                    const profileAccount = manualParseProfile(accountInfo.data);\n                    if (profileAccount) {\n                        console.log(\"✅ Successfully manually parsed profile:\", {\n                            username: profileAccount.username,\n                            bio: profileAccount.bio,\n                            isInitialized: profileAccount.is_initialized === 1,\n                            owner: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(profileAccount.owner).toString(),\n                            profileImage: profileAccount.profile_image,\n                            coverImage: profileAccount.cover_image,\n                            postsCount: Number(profileAccount.posts_count)\n                        });\n                    } else {\n                        console.log(\"❌ Manual parsing failed\");\n                    }\n                    // Also try Borsh for comparison\n                    try {\n                        const profileAccount = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.deserialize)(profileAccountSchema, ProfileAccount, accountInfo.data);\n                        console.log(\"✅ Borsh deserialization also worked:\", {\n                            username: profileAccount.username,\n                            bio: profileAccount.bio,\n                            isInitialized: profileAccount.is_initialized === 1,\n                            owner: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(profileAccount.owner).toString()\n                        });\n                    } catch (error) {\n                        console.log(\"❌ Borsh deserialization still fails:\", error);\n                    }\n                } catch (error) {\n                    console.log(\"❌ Error checking PDA:\", error);\n                }\n            } else {\n                console.log(\"❌ Account is owned by different program: \".concat(accountInfo.owner.toString()));\n            }\n        } catch (error) {\n            console.log(\"❌ Error checking PDA:\", error);\n        }\n    };\n    // Manual profile parser - bypasses Borsh deserialization issues\n    const manualParseProfile = (data)=>{\n        try {\n            // Basic validation - profiles should have a minimum size\n            if (data.length < 150) return null // Profiles need at least 150 bytes for basic structure\n            ;\n            let offset = 0;\n            // Parse each field manually\n            const is_initialized = data[offset];\n            if (is_initialized !== 1) return null // Must be initialized\n            ;\n            offset += 1;\n            const owner = data.slice(offset, offset + 32);\n            offset += 32;\n            // Validate we have enough data for username length\n            if (offset + 4 > data.length) return null;\n            // String fields (username, bio, profile_image, cover_image)\n            const usernameLength = data.readUInt32LE(offset);\n            offset += 4;\n            // Validate username length is reasonable\n            if (usernameLength > 100 || usernameLength === 0) return null;\n            if (offset + usernameLength > data.length) return null;\n            const username = data.slice(offset, offset + usernameLength).toString(\"utf8\");\n            offset += usernameLength;\n            // Validate we have enough data for bio length\n            if (offset + 4 > data.length) return null;\n            const bioLength = data.readUInt32LE(offset);\n            offset += 4;\n            // Validate bio length is reasonable\n            if (bioLength > 1000) return null;\n            if (offset + bioLength > data.length) return null;\n            const bio = data.slice(offset, offset + bioLength).toString(\"utf8\");\n            offset += bioLength;\n            // Validate we have enough data for profile image length\n            if (offset + 4 > data.length) return null;\n            const profileImageLength = data.readUInt32LE(offset);\n            offset += 4;\n            // Validate profile image length is reasonable\n            if (profileImageLength > 500) return null;\n            if (offset + profileImageLength > data.length) return null;\n            const profile_image = data.slice(offset, offset + profileImageLength).toString(\"utf8\");\n            offset += profileImageLength;\n            // Validate we have enough data for cover image length\n            if (offset + 4 > data.length) return null;\n            const coverImageLength = data.readUInt32LE(offset);\n            offset += 4;\n            // Validate cover image length is reasonable\n            if (coverImageLength > 500) return null;\n            if (offset + coverImageLength > data.length) return null;\n            const cover_image = data.slice(offset, offset + coverImageLength).toString(\"utf8\");\n            offset += coverImageLength;\n            // Validate we have enough data for all the u64 fields (8 bytes each * 6 fields = 48 bytes)\n            if (offset + 48 > data.length) return null;\n            // u64 fields\n            const created_at = data.readBigUInt64LE(offset);\n            offset += 8;\n            const followers_count = data.readBigUInt64LE(offset);\n            offset += 8;\n            const following_count = data.readBigUInt64LE(offset);\n            offset += 8;\n            // i64 field\n            const user_credit_rating = data.readBigInt64LE(offset);\n            offset += 8;\n            const posts_count = data.readBigUInt64LE(offset);\n            offset += 8;\n            const last_post_timestamp = data.readBigUInt64LE(offset);\n            offset += 8;\n            const daily_post_count = data.readBigUInt64LE(offset);\n            offset += 8;\n            // Validate we have enough data for the final u8 field\n            if (offset + 1 > data.length) return null;\n            const is_verified = data[offset];\n            offset += 1;\n            return new ProfileAccount({\n                is_initialized,\n                owner: new Uint8Array(owner),\n                username,\n                bio,\n                profile_image,\n                cover_image,\n                created_at,\n                followers_count,\n                following_count,\n                user_credit_rating,\n                posts_count,\n                last_post_timestamp,\n                daily_post_count,\n                is_verified\n            });\n        } catch (error) {\n            // Silent failure - not a profile account or invalid data\n            return null;\n        }\n    };\n    // Manual post parser - bypasses Borsh deserialization issues\n    const manualParsePost = (data)=>{\n        try {\n            // Quick validation: posts should have specific size and structure\n            if (data.length < 100) return null // Posts should be larger than profiles\n            ;\n            let offset = 0;\n            // Parse each field manually\n            const is_initialized = data[offset];\n            if (is_initialized !== 1) return null // Must be initialized\n            ;\n            offset += 1;\n            // Check if this looks like a post vs profile by examining the structure\n            // Posts start with: u8 (init), u64 (id), [32]u8 (author), string (content)\n            // Profiles start with: u8 (init), [32]u8 (owner), string (username)\n            const id = data.readBigUInt64LE(offset);\n            offset += 8;\n            const author = data.slice(offset, offset + 32);\n            offset += 32;\n            const contentLength = data.readUInt32LE(offset);\n            offset += 4;\n            // Validate content length is reasonable (not too large)\n            if (contentLength > 10000 || contentLength === 0) return null;\n            if (offset + contentLength > data.length) return null;\n            const content = data.slice(offset, offset + contentLength).toString(\"utf8\");\n            offset += contentLength;\n            // Ensure we have enough remaining data for the rest of the post structure\n            if (offset + 40 > data.length) return null // Need at least 40 more bytes for timestamps and counts\n            ;\n            const timestamp = data.readBigUInt64LE(offset);\n            offset += 8;\n            const likes = data.readBigUInt64LE(offset);\n            offset += 8;\n            const comments = data.readBigUInt64LE(offset);\n            offset += 8;\n            const mirrors = data.readBigUInt64LE(offset);\n            offset += 8;\n            // Parse images array length\n            if (offset + 4 > data.length) return null;\n            const imagesLength = data.readUInt32LE(offset);\n            offset += 4;\n            const images = [];\n            // Parse images array - each image is a length-prefixed string\n            for(let i = 0; i < imagesLength; i++){\n                if (offset + 4 > data.length) return null;\n                const imageLength = data.readUInt32LE(offset);\n                offset += 4;\n                if (offset + imageLength > data.length) return null;\n                const image = data.slice(offset, offset + imageLength).toString(\"utf8\");\n                offset += imageLength;\n                images.push(image);\n            }\n            // Ensure we have enough data for rating and kill zone\n            if (offset + 2 > data.length) return null;\n            const rating = data[offset];\n            offset += 1;\n            const in_kill_zone = data[offset];\n            offset += 1;\n            return new PostAccount({\n                is_initialized,\n                id,\n                author: new Uint8Array(author),\n                content,\n                timestamp,\n                likes,\n                comments,\n                mirrors,\n                images,\n                rating,\n                in_kill_zone\n            });\n        } catch (error) {\n            // Silent failure - not a post account\n            return null;\n        }\n    };\n    // Convert CommunityAccount to Community interface\n    const convertCommunityAccount = (communityAccount)=>{\n        return {\n            isInitialized: communityAccount.is_initialized === 1,\n            id: Number(communityAccount.id),\n            creator: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(communityAccount.creator),\n            name: communityAccount.name,\n            description: communityAccount.description,\n            avatar: communityAccount.avatar,\n            rules: communityAccount.rules,\n            memberCount: Number(communityAccount.member_count),\n            createdAt: Number(communityAccount.created_at) * 1000,\n            isPrivate: communityAccount.is_private === 1\n        };\n    };\n    // Create Community\n    const createCommunity = async function(name, description, avatar) {\n        let rules = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83C\\uDFD8️ Creating community:\", name);\n            const balance = await checkSOLBalance();\n            if (balance < 0.05) {\n                throw new Error(\"Insufficient SOL balance: \".concat(balance, \". Need at least 0.05 SOL.\"));\n            }\n            // Generate a keypair for the community account\n            const communityKeypair = _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Keypair.generate();\n            console.log(\"\\uD83D\\uDCCD Community Account: \".concat(communityKeypair.publicKey.toString()));\n            const instructionData = new CreateCommunityInstruction({\n                name,\n                description,\n                avatar,\n                rules\n            });\n            const createCommunityVariant = Buffer.from([\n                7\n            ]) // CreateCommunity enum index\n            ;\n            const serializedData = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.serialize)(createCommunitySchema, instructionData);\n            const fullInstructionData = Buffer.concat([\n                createCommunityVariant,\n                Buffer.from(serializedData)\n            ]);\n            const instruction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: communityKeypair.publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.SystemProgram.programId,\n                        isSigner: false,\n                        isWritable: false\n                    }\n                ],\n                programId: PROGRAM_ID,\n                data: fullInstructionData\n            });\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction().add(instruction);\n            const { blockhash } = await connection.getLatestBlockhash(\"processed\");\n            transaction.recentBlockhash = blockhash;\n            transaction.feePayer = publicKey;\n            // Sign with community keypair\n            transaction.partialSign(communityKeypair);\n            const signature = await sendTransaction(transaction, connection, {\n                skipPreflight: false,\n                preflightCommitment: \"processed\",\n                maxRetries: 3,\n                signers: [\n                    communityKeypair\n                ]\n            });\n            await connection.confirmTransaction({\n                signature,\n                blockhash,\n                lastValidBlockHeight: (await connection.getLatestBlockhash()).lastValidBlockHeight\n            }, \"processed\");\n            console.log(\"✅ Community created successfully!\");\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.success('Community \"'.concat(name, '\" created successfully!'));\n            return signature;\n        } catch (error) {\n            console.error(\"❌ Community creation error:\", error);\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Failed to create community: \".concat(error.message || \"Unknown error\"));\n            throw error;\n        }\n    };\n    // Follow Profile\n    const followProfile = async (profilePublicKey)=>{\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83D\\uDC65 Following profile:\", profilePublicKey.toString());\n            // Check SOL balance first\n            const balance = await checkSOLBalance();\n            console.log(\"\\uD83D\\uDCB0 Current SOL balance: \".concat(balance));\n            if (balance < 0.01) {\n                throw new Error(\"Insufficient SOL balance: \".concat(balance, \". Need at least 0.01 SOL for transaction fees.\"));\n            }\n            // Ensure profilePublicKey is a proper PublicKey instance\n            let targetOwnerKey;\n            if (profilePublicKey instanceof _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey) {\n                targetOwnerKey = profilePublicKey;\n            } else if (typeof profilePublicKey === \"string\") {\n                targetOwnerKey = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(profilePublicKey);\n                console.log(\"\\uD83D\\uDD04 Converted string to PublicKey:\", targetOwnerKey.toString());\n            } else {\n                throw new Error(\"Invalid profilePublicKey type: \".concat(typeof profilePublicKey));\n            }\n            // Find both the target profile account and follower profile account\n            console.log(\"\\uD83D\\uDD0D Searching for target profile owned by: \".concat(targetOwnerKey.toString().slice(0, 8), \"...\"));\n            console.log(\"\\uD83D\\uDD0D Searching for follower profile owned by: \".concat(publicKey.toString().slice(0, 8), \"...\"));\n            const accounts = await connection.getProgramAccounts(PROGRAM_ID);\n            let targetProfileAddress = null;\n            let followerProfileAddress = null;\n            for (const { account, pubkey } of accounts){\n                try {\n                    // Check if account belongs to our program\n                    const accountInfo = await connection.getAccountInfo(pubkey);\n                    if (!accountInfo || !accountInfo.owner.equals(PROGRAM_ID)) {\n                        console.log(\"⚠️ Account \".concat(pubkey.toString().slice(0, 8), \" doesn't belong to our program (owner: \").concat(accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.owner.toString(), \")\"));\n                        continue;\n                    }\n                    const parsedProfile = manualParseProfile(account.data);\n                    if (parsedProfile && parsedProfile.is_initialized === 1) {\n                        const profileOwner = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(parsedProfile.owner);\n                        // Check if this is the target profile (owned by the person we want to follow)\n                        if (profileOwner.equals(targetOwnerKey)) {\n                            // If we already found a target profile, prefer the first one (or you could add logic to pick a specific one)\n                            if (!targetProfileAddress) {\n                                targetProfileAddress = pubkey;\n                                console.log(\"\\uD83C\\uDFAF Found target profile account: \".concat(pubkey.toString()));\n                                console.log(\"   Owner: \".concat(profileOwner.toString()));\n                                console.log(\"   Username: \".concat(parsedProfile.username));\n                            } else {\n                                console.log(\"⚠️ Found additional profile for same owner: \".concat(pubkey.toString(), \" (\").concat(parsedProfile.username, \") - skipping\"));\n                            }\n                        }\n                        // Check if this is the follower's profile (current user)\n                        if (profileOwner.equals(publicKey)) {\n                            // If we already found a follower profile, prefer the first one\n                            if (!followerProfileAddress) {\n                                followerProfileAddress = pubkey;\n                                console.log(\"✅ Found follower profile account: \".concat(pubkey.toString()));\n                                console.log(\"   Owner: \".concat(profileOwner.toString()));\n                                console.log(\"   Username: \".concat(parsedProfile.username));\n                            } else {\n                                console.log(\"⚠️ Found additional profile for follower: \".concat(pubkey.toString(), \" (\").concat(parsedProfile.username, \") - skipping\"));\n                            }\n                        }\n                    }\n                } catch (error) {\n                    continue;\n                }\n            }\n            if (!targetProfileAddress) {\n                throw new Error(\"Target profile owned by \".concat(targetOwnerKey.toString().slice(0, 8), \" not found on blockchain. Make sure this user has created a profile.\"));\n            }\n            if (!followerProfileAddress) {\n                throw new Error(\"You must create a profile before following others\");\n            }\n            const instructionData = new FollowProfileInstruction({\n                profile_id: targetProfileAddress\n            });\n            const followProfileVariant = Buffer.from([\n                5\n            ]) // FollowProfile enum index\n            ;\n            const serializedData = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.serialize)(followProfileSchema, instructionData);\n            const fullInstructionData = Buffer.concat([\n                followProfileVariant,\n                Buffer.from(serializedData)\n            ]);\n            console.log(\"\\uD83D\\uDD22 Instruction data: variant [5], serialized length: \".concat(serializedData.length, \", total: \").concat(fullInstructionData.length, \" bytes\"));\n            console.log(\"\\uD83D\\uDD22 Using target profile account address in instruction: \".concat(targetProfileAddress.toString()));\n            // Debug: verify all pubkeys are proper PublicKey instances and belong to our program\n            console.log(\"\\uD83D\\uDD0D Verifying transaction keys:\");\n            console.log(\"  publicKey (follower):\", publicKey.toString(), \"instanceof PublicKey:\", publicKey instanceof _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey);\n            console.log(\"  targetProfileAddress (account):\", targetProfileAddress.toString(), \"instanceof PublicKey:\", targetProfileAddress instanceof _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey);\n            console.log(\"  followerProfileAddress (account):\", followerProfileAddress.toString(), \"instanceof PublicKey:\", followerProfileAddress instanceof _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey);\n            console.log(\"  PROGRAM_ID:\", PROGRAM_ID.toString());\n            // Verify account ownership\n            const targetAccountInfo = await connection.getAccountInfo(targetProfileAddress);\n            const followerAccountInfo = await connection.getAccountInfo(followerProfileAddress);\n            console.log(\"\\uD83D\\uDD0D Account ownership verification:\");\n            console.log(\"  Target profile owner:\", targetAccountInfo === null || targetAccountInfo === void 0 ? void 0 : targetAccountInfo.owner.toString());\n            console.log(\"  Follower profile owner:\", followerAccountInfo === null || followerAccountInfo === void 0 ? void 0 : followerAccountInfo.owner.toString());\n            console.log(\"  Expected owner (PROGRAM_ID):\", PROGRAM_ID.toString());\n            console.log(\"  Target profile owned by:\", targetOwnerKey.toString());\n            // Smart contract expects this EXACT account order:\n            // 0. follower_account (signer, writable) - The follower's wallet\n            // 1. followed_profile_account (writable) - The profile account to follow  \n            // 2. follower_profile_account (writable) - The follower's profile account\n            const instruction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: targetProfileAddress,\n                        isSigner: false,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: followerProfileAddress,\n                        isSigner: false,\n                        isWritable: true\n                    }\n                ],\n                programId: PROGRAM_ID,\n                data: fullInstructionData\n            });\n            console.log(\"\\uD83D\\uDD11 Transaction instruction created\");\n            console.log(\"\\uD83D\\uDD11 Keys:\", instruction.keys.map((k)=>({\n                    pubkey: k.pubkey.toString(),\n                    isSigner: k.isSigner,\n                    isWritable: k.isWritable\n                })));\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction().add(instruction);\n            const { blockhash } = await connection.getLatestBlockhash(\"processed\");\n            transaction.recentBlockhash = blockhash;\n            transaction.feePayer = publicKey;\n            // Simulate transaction before sending\n            console.log(\"\\uD83C\\uDFAF Simulating transaction...\");\n            const simulation = await connection.simulateTransaction(transaction);\n            console.log(\"\\uD83D\\uDCCA Simulation result:\", simulation);\n            if (simulation.value.err) {\n                throw new Error(\"Transaction simulation failed: \".concat(JSON.stringify(simulation.value.err)));\n            }\n            console.log(\"✅ Transaction simulation successful\");\n            console.log(\"\\uD83D\\uDE80 Sending transaction...\");\n            const signature = await sendTransaction(transaction, connection, {\n                skipPreflight: false,\n                preflightCommitment: \"processed\",\n                maxRetries: 3\n            });\n            console.log(\"\\uD83D\\uDCCB Transaction sent with signature: \".concat(signature));\n            console.log(\"⏳ Confirming transaction...\");\n            await connection.confirmTransaction({\n                signature,\n                blockhash,\n                lastValidBlockHeight: (await connection.getLatestBlockhash()).lastValidBlockHeight\n            }, \"processed\");\n            console.log(\"✅ Transaction confirmed! Profile followed successfully!\");\n            // Track the follow in localStorage\n            if (publicKey) {\n                addUserFollow(publicKey.toString(), targetOwnerKey.toString());\n            }\n            // Clear profile cache to force refresh of follower counts for both profiles\n            clearProfileCache(publicKey.toString()) // Clear follower's profile cache\n            ;\n            clearProfileCache(targetOwnerKey.toString()) // Clear target's profile cache\n            ;\n            clearProfileCache() // Clear all caches to be safe\n            ;\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.success(\"Profile followed!\");\n            return signature;\n        } catch (error) {\n            var _error_message, _error_message1, _error_message2, _error_message3;\n            console.error(\"❌ Follow error:\", error);\n            // More specific error messages\n            if ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"insufficient funds\")) {\n                const balance = await checkSOLBalance();\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Insufficient SOL: \".concat(balance.toFixed(4), \" SOL. Need at least 0.01 SOL for fees.\"));\n            } else if ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes(\"simulation failed\")) {\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Transaction would fail: Check accounts and permissions\");\n                console.error(\"Simulation error details:\", error.message);\n            } else if ((_error_message2 = error.message) === null || _error_message2 === void 0 ? void 0 : _error_message2.includes(\"not found on blockchain\")) {\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Profile not found: User may not have created a profile yet\");\n            } else if ((_error_message3 = error.message) === null || _error_message3 === void 0 ? void 0 : _error_message3.includes(\"Unexpected error\")) {\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Wallet transaction failed: Check connection and try again\");\n            } else {\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Failed to follow profile: \".concat(error.message || \"Unknown error\"));\n            }\n            throw error;\n        }\n    };\n    // Unfollow Profile\n    const unfollowProfile = async (profilePublicKey)=>{\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83D\\uDC65 Unfollowing profile:\", profilePublicKey.toString());\n            // Ensure profilePublicKey is a proper PublicKey instance\n            let targetProfileKey;\n            if (profilePublicKey instanceof _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey) {\n                targetProfileKey = profilePublicKey;\n            } else if (typeof profilePublicKey === \"string\") {\n                targetProfileKey = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(profilePublicKey);\n                console.log(\"\\uD83D\\uDD04 Converted string to PublicKey:\", targetProfileKey.toString());\n            } else {\n                throw new Error(\"Invalid profilePublicKey type: \".concat(typeof profilePublicKey));\n            }\n            // Find the follower's profile account (current user's profile)\n            console.log(\"\\uD83D\\uDD0D Searching for follower profile: \".concat(publicKey.toString().slice(0, 8), \"...\"));\n            const accounts = await connection.getProgramAccounts(PROGRAM_ID);\n            let followerProfileAddress = null;\n            for (const { account, pubkey } of accounts){\n                try {\n                    const parsedProfile = manualParseProfile(account.data);\n                    if (parsedProfile && parsedProfile.is_initialized === 1 && new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(parsedProfile.owner).equals(publicKey)) {\n                        followerProfileAddress = pubkey;\n                        console.log(\"✅ Found follower profile account: \".concat(pubkey.toString()));\n                        break;\n                    }\n                } catch (error) {\n                    continue;\n                }\n            }\n            if (!followerProfileAddress) {\n                throw new Error(\"You must create a profile before unfollowing others\");\n            }\n            const instructionData = new FollowProfileInstruction({\n                profile_id: targetProfileKey\n            });\n            const unfollowProfileVariant = Buffer.from([\n                6\n            ]) // UnfollowProfile enum index\n            ;\n            const serializedData = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.serialize)(followProfileSchema, instructionData);\n            const fullInstructionData = Buffer.concat([\n                unfollowProfileVariant,\n                Buffer.from(serializedData)\n            ]);\n            const instruction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: publicKey,\n                        isSigner: true,\n                        isWritable: false\n                    },\n                    {\n                        pubkey: targetProfileKey,\n                        isSigner: false,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: followerProfileAddress,\n                        isSigner: false,\n                        isWritable: true\n                    }\n                ],\n                programId: PROGRAM_ID,\n                data: fullInstructionData\n            });\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction().add(instruction);\n            const signature = await sendTransaction(transaction, connection);\n            await connection.confirmTransaction(signature, \"processed\");\n            // Track the unfollow in localStorage\n            if (publicKey) {\n                removeUserFollow(publicKey.toString(), targetProfileKey.toString());\n            }\n            // Clear profile cache to force refresh of follower counts for both profiles\n            clearProfileCache(publicKey.toString()) // Clear follower's profile cache\n            ;\n            clearProfileCache(targetProfileKey.toString()) // Clear target's profile cache\n            ;\n            clearProfileCache() // Clear all caches to be safe\n            ;\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.success(\"Profile unfollowed!\");\n            return signature;\n        } catch (error) {\n            console.error(\"Unfollow error:\", error);\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Failed to unfollow profile\");\n            throw error;\n        }\n    };\n    // Update Profile\n    const updateProfile = async (username, bio, profileImage, coverImage)=>{\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83D\\uDD04 Updating profile:\", username);\n            const instructionData = new CreateProfileInstruction({\n                username,\n                bio,\n                profile_image: profileImage,\n                cover_image: coverImage\n            });\n            const updateProfileVariant = Buffer.from([\n                1\n            ]) // UpdateProfile enum index (same as CreateProfile)\n            ;\n            const serializedData = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.serialize)(createProfileSchema, instructionData);\n            const fullInstructionData = Buffer.concat([\n                updateProfileVariant,\n                Buffer.from(serializedData)\n            ]);\n            const instruction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    }\n                ],\n                programId: PROGRAM_ID,\n                data: fullInstructionData\n            });\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction().add(instruction);\n            const signature = await sendTransaction(transaction, connection);\n            await connection.confirmTransaction(signature, \"processed\");\n            console.log(\"✅ Profile updated successfully!\");\n            // Clear cache to force refresh\n            profileCache.delete(publicKey.toString());\n            return signature;\n        } catch (error) {\n            console.error(\"❌ Update profile error:\", error);\n            throw error;\n        }\n    };\n    // Comment on Post - REAL BLOCKCHAIN IMPLEMENTATION\n    const commentOnPost = async (postId, content, postAuthor)=>{\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83D\\uDCAC Creating comment on post ID \".concat(postId, \"...\"));\n            // Check SOL balance\n            const balance = await checkSOLBalance();\n            if (balance < 0.05) {\n                throw new Error(\"Insufficient SOL balance: \".concat(balance, \". You need at least 0.05 SOL for transaction fees and account creation.\"));\n            }\n            // Get user's profile for the comment\n            const userProfile = await getProfile(publicKey);\n            if (!userProfile) {\n                throw new Error(\"You must create a profile before commenting\");\n            }\n            // Find the parent post account by scanning all program accounts\n            console.log(\"\\uD83D\\uDD0D Searching for post ID \".concat(postId, \" by author \").concat(postAuthor.toString().slice(0, 8), \"...\"));\n            const accounts = await connection.getProgramAccounts(PROGRAM_ID);\n            let parentPostAccountAddress = null;\n            let parentPostAccount = null;\n            let userProfileAccountAddress = null;\n            // First pass: find the parent post account\n            for (const { account, pubkey } of accounts){\n                try {\n                    const parsedPost = manualParsePost(account.data);\n                    if (parsedPost && parsedPost.is_initialized === 1 && Number(parsedPost.id) === postId && new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(parsedPost.author).equals(postAuthor)) {\n                        parentPostAccountAddress = pubkey;\n                        parentPostAccount = parsedPost;\n                        console.log(\"\\uD83C\\uDFAF Found parent post ID \".concat(postId, \" at address: \").concat(pubkey.toString()));\n                        break;\n                    }\n                } catch (error) {\n                    continue;\n                }\n            }\n            if (!parentPostAccountAddress || !parentPostAccount) {\n                throw new Error(\"Parent post ID \".concat(postId, \" by author \").concat(postAuthor.toString().slice(0, 8), \" not found on blockchain\"));\n            }\n            // Second pass: find the user's profile account\n            console.log(\"\\uD83D\\uDD0D Searching for user's profile: \".concat(publicKey.toString().slice(0, 8), \"...\"));\n            for (const { account, pubkey } of accounts){\n                try {\n                    const parsedProfile = manualParseProfile(account.data);\n                    if (parsedProfile && parsedProfile.is_initialized === 1 && new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(parsedProfile.owner).equals(publicKey)) {\n                        userProfileAccountAddress = pubkey;\n                        console.log(\"✅ Found user profile account: \".concat(pubkey.toString()));\n                        break;\n                    }\n                } catch (error) {\n                    continue;\n                }\n            }\n            if (!userProfileAccountAddress) {\n                throw new Error(\"User's profile not found for \".concat(publicKey.toString().slice(0, 8)));\n            }\n            // Generate a new keypair for the comment account\n            const commentKeypair = _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Keypair.generate();\n            console.log(\"\\uD83D\\uDCCD Comment account: \".concat(commentKeypair.publicKey.toString()));\n            const instructionData = new CommentOnPostInstruction({\n                content: content,\n                parent_id: BigInt(postId)\n            });\n            const commentOnPostVariant = Buffer.from([\n                4\n            ]) // CommentOnPost instruction variant\n            ;\n            const serializedData = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.serialize)(commentOnPostSchema, instructionData);\n            const fullInstructionData = Buffer.concat([\n                commentOnPostVariant,\n                Buffer.from(serializedData)\n            ]);\n            console.log(\"\\uD83D\\uDD22 Instruction data: variant [4], serialized length: \".concat(serializedData.length, \", total: \").concat(fullInstructionData.length, \" bytes\"));\n            const instruction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: commentKeypair.publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: parentPostAccountAddress,\n                        isSigner: false,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: userProfileAccountAddress,\n                        isSigner: false,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.SystemProgram.programId,\n                        isSigner: false,\n                        isWritable: false\n                    }\n                ],\n                programId: PROGRAM_ID,\n                data: fullInstructionData\n            });\n            console.log(\"\\uD83D\\uDD11 Transaction accounts:\");\n            console.log(\"  User (commenter): \".concat(publicKey.toString(), \" (signer, writable)\"));\n            console.log(\"  Comment: \".concat(commentKeypair.publicKey.toString(), \" (signer, writable)\"));\n            console.log(\"  Parent Post: \".concat(parentPostAccountAddress.toString(), \" (not signer, writable)\"));\n            console.log(\"  User Profile: \".concat(userProfileAccountAddress.toString(), \" (not signer, writable)\"));\n            console.log(\"  System Program: \".concat(_solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.SystemProgram.programId.toString()));\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction().add(instruction);\n            const { blockhash } = await connection.getLatestBlockhash(\"processed\");\n            transaction.recentBlockhash = blockhash;\n            transaction.feePayer = publicKey;\n            // The comment account must sign the transaction\n            transaction.partialSign(commentKeypair);\n            // Simulate transaction before sending\n            console.log(\"\\uD83C\\uDFAF Simulating transaction...\");\n            const simulation = await connection.simulateTransaction(transaction);\n            console.log(\"\\uD83D\\uDCCA Simulation result:\", simulation);\n            if (simulation.value.err) {\n                throw new Error(\"Transaction simulation failed: \".concat(JSON.stringify(simulation.value.err)));\n            }\n            console.log(\"✅ Transaction simulation successful\");\n            console.log(\"\\uD83D\\uDE80 Sending transaction...\");\n            const signature = await sendTransaction(transaction, connection, {\n                skipPreflight: false,\n                preflightCommitment: \"processed\",\n                maxRetries: 3,\n                signers: [\n                    commentKeypair\n                ]\n            });\n            console.log(\"\\uD83D\\uDCCB Transaction sent with signature: \".concat(signature));\n            console.log(\"⏳ Confirming transaction...\");\n            await connection.confirmTransaction({\n                signature,\n                blockhash,\n                lastValidBlockHeight: (await connection.getLatestBlockhash()).lastValidBlockHeight\n            }, \"processed\");\n            console.log(\"✅ Transaction confirmed! Comment created successfully!\");\n            // Track this comment account so we can distinguish it from regular posts\n            trackCommentAccount(commentKeypair.publicKey.toString(), postId);\n            // Clear posts cache to force refresh\n            postsCache = null;\n            // Also store comment locally for immediate display\n            const comment = {\n                id: Date.now(),\n                parentPostId: postId,\n                author: publicKey,\n                content: content,\n                timestamp: Date.now(),\n                likes: 0,\n                authorProfile: userProfile\n            };\n            storeComment(postId, comment);\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.success(\"Comment posted!\");\n            return signature;\n        } catch (error) {\n            var _error_message, _error_message1, _error_message2;\n            console.error(\"❌ Comment creation error:\", error);\n            // More specific error messages\n            if ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"insufficient funds\")) {\n                const balance = await checkSOLBalance();\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Insufficient SOL: \".concat(balance.toFixed(4), \" SOL. Need at least 0.05 SOL for fees and account creation.\"));\n            } else if ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes(\"simulation failed\")) {\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Transaction would fail: Check post exists and wallet has permission\");\n                console.error(\"Simulation error details:\", error.message);\n            } else if ((_error_message2 = error.message) === null || _error_message2 === void 0 ? void 0 : _error_message2.includes(\"not found on blockchain\")) {\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Post not found on blockchain\");\n            } else {\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Failed to comment: \".concat(error.message || \"Unknown error\"));\n            }\n            throw error;\n        }\n    };\n    // Bookmark Post (using localStorage since we don't have bookmark functionality)\n    const bookmarkPost = async (postId)=>{\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83D\\uDD16 Bookmarking post ID \".concat(postId, \"...\"));\n            const bookmarksKey = \"bookmarks_\".concat(publicKey.toString());\n            const existingBookmarks = localStorage.getItem(bookmarksKey);\n            const bookmarks = existingBookmarks ? JSON.parse(existingBookmarks) : [];\n            if (bookmarks.includes(postId)) {\n                // Remove bookmark\n                const updatedBookmarks = bookmarks.filter((id)=>id !== postId);\n                localStorage.setItem(bookmarksKey, JSON.stringify(updatedBookmarks));\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.success(\"Bookmark removed!\");\n            } else {\n                // Add bookmark\n                bookmarks.push(postId);\n                localStorage.setItem(bookmarksKey, JSON.stringify(bookmarks));\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.success(\"Post bookmarked!\");\n            }\n            return \"bookmarked\";\n        } catch (error) {\n            console.error(\"❌ Bookmark error:\", error);\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Failed to bookmark post\");\n            throw error;\n        }\n    };\n    // Get user bookmarks\n    const getUserBookmarks = ()=>{\n        if (!publicKey) return [];\n        try {\n            const bookmarksKey = \"bookmarks_\".concat(publicKey.toString());\n            const existingBookmarks = localStorage.getItem(bookmarksKey);\n            return existingBookmarks ? JSON.parse(existingBookmarks) : [];\n        } catch (error) {\n            console.error(\"Failed to get bookmarks:\", error);\n            return [];\n        }\n    };\n    // Check if post is bookmarked\n    const isPostBookmarked = (postId)=>{\n        const bookmarks = getUserBookmarks();\n        return bookmarks.includes(postId);\n    };\n    // Utility function to preload profile on wallet connection\n    const preloadProfile = async ()=>{\n        if (!publicKey) return;\n        console.log(\"\\uD83D\\uDE80 Preloading profile on wallet connection...\");\n        try {\n            await getProfile(publicKey);\n        } catch (error) {\n            console.warn(\"Failed to preload profile:\", error);\n        }\n    };\n    // Force refresh all data - clears all caches\n    const refreshData = ()=>{\n        console.log(\"\\uD83D\\uDD04 Force refreshing all data...\");\n        clearProfileCache();\n        postsCache = null;\n        // Clear comments storage\n        commentsStorage = {};\n        // Clear comment tracking data\n        try {\n            localStorage.removeItem(getCommentAccountsKey());\n            localStorage.removeItem(getCommentMappingKey());\n            console.log(\"\\uD83D\\uDDD1️ Cleared comment tracking data\");\n        } catch (error) {\n            console.error(\"Failed to clear comment tracking data:\", error);\n        }\n    };\n    // Force refresh a specific user's profile (useful after follow/unfollow)\n    const refreshUserProfile = async (userPublicKey)=>{\n        console.log(\"\\uD83D\\uDD04 Force refreshing profile for: \".concat(userPublicKey.toString().slice(0, 8)));\n        // Clear all caches for this user\n        clearProfileCache(userPublicKey.toString());\n        // Force fetch fresh data from blockchain\n        try {\n            const freshProfile = await getProfile(userPublicKey);\n            console.log(\"✅ Refreshed profile for \".concat(userPublicKey.toString().slice(0, 8), \":\"), {\n                username: freshProfile === null || freshProfile === void 0 ? void 0 : freshProfile.username,\n                followersCount: freshProfile === null || freshProfile === void 0 ? void 0 : freshProfile.followersCount,\n                followingCount: freshProfile === null || freshProfile === void 0 ? void 0 : freshProfile.followingCount\n            });\n            return freshProfile;\n        } catch (error) {\n            console.error(\"Failed to refresh user profile:\", error);\n            return null;\n        }\n    };\n    // Check if user is following another user - hybrid approach\n    const isFollowingUser = async (followerPublicKey, targetPublicKey)=>{\n        try {\n            console.log(\"\\uD83D\\uDD0D Checking follow state: \".concat(followerPublicKey.toString().slice(0, 8), \" -> \").concat(targetPublicKey.toString().slice(0, 8)));\n            // First check localStorage for immediate feedback\n            const localStorageKey = \"user_follows_\".concat(followerPublicKey.toString());\n            const storedFollows = localStorage.getItem(localStorageKey);\n            const followsList = storedFollows ? JSON.parse(storedFollows) : [];\n            const isFollowingInLocalStorage = followsList.includes(targetPublicKey.toString());\n            console.log(\"\\uD83D\\uDCF1 localStorage check: \".concat(isFollowingInLocalStorage));\n            // Get both profiles to check follow counts\n            const [followerProfile, targetProfile] = await Promise.all([\n                getProfile(followerPublicKey),\n                getProfile(targetPublicKey)\n            ]);\n            if (!followerProfile || !targetProfile) {\n                console.log(\"❌ One or both profiles not found\");\n                return false;\n            }\n            console.log('\\uD83D\\uDCCA Follower \"'.concat(followerProfile.username, '\" following: ').concat(followerProfile.followingCount));\n            console.log('\\uD83D\\uDCCA Target \"'.concat(targetProfile.username, '\" followers: ').concat(targetProfile.followersCount));\n            // If localStorage says following and both have non-zero counts, likely following\n            if (isFollowingInLocalStorage && followerProfile.followingCount > 0 && targetProfile.followersCount > 0) {\n                console.log(\"✅ Confirmed following via localStorage + blockchain counts\");\n                return true;\n            }\n            // If localStorage says not following, trust that\n            if (!isFollowingInLocalStorage) {\n                console.log(\"❌ Not following according to localStorage\");\n                return false;\n            }\n            // Fallback: if localStorage is inconsistent, default to false to prevent double follows\n            console.log(\"⚠️ Inconsistent state, defaulting to not following\");\n            return false;\n        } catch (error) {\n            console.error(\"Error checking follow state:\", error);\n            return false;\n        }\n    };\n    return {\n        createProfile,\n        createPost,\n        likePost,\n        unlikePost,\n        getProfile,\n        getProfileByUsername,\n        getPosts,\n        getProfilePDA,\n        getPostPDA,\n        checkProfileAtPDA,\n        preloadProfile,\n        clearProfileCache,\n        refreshData,\n        refreshUserProfile,\n        createCommunity,\n        followProfile,\n        unfollowProfile,\n        updateProfile,\n        commentOnPost,\n        bookmarkPost,\n        getUserBookmarks,\n        isPostBookmarked,\n        getCommentsForPost,\n        hasUserLikedPost: (postId)=>publicKey ? hasUserLikedPost(publicKey.toString(), postId) : false,\n        getUserLikedPosts: ()=>publicKey ? getUserLikedPosts(publicKey.toString()) : [],\n        getUserFollowedProfiles: ()=>publicKey ? getUserFollowedProfiles(publicKey.toString()) : [],\n        addUserFollow: (profileOwnerKey)=>publicKey ? addUserFollow(publicKey.toString(), profileOwnerKey) : null,\n        removeUserFollow: (profileOwnerKey)=>publicKey ? removeUserFollow(publicKey.toString(), profileOwnerKey) : null,\n        isUserFollowingProfile: (profileOwnerKey)=>publicKey ? isUserFollowingProfile(publicKey.toString(), profileOwnerKey) : false,\n        isFollowingUser: (followerPublicKey, targetPublicKey)=>publicKey ? isFollowingUser(followerPublicKey, targetPublicKey) : false\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZUJsb2Nrc1Byb2dyYW0udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUF1RTtBQUNtRDtBQUM1RTtBQUNQO0FBQ047QUFFakMseURBQXlEO0FBQ3pELE1BQU1ZLGFBQWEsSUFBSVYsc0RBQVNBLENBQUNTLDJDQUFNQSxDQUFDRSxNQUFNLENBQUNDLFNBQVM7QUFFeEQsb0VBQW9FO0FBQ3BFLE1BQU1DLGFBQWFDLGtCQUF5Qjs7QUFFNUMsK0NBQStDO1VBQzFDQzs7Ozs7Ozs7OztHQUFBQSx3QkFBQUE7O1VBYU9DOzs7Ozs7Ozs7R0FBQUEsZUFBQUE7QUFXWix3Q0FBd0M7QUFDeEMsTUFBTUM7SUFNSkMsWUFBWUMsTUFLWCxDQUFFO1FBQ0QsSUFBSSxDQUFDQyxRQUFRLEdBQUdELE9BQU9DLFFBQVE7UUFDL0IsSUFBSSxDQUFDQyxHQUFHLEdBQUdGLE9BQU9FLEdBQUc7UUFDckIsSUFBSSxDQUFDQyxhQUFhLEdBQUdILE9BQU9HLGFBQWE7UUFDekMsSUFBSSxDQUFDQyxXQUFXLEdBQUdKLE9BQU9JLFdBQVc7SUFDdkM7QUFDRjtBQUVBLHFDQUFxQztBQUNyQyxNQUFNQztJQUlKTixZQUFZQyxNQUdYLENBQUU7UUFDRCxJQUFJLENBQUNNLE9BQU8sR0FBR04sT0FBT00sT0FBTztRQUM3QixJQUFJLENBQUNDLE1BQU0sR0FBR1AsT0FBT08sTUFBTTtJQUM3QjtBQUNGO0FBRUEsbUNBQW1DO0FBQ25DLE1BQU1DO0lBR0pULFlBQVlDLE1BRVgsQ0FBRTtRQUNELElBQUksQ0FBQ1MsT0FBTyxHQUFHVCxPQUFPUyxPQUFPO0lBQy9CO0FBQ0Y7QUFFQSx5Q0FBeUM7QUFDekMsTUFBTUM7SUFJSlgsWUFBWUMsTUFHWCxDQUFFO1FBQ0QsSUFBSSxDQUFDTSxPQUFPLEdBQUdOLE9BQU9NLE9BQU87UUFDN0IsSUFBSSxDQUFDSyxTQUFTLEdBQUdYLE9BQU9XLFNBQVM7SUFDbkM7QUFDRjtBQUVBLHVDQUF1QztBQUN2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N087UUFDQThPO1FBQ0FDO1FBQ0FoQztRQUNBRztRQUNBUztRQUNBRztRQUNBRTtRQUNBTTtRQUNBSztRQUNBQztRQUNBbkY7UUFDQXZILGtCQUFrQixDQUFDSixTQUFtQmhFLFlBQVlvRSxpQkFBaUJwRSxVQUFVNEYsUUFBUSxJQUFJNUIsVUFBVTtRQUNuR0osbUJBQW1CLElBQU01RCxZQUFZNEQsa0JBQWtCNUQsVUFBVTRGLFFBQVEsTUFBTSxFQUFFO1FBQ2pGckIseUJBQXlCLElBQU12RSxZQUFZdUUsd0JBQXdCdkUsVUFBVTRGLFFBQVEsTUFBTSxFQUFFO1FBQzdGbEIsZUFBZSxDQUFDQyxrQkFBNEIzRSxZQUFZMEUsY0FBYzFFLFVBQVU0RixRQUFRLElBQUlqQixtQkFBbUI7UUFDL0dDLGtCQUFrQixDQUFDRCxrQkFBNEIzRSxZQUFZNEUsaUJBQWlCNUUsVUFBVTRGLFFBQVEsSUFBSWpCLG1CQUFtQjtRQUNySEcsd0JBQXdCLENBQUNILGtCQUE0QjNFLFlBQVk4RSx1QkFBdUI5RSxVQUFVNEYsUUFBUSxJQUFJakIsbUJBQW1CO1FBQ2pJd00saUJBQWlCLENBQUNDLG1CQUE4QkMsa0JBQStCclIsWUFBWW1SLGdCQUFnQkMsbUJBQW1CQyxtQkFBbUI7SUFDbko7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ob29rcy91c2VCbG9ja3NQcm9ncmFtLnRzPzVlOGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlQ29ubmVjdGlvbiwgdXNlV2FsbGV0IH0gZnJvbSAnQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdCdcbmltcG9ydCB7IFB1YmxpY0tleSwgVHJhbnNhY3Rpb24sIFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24sIFN5c3RlbVByb2dyYW0sIExBTVBPUlRTX1BFUl9TT0wsIEtleXBhaXIgfSBmcm9tICdAc29sYW5hL3dlYjMuanMnXG5pbXBvcnQgeyBzZXJpYWxpemUsIGRlc2VyaWFsaXplIH0gZnJvbSAnYm9yc2gnXG5pbXBvcnQgeyB0b2FzdCB9IGZyb20gJ3JlYWN0LWhvdC10b2FzdCdcbmltcG9ydCB7IGNvbmZpZyB9IGZyb20gJ0AvY29uZmlnJ1xuXG4vLyBZb3VyIGRlcGxveWVkIHByb2dyYW0gSUQgLSBjb25maWd1cmVkIGZyb20gZW52aXJvbm1lbnRcbmNvbnN0IFBST0dSQU1fSUQgPSBuZXcgUHVibGljS2V5KGNvbmZpZy5zb2xhbmEucHJvZ3JhbUlkKVxuXG4vLyBBZGQgZGVidWcgbW9kZSBmb3IgdGVzdGluZyB3aXRob3V0IGFjdHVhbCBibG9ja2NoYWluIHRyYW5zYWN0aW9uc1xuY29uc3QgREVCVUdfTU9ERSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnXG5cbi8vIEluc3RydWN0aW9uIGVudW0gbWF0Y2hpbmcgeW91ciBSdXN0IGNvbnRyYWN0XG5lbnVtIENvbnRyYWN0SW5zdHJ1Y3Rpb24ge1xuICBDcmVhdGVQcm9maWxlID0gMCxcbiAgVXBkYXRlUHJvZmlsZSA9IDEsXG4gIENyZWF0ZVBvc3QgPSAyLFxuICBMaWtlUG9zdCA9IDMsXG4gIENvbW1lbnRPblBvc3QgPSA0LFxuICBGb2xsb3dQcm9maWxlID0gNSxcbiAgVW5mb2xsb3dQcm9maWxlID0gNixcbiAgQ3JlYXRlQ29tbXVuaXR5ID0gNyxcbiAgSm9pbkNvbW11bml0eSA9IDgsXG59XG5cbi8vIFBvc3RSYXRpbmcgZW51bSBtYXRjaGluZyBSdXN0IGNvbnRyYWN0XG5leHBvcnQgZW51bSBQb3N0UmF0aW5nIHtcbiAgTm9uZSA9IDAsXG4gIEJyb256ZSA9IDEsXG4gIFNpbHZlciA9IDIsXG4gIEdvbGQgPSAzLFxuICBQbGF0aW51bSA9IDQsXG4gIERpYW1vbmQgPSA1LFxuICBBY2UgPSA2LFxuICBDb25xdWVyb3IgPSA3LFxufVxuXG4vLyBDcmVhdGUgUHJvZmlsZSBpbnN0cnVjdGlvbiBkYXRhIGNsYXNzXG5jbGFzcyBDcmVhdGVQcm9maWxlSW5zdHJ1Y3Rpb24ge1xuICB1c2VybmFtZTogc3RyaW5nXG4gIGJpbzogc3RyaW5nXG4gIHByb2ZpbGVfaW1hZ2U6IHN0cmluZ1xuICBjb3Zlcl9pbWFnZTogc3RyaW5nXG5cbiAgY29uc3RydWN0b3IoZmllbGRzOiB7XG4gICAgdXNlcm5hbWU6IHN0cmluZ1xuICAgIGJpbzogc3RyaW5nXG4gICAgcHJvZmlsZV9pbWFnZTogc3RyaW5nXG4gICAgY292ZXJfaW1hZ2U6IHN0cmluZ1xuICB9KSB7XG4gICAgdGhpcy51c2VybmFtZSA9IGZpZWxkcy51c2VybmFtZVxuICAgIHRoaXMuYmlvID0gZmllbGRzLmJpb1xuICAgIHRoaXMucHJvZmlsZV9pbWFnZSA9IGZpZWxkcy5wcm9maWxlX2ltYWdlXG4gICAgdGhpcy5jb3Zlcl9pbWFnZSA9IGZpZWxkcy5jb3Zlcl9pbWFnZVxuICB9XG59XG5cbi8vIENyZWF0ZSBQb3N0IGluc3RydWN0aW9uIGRhdGEgY2xhc3NcbmNsYXNzIENyZWF0ZVBvc3RJbnN0cnVjdGlvbiB7XG4gIGNvbnRlbnQ6IHN0cmluZ1xuICBpbWFnZXM6IHN0cmluZ1tdXG5cbiAgY29uc3RydWN0b3IoZmllbGRzOiB7XG4gICAgY29udGVudDogc3RyaW5nXG4gICAgaW1hZ2VzOiBzdHJpbmdbXVxuICB9KSB7XG4gICAgdGhpcy5jb250ZW50ID0gZmllbGRzLmNvbnRlbnRcbiAgICB0aGlzLmltYWdlcyA9IGZpZWxkcy5pbWFnZXNcbiAgfVxufVxuXG4vLyBMaWtlIFBvc3QgaW5zdHJ1Y3Rpb24gZGF0YSBjbGFzc1xuY2xhc3MgTGlrZVBvc3RJbnN0cnVjdGlvbiB7XG4gIHBvc3RfaWQ6IGJpZ2ludFxuXG4gIGNvbnN0cnVjdG9yKGZpZWxkczoge1xuICAgIHBvc3RfaWQ6IGJpZ2ludFxuICB9KSB7XG4gICAgdGhpcy5wb3N0X2lkID0gZmllbGRzLnBvc3RfaWRcbiAgfVxufVxuXG4vLyBDb21tZW50IE9uIFBvc3QgaW5zdHJ1Y3Rpb24gZGF0YSBjbGFzc1xuY2xhc3MgQ29tbWVudE9uUG9zdEluc3RydWN0aW9uIHtcbiAgY29udGVudDogc3RyaW5nXG4gIHBhcmVudF9pZDogYmlnaW50XG5cbiAgY29uc3RydWN0b3IoZmllbGRzOiB7XG4gICAgY29udGVudDogc3RyaW5nXG4gICAgcGFyZW50X2lkOiBiaWdpbnRcbiAgfSkge1xuICAgIHRoaXMuY29udGVudCA9IGZpZWxkcy5jb250ZW50XG4gICAgdGhpcy5wYXJlbnRfaWQgPSBmaWVsZHMucGFyZW50X2lkXG4gIH1cbn1cblxuLy8gQm9va21hcmsgUG9zdCBpbnN0cnVjdGlvbiBkYXRhIGNsYXNzXG5jbGFzcyBCb29rbWFya1Bvc3RJbnN0cnVjdGlvbiB7XG4gIHBvc3RfaWQ6IGJpZ2ludFxuXG4gIGNvbnN0cnVjdG9yKGZpZWxkczoge1xuICAgIHBvc3RfaWQ6IGJpZ2ludFxuICB9KSB7XG4gICAgdGhpcy5wb3N0X2lkID0gZmllbGRzLnBvc3RfaWRcbiAgfVxufVxuXG4vLyBQcm9maWxlIHN0cnVjdCBmb3IgZGVzZXJpYWxpemF0aW9uIC0gbWF0Y2hpbmcgUnVzdCBleGFjdGx5XG5jbGFzcyBQcm9maWxlQWNjb3VudCB7XG4gIGlzX2luaXRpYWxpemVkOiBudW1iZXIgIC8vIHU4IGZyb20gUnVzdCBib29sXG4gIG93bmVyOiBVaW50OEFycmF5XG4gIHVzZXJuYW1lOiBzdHJpbmdcbiAgYmlvOiBzdHJpbmdcbiAgcHJvZmlsZV9pbWFnZTogc3RyaW5nXG4gIGNvdmVyX2ltYWdlOiBzdHJpbmdcbiAgY3JlYXRlZF9hdDogYmlnaW50XG4gIGZvbGxvd2Vyc19jb3VudDogYmlnaW50XG4gIGZvbGxvd2luZ19jb3VudDogYmlnaW50XG4gIHVzZXJfY3JlZGl0X3JhdGluZzogYmlnaW50XG4gIHBvc3RzX2NvdW50OiBiaWdpbnRcbiAgbGFzdF9wb3N0X3RpbWVzdGFtcDogYmlnaW50XG4gIGRhaWx5X3Bvc3RfY291bnQ6IGJpZ2ludFxuICBpc192ZXJpZmllZDogbnVtYmVyICAvLyB1OCBmcm9tIFJ1c3QgYm9vbFxuXG4gIGNvbnN0cnVjdG9yKGZpZWxkczogYW55KSB7XG4gICAgdGhpcy5pc19pbml0aWFsaXplZCA9IGZpZWxkcy5pc19pbml0aWFsaXplZFxuICAgIHRoaXMub3duZXIgPSBmaWVsZHMub3duZXJcbiAgICB0aGlzLnVzZXJuYW1lID0gZmllbGRzLnVzZXJuYW1lXG4gICAgdGhpcy5iaW8gPSBmaWVsZHMuYmlvXG4gICAgdGhpcy5wcm9maWxlX2ltYWdlID0gZmllbGRzLnByb2ZpbGVfaW1hZ2VcbiAgICB0aGlzLmNvdmVyX2ltYWdlID0gZmllbGRzLmNvdmVyX2ltYWdlXG4gICAgdGhpcy5jcmVhdGVkX2F0ID0gZmllbGRzLmNyZWF0ZWRfYXRcbiAgICB0aGlzLmZvbGxvd2Vyc19jb3VudCA9IGZpZWxkcy5mb2xsb3dlcnNfY291bnRcbiAgICB0aGlzLmZvbGxvd2luZ19jb3VudCA9IGZpZWxkcy5mb2xsb3dpbmdfY291bnRcbiAgICB0aGlzLnVzZXJfY3JlZGl0X3JhdGluZyA9IGZpZWxkcy51c2VyX2NyZWRpdF9yYXRpbmdcbiAgICB0aGlzLnBvc3RzX2NvdW50ID0gZmllbGRzLnBvc3RzX2NvdW50XG4gICAgdGhpcy5sYXN0X3Bvc3RfdGltZXN0YW1wID0gZmllbGRzLmxhc3RfcG9zdF90aW1lc3RhbXBcbiAgICB0aGlzLmRhaWx5X3Bvc3RfY291bnQgPSBmaWVsZHMuZGFpbHlfcG9zdF9jb3VudFxuICAgIHRoaXMuaXNfdmVyaWZpZWQgPSBmaWVsZHMuaXNfdmVyaWZpZWRcbiAgfVxufVxuXG4vLyBQb3N0IHN0cnVjdCBmb3IgZGVzZXJpYWxpemF0aW9uIC0gbWF0Y2hpbmcgUnVzdCBleGFjdGx5XG5jbGFzcyBQb3N0QWNjb3VudCB7XG4gIGlzX2luaXRpYWxpemVkOiBudW1iZXIgIC8vIHU4IGZyb20gUnVzdCBib29sXG4gIGlkOiBiaWdpbnRcbiAgYXV0aG9yOiBVaW50OEFycmF5XG4gIGNvbnRlbnQ6IHN0cmluZ1xuICB0aW1lc3RhbXA6IGJpZ2ludFxuICBsaWtlczogYmlnaW50XG4gIGNvbW1lbnRzOiBiaWdpbnRcbiAgbWlycm9yczogYmlnaW50XG4gIGltYWdlczogc3RyaW5nW11cbiAgcmF0aW5nOiBudW1iZXJcbiAgaW5fa2lsbF96b25lOiBudW1iZXIgIC8vIHU4IGZyb20gUnVzdCBib29sXG5cbiAgY29uc3RydWN0b3IoZmllbGRzOiBhbnkpIHtcbiAgICB0aGlzLmlzX2luaXRpYWxpemVkID0gZmllbGRzLmlzX2luaXRpYWxpemVkXG4gICAgdGhpcy5pZCA9IGZpZWxkcy5pZFxuICAgIHRoaXMuYXV0aG9yID0gZmllbGRzLmF1dGhvclxuICAgIHRoaXMuY29udGVudCA9IGZpZWxkcy5jb250ZW50XG4gICAgdGhpcy50aW1lc3RhbXAgPSBmaWVsZHMudGltZXN0YW1wXG4gICAgdGhpcy5saWtlcyA9IGZpZWxkcy5saWtlc1xuICAgIHRoaXMuY29tbWVudHMgPSBmaWVsZHMuY29tbWVudHNcbiAgICB0aGlzLm1pcnJvcnMgPSBmaWVsZHMubWlycm9yc1xuICAgIHRoaXMuaW1hZ2VzID0gZmllbGRzLmltYWdlc1xuICAgIHRoaXMucmF0aW5nID0gZmllbGRzLnJhdGluZ1xuICAgIHRoaXMuaW5fa2lsbF96b25lID0gZmllbGRzLmluX2tpbGxfem9uZVxuICB9XG59XG5cbi8vIEJvcnNoIHNjaGVtYXNcbmNvbnN0IGNyZWF0ZVByb2ZpbGVTY2hlbWEgPSBuZXcgTWFwKFtcbiAgW0NyZWF0ZVByb2ZpbGVJbnN0cnVjdGlvbiwge1xuICAgIGtpbmQ6ICdzdHJ1Y3QnLFxuICAgIGZpZWxkczogW1xuICAgICAgWyd1c2VybmFtZScsICdzdHJpbmcnXSxcbiAgICAgIFsnYmlvJywgJ3N0cmluZyddLFxuICAgICAgWydwcm9maWxlX2ltYWdlJywgJ3N0cmluZyddLFxuICAgICAgWydjb3Zlcl9pbWFnZScsICdzdHJpbmcnXSxcbiAgICBdLFxuICB9XSxcbl0pXG5cbmNvbnN0IGNyZWF0ZVBvc3RTY2hlbWEgPSBuZXcgTWFwKFtcbiAgW0NyZWF0ZVBvc3RJbnN0cnVjdGlvbiwge1xuICAgIGtpbmQ6ICdzdHJ1Y3QnLFxuICAgIGZpZWxkczogW1xuICAgICAgWydjb250ZW50JywgJ3N0cmluZyddLFxuICAgICAgWydpbWFnZXMnLCBbJ3N0cmluZyddXSxcbiAgICBdLFxuICB9XSxcbl0pXG5cbmNvbnN0IGxpa2VQb3N0U2NoZW1hID0gbmV3IE1hcChbXG4gIFtMaWtlUG9zdEluc3RydWN0aW9uLCB7XG4gICAga2luZDogJ3N0cnVjdCcsXG4gICAgZmllbGRzOiBbXG4gICAgICBbJ3Bvc3RfaWQnLCAndTY0J10sXG4gICAgXSxcbiAgfV0sXG5dKVxuXG5jb25zdCBjb21tZW50T25Qb3N0U2NoZW1hID0gbmV3IE1hcChbXG4gIFtDb21tZW50T25Qb3N0SW5zdHJ1Y3Rpb24sIHtcbiAgICBraW5kOiAnc3RydWN0JyxcbiAgICBmaWVsZHM6IFtcbiAgICAgIFsnY29udGVudCcsICdzdHJpbmcnXSxcbiAgICAgIFsncGFyZW50X2lkJywgJ3U2NCddLFxuICAgIF0sXG4gIH1dLFxuXSlcblxuY29uc3QgYm9va21hcmtQb3N0U2NoZW1hID0gbmV3IE1hcChbXG4gIFtCb29rbWFya1Bvc3RJbnN0cnVjdGlvbiwge1xuICAgIGtpbmQ6ICdzdHJ1Y3QnLFxuICAgIGZpZWxkczogW1xuICAgICAgWydwb3N0X2lkJywgJ3U2NCddLFxuICAgIF0sXG4gIH1dLFxuXSlcblxuY29uc3QgcHJvZmlsZUFjY291bnRTY2hlbWEgPSBuZXcgTWFwKFtcbiAgW1Byb2ZpbGVBY2NvdW50LCB7XG4gICAga2luZDogJ3N0cnVjdCcsXG4gICAgZmllbGRzOiBbXG4gICAgICBbJ2lzX2luaXRpYWxpemVkJywgJ3U4J10sICAvLyBSdXN0IGJvb2wgaXMgc2VyaWFsaXplZCBhcyB1OFxuICAgICAgWydvd25lcicsIFszMl1dLFxuICAgICAgWyd1c2VybmFtZScsICdzdHJpbmcnXSxcbiAgICAgIFsnYmlvJywgJ3N0cmluZyddLFxuICAgICAgWydwcm9maWxlX2ltYWdlJywgJ3N0cmluZyddLFxuICAgICAgWydjb3Zlcl9pbWFnZScsICdzdHJpbmcnXSxcbiAgICAgIFsnY3JlYXRlZF9hdCcsICd1NjQnXSxcbiAgICAgIFsnZm9sbG93ZXJzX2NvdW50JywgJ3U2NCddLFxuICAgICAgWydmb2xsb3dpbmdfY291bnQnLCAndTY0J10sXG4gICAgICBbJ3VzZXJfY3JlZGl0X3JhdGluZycsICdpNjQnXSxcbiAgICAgIFsncG9zdHNfY291bnQnLCAndTY0J10sXG4gICAgICBbJ2xhc3RfcG9zdF90aW1lc3RhbXAnLCAndTY0J10sXG4gICAgICBbJ2RhaWx5X3Bvc3RfY291bnQnLCAndTY0J10sXG4gICAgICBbJ2lzX3ZlcmlmaWVkJywgJ3U4J10sICAvLyBSdXN0IGJvb2wgaXMgc2VyaWFsaXplZCBhcyB1OFxuICAgIF0sXG4gIH1dLFxuXSlcblxuY29uc3QgcG9zdEFjY291bnRTY2hlbWEgPSBuZXcgTWFwKFtcbiAgW1Bvc3RBY2NvdW50LCB7XG4gICAga2luZDogJ3N0cnVjdCcsXG4gICAgZmllbGRzOiBbXG4gICAgICBbJ2lzX2luaXRpYWxpemVkJywgJ3U4J10sICAvLyBSdXN0IGJvb2wgaXMgc2VyaWFsaXplZCBhcyB1OFxuICAgICAgWydpZCcsICd1NjQnXSxcbiAgICAgIFsnYXV0aG9yJywgWzMyXV0sXG4gICAgICBbJ2NvbnRlbnQnLCAnc3RyaW5nJ10sXG4gICAgICBbJ3RpbWVzdGFtcCcsICd1NjQnXSxcbiAgICAgIFsnbGlrZXMnLCAndTY0J10sXG4gICAgICBbJ2NvbW1lbnRzJywgJ3U2NCddLFxuICAgICAgWydtaXJyb3JzJywgJ3U2NCddLFxuICAgICAgWydpbWFnZXMnLCBbJ3N0cmluZyddXSxcbiAgICAgIFsncmF0aW5nJywgJ3U4J10sXG4gICAgICBbJ2luX2tpbGxfem9uZScsICd1OCddLCAgLy8gUnVzdCBib29sIGlzIHNlcmlhbGl6ZWQgYXMgdThcbiAgICBdLFxuICB9XSxcbl0pXG5cbi8vIENvbW11bml0eS9TdWJCbG9jayBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgQ29tbXVuaXR5IHtcbiAgaXNJbml0aWFsaXplZDogYm9vbGVhblxuICBpZDogbnVtYmVyXG4gIGNyZWF0b3I6IFB1YmxpY0tleVxuICBuYW1lOiBzdHJpbmdcbiAgZGVzY3JpcHRpb246IHN0cmluZ1xuICBhdmF0YXI6IHN0cmluZ1xuICBydWxlczogc3RyaW5nW11cbiAgbWVtYmVyQ291bnQ6IG51bWJlclxuICBjcmVhdGVkQXQ6IG51bWJlclxuICBpc1ByaXZhdGU6IGJvb2xlYW5cbn1cblxuLy8gQ29tbXVuaXR5IHN0cnVjdCBmb3IgZGVzZXJpYWxpemF0aW9uXG5jbGFzcyBDb21tdW5pdHlBY2NvdW50IHtcbiAgaXNfaW5pdGlhbGl6ZWQ6IG51bWJlclxuICBpZDogYmlnaW50XG4gIGNyZWF0b3I6IFVpbnQ4QXJyYXlcbiAgbmFtZTogc3RyaW5nXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmdcbiAgYXZhdGFyOiBzdHJpbmdcbiAgcnVsZXM6IHN0cmluZ1tdXG4gIG1lbWJlcl9jb3VudDogYmlnaW50XG4gIGNyZWF0ZWRfYXQ6IGJpZ2ludFxuICBpc19wcml2YXRlOiBudW1iZXJcblxuICBjb25zdHJ1Y3RvcihmaWVsZHM6IGFueSkge1xuICAgIHRoaXMuaXNfaW5pdGlhbGl6ZWQgPSBmaWVsZHMuaXNfaW5pdGlhbGl6ZWRcbiAgICB0aGlzLmlkID0gZmllbGRzLmlkXG4gICAgdGhpcy5jcmVhdG9yID0gZmllbGRzLmNyZWF0b3JcbiAgICB0aGlzLm5hbWUgPSBmaWVsZHMubmFtZVxuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBmaWVsZHMuZGVzY3JpcHRpb25cbiAgICB0aGlzLmF2YXRhciA9IGZpZWxkcy5hdmF0YXJcbiAgICB0aGlzLnJ1bGVzID0gZmllbGRzLnJ1bGVzXG4gICAgdGhpcy5tZW1iZXJfY291bnQgPSBmaWVsZHMubWVtYmVyX2NvdW50XG4gICAgdGhpcy5jcmVhdGVkX2F0ID0gZmllbGRzLmNyZWF0ZWRfYXRcbiAgICB0aGlzLmlzX3ByaXZhdGUgPSBmaWVsZHMuaXNfcHJpdmF0ZVxuICB9XG59XG5cbi8vIENyZWF0ZSBDb21tdW5pdHkgaW5zdHJ1Y3Rpb25cbmNsYXNzIENyZWF0ZUNvbW11bml0eUluc3RydWN0aW9uIHtcbiAgbmFtZTogc3RyaW5nXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmdcbiAgYXZhdGFyOiBzdHJpbmdcbiAgcnVsZXM6IHN0cmluZ1tdXG5cbiAgY29uc3RydWN0b3IoZmllbGRzOiB7XG4gICAgbmFtZTogc3RyaW5nXG4gICAgZGVzY3JpcHRpb246IHN0cmluZ1xuICAgIGF2YXRhcjogc3RyaW5nXG4gICAgcnVsZXM6IHN0cmluZ1tdXG4gIH0pIHtcbiAgICB0aGlzLm5hbWUgPSBmaWVsZHMubmFtZVxuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBmaWVsZHMuZGVzY3JpcHRpb25cbiAgICB0aGlzLmF2YXRhciA9IGZpZWxkcy5hdmF0YXJcbiAgICB0aGlzLnJ1bGVzID0gZmllbGRzLnJ1bGVzXG4gIH1cbn1cblxuLy8gRm9sbG93IFByb2ZpbGUgaW5zdHJ1Y3Rpb25cbmNsYXNzIEZvbGxvd1Byb2ZpbGVJbnN0cnVjdGlvbiB7XG4gIHByb2ZpbGVfaWQ6IFVpbnQ4QXJyYXlcblxuICBjb25zdHJ1Y3RvcihmaWVsZHM6IHtcbiAgICBwcm9maWxlX2lkOiBQdWJsaWNLZXlcbiAgfSkge1xuICAgIC8vIEVuc3VyZSB3ZSBoYXZlIGEgcHJvcGVyIFB1YmxpY0tleSBpbnN0YW5jZVxuICAgIGxldCBwdWJsaWNLZXk6IFB1YmxpY0tleVxuICAgIGlmIChmaWVsZHMucHJvZmlsZV9pZCBpbnN0YW5jZW9mIFB1YmxpY0tleSkge1xuICAgICAgcHVibGljS2V5ID0gZmllbGRzLnByb2ZpbGVfaWRcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBmaWVsZHMucHJvZmlsZV9pZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHB1YmxpY0tleSA9IG5ldyBQdWJsaWNLZXkoZmllbGRzLnByb2ZpbGVfaWQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwcm9maWxlX2lkIHR5cGU6ICR7dHlwZW9mIGZpZWxkcy5wcm9maWxlX2lkfWApXG4gICAgfVxuICAgIFxuICAgIHRoaXMucHJvZmlsZV9pZCA9IHB1YmxpY0tleS50b0J1ZmZlcigpXG4gIH1cbn1cblxuY29uc3QgY3JlYXRlQ29tbXVuaXR5U2NoZW1hID0gbmV3IE1hcChbXG4gIFtDcmVhdGVDb21tdW5pdHlJbnN0cnVjdGlvbiwge1xuICAgIGtpbmQ6ICdzdHJ1Y3QnLFxuICAgIGZpZWxkczogW1xuICAgICAgWyduYW1lJywgJ3N0cmluZyddLFxuICAgICAgWydkZXNjcmlwdGlvbicsICdzdHJpbmcnXSxcbiAgICAgIFsnYXZhdGFyJywgJ3N0cmluZyddLFxuICAgICAgWydydWxlcycsIFsnc3RyaW5nJ11dLFxuICAgIF0sXG4gIH1dLFxuXSlcblxuY29uc3QgZm9sbG93UHJvZmlsZVNjaGVtYSA9IG5ldyBNYXAoW1xuICBbRm9sbG93UHJvZmlsZUluc3RydWN0aW9uLCB7XG4gICAga2luZDogJ3N0cnVjdCcsXG4gICAgZmllbGRzOiBbXG4gICAgICBbJ3Byb2ZpbGVfaWQnLCBbMzJdXSxcbiAgICBdLFxuICB9XSxcbl0pXG5cbmNvbnN0IGNvbW11bml0eUFjY291bnRTY2hlbWEgPSBuZXcgTWFwKFtcbiAgW0NvbW11bml0eUFjY291bnQsIHtcbiAgICBraW5kOiAnc3RydWN0JyxcbiAgICBmaWVsZHM6IFtcbiAgICAgIFsnaXNfaW5pdGlhbGl6ZWQnLCAndTgnXSxcbiAgICAgIFsnaWQnLCAndTY0J10sXG4gICAgICBbJ2NyZWF0b3InLCBbMzJdXSxcbiAgICAgIFsnbmFtZScsICdzdHJpbmcnXSxcbiAgICAgIFsnZGVzY3JpcHRpb24nLCAnc3RyaW5nJ10sXG4gICAgICBbJ2F2YXRhcicsICdzdHJpbmcnXSxcbiAgICAgIFsncnVsZXMnLCBbJ3N0cmluZyddXSxcbiAgICAgIFsnbWVtYmVyX2NvdW50JywgJ3U2NCddLFxuICAgICAgWydjcmVhdGVkX2F0JywgJ3U2NCddLFxuICAgICAgWydpc19wcml2YXRlJywgJ3U4J10sXG4gICAgXSxcbiAgfV0sXG5dKVxuXG4vLyBQcm9maWxlIGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBQcm9maWxlIHtcbiAgaXNJbml0aWFsaXplZDogYm9vbGVhblxuICBvd25lcjogUHVibGljS2V5XG4gIHVzZXJuYW1lOiBzdHJpbmdcbiAgYmlvOiBzdHJpbmdcbiAgcHJvZmlsZUltYWdlOiBzdHJpbmdcbiAgY292ZXJJbWFnZTogc3RyaW5nXG4gIGNyZWF0ZWRBdDogbnVtYmVyXG4gIGZvbGxvd2Vyc0NvdW50OiBudW1iZXJcbiAgZm9sbG93aW5nQ291bnQ6IG51bWJlclxuICB1c2VyQ3JlZGl0UmF0aW5nOiBudW1iZXJcbiAgcG9zdHNDb3VudDogbnVtYmVyXG4gIGxhc3RQb3N0VGltZXN0YW1wOiBudW1iZXJcbiAgZGFpbHlQb3N0Q291bnQ6IG51bWJlclxuICBpc1ZlcmlmaWVkOiBib29sZWFuXG59XG5cbi8vIENvbW1lbnQgaW50ZXJmYWNlIC0gc2VwYXJhdGUgZnJvbSBQb3N0XG5leHBvcnQgaW50ZXJmYWNlIENvbW1lbnQge1xuICBpZDogbnVtYmVyXG4gIHBhcmVudFBvc3RJZDogbnVtYmVyXG4gIGF1dGhvcjogUHVibGljS2V5XG4gIGNvbnRlbnQ6IHN0cmluZ1xuICB0aW1lc3RhbXA6IG51bWJlclxuICBsaWtlczogbnVtYmVyXG4gIGF1dGhvclByb2ZpbGU/OiBQcm9maWxlIHwgbnVsbFxufVxuXG4vLyBQb3N0IGludGVyZmFjZSAtIGNsZWFuIHdpdGhvdXQgY29tbWVudCBjb25mdXNpb25cbmV4cG9ydCBpbnRlcmZhY2UgUG9zdCB7XG4gIGlzSW5pdGlhbGl6ZWQ6IGJvb2xlYW5cbiAgaWQ6IG51bWJlclxuICBhdXRob3I6IFB1YmxpY0tleVxuICBjb250ZW50OiBzdHJpbmdcbiAgdGltZXN0YW1wOiBudW1iZXJcbiAgbGlrZXM6IG51bWJlclxuICBjb21tZW50czogbnVtYmVyXG4gIG1pcnJvcnM6IG51bWJlclxuICBpbWFnZXM6IHN0cmluZ1tdXG4gIHJhdGluZzogUG9zdFJhdGluZ1xuICBpbktpbGxab25lOiBib29sZWFuXG59XG5cbi8vIENhY2hlIGZvciBwcm9maWxlIGxvb2t1cHMgdG8gYXZvaWQgcmVwZWF0ZWQgYmxvY2tjaGFpbiBjYWxsc1xuY29uc3QgcHJvZmlsZUNhY2hlID0gbmV3IE1hcDxzdHJpbmcsIFByb2ZpbGUgfCBudWxsPigpXG5jb25zdCBDQUNIRV9EVVJBVElPTiA9IDYwMDAwIC8vIDEgbWludXRlIGZvciBtZW1vcnkgY2FjaGUgKGluY3JlYXNlZCBmcm9tIDMwIHNlY29uZHMpXG5cbi8vIFBvc3RzIGNhY2hlXG5sZXQgcG9zdHNDYWNoZTogeyBwb3N0czogUG9zdFtdLCB0aW1lc3RhbXA6IG51bWJlciB9IHwgbnVsbCA9IG51bGxcbmNvbnN0IFBPU1RTX0NBQ0hFX0RVUkFUSU9OID0gMzAwMDAgLy8gMzAgc2Vjb25kcyBmb3IgcG9zdHMgY2FjaGUgKGluY3JlYXNlZCBmcm9tIDEwIHNlY29uZHMpXG5cbi8vIGxvY2FsU3RvcmFnZSBjYWNoZSBjb25maWd1cmF0aW9uIC0gVXBkYXRlZCB0byBzdXBwb3J0IG11bHRpcGxlIHByb2ZpbGVzXG5jb25zdCBMT0NBTFNUT1JBR0VfQ0FDSEVfUFJFRklYID0gJ2Jsb2Nrc19wcm9maWxlXydcbmNvbnN0IExPQ0FMU1RPUkFHRV9DQUNIRV9EVVJBVElPTiA9IDEwICogNjAgKiAxMDAwIC8vIDEwIG1pbnV0ZXMgZm9yIGxvY2FsU3RvcmFnZSBjYWNoZSAoaW5jcmVhc2VkIGZyb20gNSBtaW51dGVzKVxuXG5pbnRlcmZhY2UgQ2FjaGVkUHJvZmlsZSB7XG4gIHByb2ZpbGU6IFByb2ZpbGUgfCBudWxsXG4gIHRpbWVzdGFtcDogbnVtYmVyXG4gIHdhbGxldEFkZHJlc3M6IHN0cmluZ1xufVxuXG4vLyBsb2NhbFN0b3JhZ2UgY2FjaGUgdXRpbGl0aWVzIC0gVXBkYXRlZCB0byBzdXBwb3J0IG11bHRpcGxlIHByb2ZpbGVzXG5jb25zdCBzYXZlUHJvZmlsZVRvTG9jYWxTdG9yYWdlID0gKHdhbGxldEFkZHJlc3M6IHN0cmluZywgcHJvZmlsZTogUHJvZmlsZSB8IG51bGwpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBjYWNoZUtleSA9IGAke0xPQ0FMU1RPUkFHRV9DQUNIRV9QUkVGSVh9JHt3YWxsZXRBZGRyZXNzfWBcbiAgICBjb25zdCBjYWNoZURhdGE6IENhY2hlZFByb2ZpbGUgPSB7XG4gICAgICBwcm9maWxlLFxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgd2FsbGV0QWRkcmVzc1xuICAgIH1cbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShjYWNoZUtleSwgSlNPTi5zdHJpbmdpZnkoY2FjaGVEYXRhKSlcbiAgICBjb25zb2xlLmxvZyhg8J+SviBQcm9maWxlIGNhY2hlZCB0byBsb2NhbFN0b3JhZ2UgZm9yICR7d2FsbGV0QWRkcmVzcy5zbGljZSgwLCA4KX1gKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHNhdmUgcHJvZmlsZSB0byBsb2NhbFN0b3JhZ2U6JywgZXJyb3IpXG4gIH1cbn1cblxuY29uc3QgZ2V0UHJvZmlsZUZyb21Mb2NhbFN0b3JhZ2UgPSAod2FsbGV0QWRkcmVzczogc3RyaW5nKTogUHJvZmlsZSB8IG51bGwgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gYCR7TE9DQUxTVE9SQUdFX0NBQ0hFX1BSRUZJWH0ke3dhbGxldEFkZHJlc3N9YFxuICAgIGNvbnN0IGNhY2hlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGNhY2hlS2V5KVxuICAgIGlmICghY2FjaGVkKSByZXR1cm4gbnVsbFxuXG4gICAgY29uc3QgY2FjaGVEYXRhOiBDYWNoZWRQcm9maWxlID0gSlNPTi5wYXJzZShjYWNoZWQpXG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgY2FjaGUgaXMgZXhwaXJlZFxuICAgIGlmIChEYXRlLm5vdygpIC0gY2FjaGVEYXRhLnRpbWVzdGFtcCA+IExPQ0FMU1RPUkFHRV9DQUNIRV9EVVJBVElPTikge1xuICAgICAgY29uc29sZS5sb2coYOKPsCBDYWNoZSBleHBpcmVkIGZvciAke3dhbGxldEFkZHJlc3Muc2xpY2UoMCwgOCl9LCBjbGVhcmluZ2ApXG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShjYWNoZUtleSlcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKGDimqEgVXNpbmcgY2FjaGVkIHByb2ZpbGUgZnJvbSBsb2NhbFN0b3JhZ2UgZm9yICR7d2FsbGV0QWRkcmVzcy5zbGljZSgwLCA4KX1gKVxuICAgIHJldHVybiBjYWNoZURhdGEucHJvZmlsZVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHJlYWQgcHJvZmlsZSBmcm9tIGxvY2FsU3RvcmFnZTonLCBlcnJvcilcbiAgICBjb25zdCBjYWNoZUtleSA9IGAke0xPQ0FMU1RPUkFHRV9DQUNIRV9QUkVGSVh9JHt3YWxsZXRBZGRyZXNzfWBcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShjYWNoZUtleSlcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbmNvbnN0IGNsZWFyUHJvZmlsZUNhY2hlID0gKHdhbGxldEFkZHJlc3M/OiBzdHJpbmcpID0+IHtcbiAgLy8gQ2xlYXIgbWVtb3J5IGNhY2hlXG4gIGlmICh3YWxsZXRBZGRyZXNzKSB7XG4gICAgcHJvZmlsZUNhY2hlLmRlbGV0ZSh3YWxsZXRBZGRyZXNzKVxuICAgIC8vIENsZWFyIGxvY2FsU3RvcmFnZSBjYWNoZSBmb3Igc3BlY2lmaWMgdXNlclxuICAgIGNvbnN0IGNhY2hlS2V5ID0gYCR7TE9DQUxTVE9SQUdFX0NBQ0hFX1BSRUZJWH0ke3dhbGxldEFkZHJlc3N9YFxuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGNhY2hlS2V5KVxuICB9IGVsc2Uge1xuICAgIHByb2ZpbGVDYWNoZS5jbGVhcigpXG4gICAgLy8gQ2xlYXIgYWxsIGxvY2FsU3RvcmFnZSBwcm9maWxlIGNhY2hlc1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhsb2NhbFN0b3JhZ2UpXG4gICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoTE9DQUxTVE9SQUdFX0NBQ0hFX1BSRUZJWCkpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KVxuICAgICAgfVxuICAgIH0pXG4gIH1cbiAgXG4gIC8vIENsZWFyIHBvc3RzIGNhY2hlXG4gIHBvc3RzQ2FjaGUgPSBudWxsXG4gIFxuICBjb25zb2xlLmxvZygn8J+Xke+4jyBQcm9maWxlIGFuZCBwb3N0cyBjYWNoZSBjbGVhcmVkJylcbn1cblxuLy8gU2ltcGxlIGluLW1lbW9yeSBjb21tZW50IHN0b3JhZ2UgKHJlc2V0cyBvbiBwYWdlIHJlZnJlc2gpXG5sZXQgY29tbWVudHNTdG9yYWdlOiB7IFtwb3N0SWQ6IG51bWJlcl06IENvbW1lbnRbXSB9ID0ge31cblxuLy8gQ29tbWVudCBhY2NvdW50IHRyYWNraW5nIC0gc3RvcmUgY29tbWVudCBhY2NvdW50IGFkZHJlc3NlcyB0byBkaXN0aW5ndWlzaCBmcm9tIHBvc3RzXG5jb25zdCBnZXRDb21tZW50QWNjb3VudHNLZXkgPSAoKSA9PiAnY29tbWVudF9hY2NvdW50cydcbmNvbnN0IGdldENvbW1lbnRNYXBwaW5nS2V5ID0gKCkgPT4gJ2NvbW1lbnRfdG9fcG9zdF9tYXBwaW5nJ1xuXG4vLyBTdG9yZSBjb21tZW50IGFjY291bnQgYWRkcmVzcyBhbmQgaXRzIHBhcmVudCBwb3N0IElEXG5jb25zdCB0cmFja0NvbW1lbnRBY2NvdW50ID0gKGNvbW1lbnRBY2NvdW50QWRkcmVzczogc3RyaW5nLCBwYXJlbnRQb3N0SWQ6IG51bWJlcikgPT4ge1xuICB0cnkge1xuICAgIC8vIFRyYWNrIGNvbW1lbnQgYWNjb3VudHNcbiAgICBjb25zdCBjb21tZW50QWNjb3VudHNLZXkgPSBnZXRDb21tZW50QWNjb3VudHNLZXkoKVxuICAgIGNvbnN0IGV4aXN0aW5nQWNjb3VudHMgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShjb21tZW50QWNjb3VudHNLZXkpXG4gICAgY29uc3QgY29tbWVudEFjY291bnRzOiBzdHJpbmdbXSA9IGV4aXN0aW5nQWNjb3VudHMgPyBKU09OLnBhcnNlKGV4aXN0aW5nQWNjb3VudHMpIDogW11cbiAgICBcbiAgICBpZiAoIWNvbW1lbnRBY2NvdW50cy5pbmNsdWRlcyhjb21tZW50QWNjb3VudEFkZHJlc3MpKSB7XG4gICAgICBjb21tZW50QWNjb3VudHMucHVzaChjb21tZW50QWNjb3VudEFkZHJlc3MpXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShjb21tZW50QWNjb3VudHNLZXksIEpTT04uc3RyaW5naWZ5KGNvbW1lbnRBY2NvdW50cykpXG4gICAgfVxuICAgIFxuICAgIC8vIFRyYWNrIGNvbW1lbnQgdG8gcG9zdCBtYXBwaW5nXG4gICAgY29uc3QgbWFwcGluZ0tleSA9IGdldENvbW1lbnRNYXBwaW5nS2V5KClcbiAgICBjb25zdCBleGlzdGluZ01hcHBpbmcgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShtYXBwaW5nS2V5KVxuICAgIGNvbnN0IGNvbW1lbnRNYXBwaW5nOiB7IFtjb21tZW50QWNjb3VudDogc3RyaW5nXTogbnVtYmVyIH0gPSBleGlzdGluZ01hcHBpbmcgPyBKU09OLnBhcnNlKGV4aXN0aW5nTWFwcGluZykgOiB7fVxuICAgIFxuICAgIGNvbW1lbnRNYXBwaW5nW2NvbW1lbnRBY2NvdW50QWRkcmVzc10gPSBwYXJlbnRQb3N0SWRcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShtYXBwaW5nS2V5LCBKU09OLnN0cmluZ2lmeShjb21tZW50TWFwcGluZykpXG4gICAgXG4gICAgY29uc29sZS5sb2coYPCfk50gVHJhY2tlZCBjb21tZW50IGFjY291bnQgJHtjb21tZW50QWNjb3VudEFkZHJlc3Muc2xpY2UoMCwgOCl9IGZvciBwb3N0ICR7cGFyZW50UG9zdElkfWApXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHRyYWNrIGNvbW1lbnQgYWNjb3VudDonLCBlcnJvcilcbiAgfVxufVxuXG4vLyBDaGVjayBpZiBhbiBhY2NvdW50IGFkZHJlc3MgaXMgYSBjb21tZW50XG5jb25zdCBpc0NvbW1lbnRBY2NvdW50ID0gKGFjY291bnRBZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBjb21tZW50QWNjb3VudHNLZXkgPSBnZXRDb21tZW50QWNjb3VudHNLZXkoKVxuICAgIGNvbnN0IGV4aXN0aW5nQWNjb3VudHMgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShjb21tZW50QWNjb3VudHNLZXkpXG4gICAgY29uc3QgY29tbWVudEFjY291bnRzOiBzdHJpbmdbXSA9IGV4aXN0aW5nQWNjb3VudHMgPyBKU09OLnBhcnNlKGV4aXN0aW5nQWNjb3VudHMpIDogW11cbiAgICByZXR1cm4gY29tbWVudEFjY291bnRzLmluY2x1ZGVzKGFjY291bnRBZGRyZXNzKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8vIEdldCBwYXJlbnQgcG9zdCBJRCBmb3IgYSBjb21tZW50IGFjY291bnRcbmNvbnN0IGdldFBhcmVudFBvc3RJZCA9IChjb21tZW50QWNjb3VudEFkZHJlc3M6IHN0cmluZyk6IG51bWJlciB8IG51bGwgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IG1hcHBpbmdLZXkgPSBnZXRDb21tZW50TWFwcGluZ0tleSgpXG4gICAgY29uc3QgZXhpc3RpbmdNYXBwaW5nID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0obWFwcGluZ0tleSlcbiAgICBjb25zdCBjb21tZW50TWFwcGluZzogeyBbY29tbWVudEFjY291bnQ6IHN0cmluZ106IG51bWJlciB9ID0gZXhpc3RpbmdNYXBwaW5nID8gSlNPTi5wYXJzZShleGlzdGluZ01hcHBpbmcpIDoge31cbiAgICByZXR1cm4gY29tbWVudE1hcHBpbmdbY29tbWVudEFjY291bnRBZGRyZXNzXSB8fCBudWxsXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG4vLyBVc2VyIGxpa2VzIHRyYWNraW5nIC0gc3RvcmUgaW4gbG9jYWxTdG9yYWdlXG5jb25zdCBnZXRVc2VyTGlrZXNLZXkgPSAod2FsbGV0QWRkcmVzczogc3RyaW5nKSA9PiBgdXNlcl9saWtlc18ke3dhbGxldEFkZHJlc3N9YFxuXG4vLyBHZXQgdXNlcidzIGxpa2VkIHBvc3RzIGZyb20gbG9jYWxTdG9yYWdlXG5jb25zdCBnZXRVc2VyTGlrZWRQb3N0cyA9ICh3YWxsZXRBZGRyZXNzOiBzdHJpbmcpOiBudW1iZXJbXSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgbGlrZXNLZXkgPSBnZXRVc2VyTGlrZXNLZXkod2FsbGV0QWRkcmVzcylcbiAgICBjb25zdCBleGlzdGluZ0xpa2VzID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0obGlrZXNLZXkpXG4gICAgcmV0dXJuIGV4aXN0aW5nTGlrZXMgPyBKU09OLnBhcnNlKGV4aXN0aW5nTGlrZXMpIDogW11cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IHVzZXIgbGlrZXM6JywgZXJyb3IpXG4gICAgcmV0dXJuIFtdXG4gIH1cbn1cblxuLy8gQWRkIHBvc3QgdG8gdXNlcidzIGxpa2VkIHBvc3RzXG5jb25zdCBhZGRVc2VyTGlrZSA9ICh3YWxsZXRBZGRyZXNzOiBzdHJpbmcsIHBvc3RJZDogbnVtYmVyKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgbGlrZXNLZXkgPSBnZXRVc2VyTGlrZXNLZXkod2FsbGV0QWRkcmVzcylcbiAgICBjb25zdCBleGlzdGluZ0xpa2VzID0gZ2V0VXNlckxpa2VkUG9zdHMod2FsbGV0QWRkcmVzcylcbiAgICBpZiAoIWV4aXN0aW5nTGlrZXMuaW5jbHVkZXMocG9zdElkKSkge1xuICAgICAgZXhpc3RpbmdMaWtlcy5wdXNoKHBvc3RJZClcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGxpa2VzS2V5LCBKU09OLnN0cmluZ2lmeShleGlzdGluZ0xpa2VzKSlcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGFkZCB1c2VyIGxpa2U6JywgZXJyb3IpXG4gIH1cbn1cblxuLy8gUmVtb3ZlIHBvc3QgZnJvbSB1c2VyJ3MgbGlrZWQgcG9zdHNcbmNvbnN0IHJlbW92ZVVzZXJMaWtlID0gKHdhbGxldEFkZHJlc3M6IHN0cmluZywgcG9zdElkOiBudW1iZXIpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBsaWtlc0tleSA9IGdldFVzZXJMaWtlc0tleSh3YWxsZXRBZGRyZXNzKVxuICAgIGNvbnN0IGV4aXN0aW5nTGlrZXMgPSBnZXRVc2VyTGlrZWRQb3N0cyh3YWxsZXRBZGRyZXNzKVxuICAgIGNvbnN0IHVwZGF0ZWRMaWtlcyA9IGV4aXN0aW5nTGlrZXMuZmlsdGVyKGlkID0+IGlkICE9PSBwb3N0SWQpXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0obGlrZXNLZXksIEpTT04uc3RyaW5naWZ5KHVwZGF0ZWRMaWtlcykpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHJlbW92ZSB1c2VyIGxpa2U6JywgZXJyb3IpXG4gIH1cbn1cblxuLy8gQ2hlY2sgaWYgdXNlciBoYXMgbGlrZWQgYSBwb3N0XG5jb25zdCBoYXNVc2VyTGlrZWRQb3N0ID0gKHdhbGxldEFkZHJlc3M6IHN0cmluZywgcG9zdElkOiBudW1iZXIpOiBib29sZWFuID0+IHtcbiAgY29uc3QgdXNlckxpa2VzID0gZ2V0VXNlckxpa2VkUG9zdHMod2FsbGV0QWRkcmVzcylcbiAgcmV0dXJuIHVzZXJMaWtlcy5pbmNsdWRlcyhwb3N0SWQpXG59XG5cbi8vIFVzZXIgZm9sbG93cyB0cmFja2luZyAtIHN0b3JlIGluIGxvY2FsU3RvcmFnZVxuY29uc3QgZ2V0VXNlckZvbGxvd3NLZXkgPSAod2FsbGV0QWRkcmVzczogc3RyaW5nKSA9PiBgdXNlcl9mb2xsb3dzXyR7d2FsbGV0QWRkcmVzc31gXG5cbi8vIEdldCB1c2VyJ3MgZm9sbG93ZWQgcHJvZmlsZXMgZnJvbSBsb2NhbFN0b3JhZ2VcbmNvbnN0IGdldFVzZXJGb2xsb3dlZFByb2ZpbGVzID0gKHdhbGxldEFkZHJlc3M6IHN0cmluZyk6IHN0cmluZ1tdID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBmb2xsb3dzS2V5ID0gZ2V0VXNlckZvbGxvd3NLZXkod2FsbGV0QWRkcmVzcylcbiAgICBjb25zdCBleGlzdGluZ0ZvbGxvd3MgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShmb2xsb3dzS2V5KVxuICAgIHJldHVybiBleGlzdGluZ0ZvbGxvd3MgPyBKU09OLnBhcnNlKGV4aXN0aW5nRm9sbG93cykgOiBbXVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgdXNlciBmb2xsb3dzOicsIGVycm9yKVxuICAgIHJldHVybiBbXVxuICB9XG59XG5cbi8vIEFkZCBwcm9maWxlIHRvIHVzZXIncyBmb2xsb3dlZCBwcm9maWxlc1xuY29uc3QgYWRkVXNlckZvbGxvdyA9ICh3YWxsZXRBZGRyZXNzOiBzdHJpbmcsIHByb2ZpbGVPd25lcktleTogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coYPCfk50gQWRkaW5nIGZvbGxvdzogJHt3YWxsZXRBZGRyZXNzLnNsaWNlKDAsIDgpfSAtPiAke3Byb2ZpbGVPd25lcktleS5zbGljZSgwLCA4KX1gKVxuICAgIFxuICAgIGNvbnN0IGZvbGxvd3NLZXkgPSBnZXRVc2VyRm9sbG93c0tleSh3YWxsZXRBZGRyZXNzKVxuICAgIGNvbnN0IGV4aXN0aW5nRm9sbG93cyA9IGdldFVzZXJGb2xsb3dlZFByb2ZpbGVzKHdhbGxldEFkZHJlc3MpXG4gICAgXG4gICAgY29uc29sZS5sb2coYCAgRm9sbG93IGtleTogJHtmb2xsb3dzS2V5fWApXG4gICAgY29uc29sZS5sb2coYCAgRXhpc3RpbmcgZm9sbG93czogJHtKU09OLnN0cmluZ2lmeShleGlzdGluZ0ZvbGxvd3MpfWApXG4gICAgY29uc29sZS5sb2coYCAgQWRkaW5nIHByb2ZpbGU6ICR7cHJvZmlsZU93bmVyS2V5fWApXG4gICAgXG4gICAgaWYgKCFleGlzdGluZ0ZvbGxvd3MuaW5jbHVkZXMocHJvZmlsZU93bmVyS2V5KSkge1xuICAgICAgZXhpc3RpbmdGb2xsb3dzLnB1c2gocHJvZmlsZU93bmVyS2V5KVxuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oZm9sbG93c0tleSwgSlNPTi5zdHJpbmdpZnkoZXhpc3RpbmdGb2xsb3dzKSlcbiAgICAgIGNvbnNvbGUubG9nKGAgIFVwZGF0ZWQgZm9sbG93czogJHtKU09OLnN0cmluZ2lmeShleGlzdGluZ0ZvbGxvd3MpfWApXG4gICAgICBjb25zb2xlLmxvZyhg8J+TnSBUcmFja2VkIGZvbGxvdzogJHt3YWxsZXRBZGRyZXNzLnNsaWNlKDAsIDgpfSAtPiAke3Byb2ZpbGVPd25lcktleS5zbGljZSgwLCA4KX1gKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhgICBBbHJlYWR5IGZvbGxvd2luZyB0aGlzIHByb2ZpbGVgKVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gYWRkIHVzZXIgZm9sbG93OicsIGVycm9yKVxuICB9XG59XG5cbi8vIFJlbW92ZSBwcm9maWxlIGZyb20gdXNlcidzIGZvbGxvd2VkIHByb2ZpbGVzXG5jb25zdCByZW1vdmVVc2VyRm9sbG93ID0gKHdhbGxldEFkZHJlc3M6IHN0cmluZywgcHJvZmlsZU93bmVyS2V5OiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhg8J+TnSBSZW1vdmluZyBmb2xsb3c6ICR7d2FsbGV0QWRkcmVzcy5zbGljZSgwLCA4KX0gLT4gJHtwcm9maWxlT3duZXJLZXkuc2xpY2UoMCwgOCl9YClcbiAgICBcbiAgICBjb25zdCBmb2xsb3dzS2V5ID0gZ2V0VXNlckZvbGxvd3NLZXkod2FsbGV0QWRkcmVzcylcbiAgICBjb25zdCBleGlzdGluZ0ZvbGxvd3MgPSBnZXRVc2VyRm9sbG93ZWRQcm9maWxlcyh3YWxsZXRBZGRyZXNzKVxuICAgIFxuICAgIGNvbnNvbGUubG9nKGAgIEZvbGxvdyBrZXk6ICR7Zm9sbG93c0tleX1gKVxuICAgIGNvbnNvbGUubG9nKGAgIEV4aXN0aW5nIGZvbGxvd3M6ICR7SlNPTi5zdHJpbmdpZnkoZXhpc3RpbmdGb2xsb3dzKX1gKVxuICAgIGNvbnNvbGUubG9nKGAgIFJlbW92aW5nIHByb2ZpbGU6ICR7cHJvZmlsZU93bmVyS2V5fWApXG4gICAgXG4gICAgY29uc3QgdXBkYXRlZEZvbGxvd3MgPSBleGlzdGluZ0ZvbGxvd3MuZmlsdGVyKGtleSA9PiBrZXkgIT09IHByb2ZpbGVPd25lcktleSlcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShmb2xsb3dzS2V5LCBKU09OLnN0cmluZ2lmeSh1cGRhdGVkRm9sbG93cykpXG4gICAgXG4gICAgY29uc29sZS5sb2coYCAgVXBkYXRlZCBmb2xsb3dzOiAke0pTT04uc3RyaW5naWZ5KHVwZGF0ZWRGb2xsb3dzKX1gKVxuICAgIGNvbnNvbGUubG9nKGDwn5OdIFJlbW92ZWQgZm9sbG93OiAke3dhbGxldEFkZHJlc3Muc2xpY2UoMCwgOCl9IC0+ICR7cHJvZmlsZU93bmVyS2V5LnNsaWNlKDAsIDgpfWApXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHJlbW92ZSB1c2VyIGZvbGxvdzonLCBlcnJvcilcbiAgfVxufVxuXG4vLyBDaGVjayBpZiB1c2VyIGlzIGZvbGxvd2luZyBhIHByb2ZpbGVcbmNvbnN0IGlzVXNlckZvbGxvd2luZ1Byb2ZpbGUgPSAod2FsbGV0QWRkcmVzczogc3RyaW5nLCBwcm9maWxlT3duZXJLZXk6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKGDwn5SNIENoZWNraW5nIGlmICR7d2FsbGV0QWRkcmVzcy5zbGljZSgwLCA4KX0gZm9sbG93cyAke3Byb2ZpbGVPd25lcktleS5zbGljZSgwLCA4KX1gKVxuICAgIFxuICAgIGNvbnN0IHVzZXJGb2xsb3dzID0gZ2V0VXNlckZvbGxvd2VkUHJvZmlsZXMod2FsbGV0QWRkcmVzcylcbiAgICBjb25zdCBpc0ZvbGxvd2luZyA9IHVzZXJGb2xsb3dzLmluY2x1ZGVzKHByb2ZpbGVPd25lcktleSlcbiAgICBcbiAgICBjb25zb2xlLmxvZyhgICBVc2VyIGZvbGxvd3M6ICR7SlNPTi5zdHJpbmdpZnkodXNlckZvbGxvd3MpfWApXG4gICAgY29uc29sZS5sb2coYCAgTG9va2luZyBmb3I6ICR7cHJvZmlsZU93bmVyS2V5fWApXG4gICAgY29uc29sZS5sb2coYCAgUmVzdWx0OiAke2lzRm9sbG93aW5nfWApXG4gICAgXG4gICAgcmV0dXJuIGlzRm9sbG93aW5nXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNoZWNrIGZvbGxvdyBzdGF0dXM6JywgZXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUJsb2Nrc1Byb2dyYW0oKSB7XG4gIGNvbnN0IHsgY29ubmVjdGlvbiB9ID0gdXNlQ29ubmVjdGlvbigpXG4gIGNvbnN0IHsgcHVibGljS2V5LCBzZW5kVHJhbnNhY3Rpb24gfSA9IHVzZVdhbGxldCgpXG5cbiAgLy8gR2V0IHByb2ZpbGUgUERBXG4gIGNvbnN0IGdldFByb2ZpbGVQREEgPSBhc3luYyAodXNlclB1YmxpY0tleTogUHVibGljS2V5LCB1c2VybmFtZTogc3RyaW5nKTogUHJvbWlzZTxQdWJsaWNLZXk+ID0+IHtcbiAgICBjb25zdCBbcHJvZmlsZVBEQV0gPSBhd2FpdCBQdWJsaWNLZXkuZmluZFByb2dyYW1BZGRyZXNzKFxuICAgICAgW3VzZXJQdWJsaWNLZXkudG9CdWZmZXIoKSwgQnVmZmVyLmZyb20oJ3Byb2ZpbGUnKSwgQnVmZmVyLmZyb20odXNlcm5hbWUpXSxcbiAgICAgIFBST0dSQU1fSURcbiAgICApXG4gICAgcmV0dXJuIHByb2ZpbGVQREFcbiAgfVxuXG4gIC8vIEdldCBwb3N0IFBEQVxuICBjb25zdCBnZXRQb3N0UERBID0gYXN5bmMgKHVzZXJQdWJsaWNLZXk6IFB1YmxpY0tleSwgcG9zdElkOiBudW1iZXIpOiBQcm9taXNlPFB1YmxpY0tleT4gPT4ge1xuICAgIGNvbnN0IFtwb3N0UERBXSA9IGF3YWl0IFB1YmxpY0tleS5maW5kUHJvZ3JhbUFkZHJlc3MoXG4gICAgICBbdXNlclB1YmxpY0tleS50b0J1ZmZlcigpLCBCdWZmZXIuZnJvbSgncG9zdCcpLCBCdWZmZXIuZnJvbShwb3N0SWQudG9TdHJpbmcoKSldLFxuICAgICAgUFJPR1JBTV9JRFxuICAgIClcbiAgICByZXR1cm4gcG9zdFBEQVxuICB9XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNoZWNrIGlmIHByb2dyYW0gZXhpc3RzXG4gIGNvbnN0IGNoZWNrUHJvZ3JhbUV4aXN0cyA9IGFzeW5jICgpOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJvZ3JhbUluZm8gPSBhd2FpdCBjb25uZWN0aW9uLmdldEFjY291bnRJbmZvKFBST0dSQU1fSUQpXG4gICAgICByZXR1cm4gcHJvZ3JhbUluZm8gIT09IG51bGwgJiYgcHJvZ3JhbUluZm8uZXhlY3V0YWJsZVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBwcm9ncmFtIGV4aXN0ZW5jZTonLCBlcnJvcilcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjaGVjayBTT0wgYmFsYW5jZVxuICBjb25zdCBjaGVja1NPTEJhbGFuY2UgPSBhc3luYyAoKTogUHJvbWlzZTxudW1iZXI+ID0+IHtcbiAgICBpZiAoIXB1YmxpY0tleSkgcmV0dXJuIDBcbiAgICB0cnkge1xuICAgICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0QmFsYW5jZShwdWJsaWNLZXkpXG4gICAgICByZXR1cm4gYmFsYW5jZSAvIExBTVBPUlRTX1BFUl9TT0xcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgU09MIGJhbGFuY2U6JywgZXJyb3IpXG4gICAgICByZXR1cm4gMFxuICAgIH1cbiAgfVxuXG4gIC8vIENvbnZlcnQgUHJvZmlsZUFjY291bnQgdG8gUHJvZmlsZSBpbnRlcmZhY2VcbiAgY29uc3QgY29udmVydFByb2ZpbGVBY2NvdW50ID0gKHByb2ZpbGVBY2NvdW50OiBQcm9maWxlQWNjb3VudCk6IFByb2ZpbGUgPT4ge1xuICAgIC8vIENhbGN1bGF0ZSBVQ1IgYmFzZWQgb24gYWN0aXZpdHlcbiAgICBjb25zdCBjYWxjdWxhdGVVQ1IgPSAocHJvZmlsZTogUHJvZmlsZUFjY291bnQpID0+IHtcbiAgICAgIGNvbnN0IHBvc3RzQ291bnQgPSBOdW1iZXIocHJvZmlsZS5wb3N0c19jb3VudClcbiAgICAgIGNvbnN0IGZvbGxvd2Vyc0NvdW50ID0gTnVtYmVyKHByb2ZpbGUuZm9sbG93ZXJzX2NvdW50KVxuICAgICAgY29uc3QgZm9sbG93aW5nQ291bnQgPSBOdW1iZXIocHJvZmlsZS5mb2xsb3dpbmdfY291bnQpXG4gICAgICBcbiAgICAgIC8vIEJhc2UgVUNSIGNhbGN1bGF0aW9uIGFsZ29yaXRobVxuICAgICAgbGV0IHVjciA9IDEuMCAvLyBTdGFydCB3aXRoIGJhc2UgcmF0aW5nXG4gICAgICBcbiAgICAgIC8vIFBvc3RzIGZhY3RvciAoMC4xIHBvaW50cyBwZXIgcG9zdCwgbWF4IDIuMCBwb2ludHMpXG4gICAgICBjb25zdCBwb3N0c1Njb3JlID0gTWF0aC5taW4ocG9zdHNDb3VudCAqIDAuMSwgMi4wKVxuICAgICAgXG4gICAgICAvLyBGb2xsb3dlcnMgZmFjdG9yICgwLjA1IHBvaW50cyBwZXIgZm9sbG93ZXIsIG1heCAxLjUgcG9pbnRzKVxuICAgICAgY29uc3QgZm9sbG93ZXJzU2NvcmUgPSBNYXRoLm1pbihmb2xsb3dlcnNDb3VudCAqIDAuMDUsIDEuNSlcbiAgICAgIFxuICAgICAgLy8gRm9sbG93aW5nL2ZvbGxvd2VycyByYXRpbyAoaGVhbHRoeSByYXRpbyA9IGJvbnVzKVxuICAgICAgbGV0IHJhdGlvQm9udXMgPSAwXG4gICAgICBpZiAoZm9sbG93ZXJzQ291bnQgPiAwICYmIGZvbGxvd2luZ0NvdW50ID4gMCkge1xuICAgICAgICBjb25zdCByYXRpbyA9IGZvbGxvd2Vyc0NvdW50IC8gZm9sbG93aW5nQ291bnRcbiAgICAgICAgaWYgKHJhdGlvID49IDAuNSAmJiByYXRpbyA8PSAyLjApIHsgLy8gSGVhbHRoeSByYXRpb1xuICAgICAgICAgIHJhdGlvQm9udXMgPSAwLjNcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBY2NvdW50IGFnZSBmYWN0b3IgKG9sZGVyIGFjY291bnRzIGdldCBib251cylcbiAgICAgIGNvbnN0IGFjY291bnRBZ2UgPSBEYXRlLm5vdygpIC0gTnVtYmVyKHByb2ZpbGUuY3JlYXRlZF9hdCkgKiAxMDAwXG4gICAgICBjb25zdCBkYXlzT2xkID0gYWNjb3VudEFnZSAvICgxMDAwICogNjAgKiA2MCAqIDI0KVxuICAgICAgY29uc3QgYWdlQm9udXMgPSBNYXRoLm1pbihkYXlzT2xkIC8gMzAgKiAwLjIsIDEuMCkgLy8gMC4yIHBvaW50cyBwZXIgbW9udGgsIG1heCAxLjBcbiAgICAgIFxuICAgICAgLy8gVmVyaWZpY2F0aW9uIGJvbnVzXG4gICAgICBjb25zdCB2ZXJpZmljYXRpb25Cb251cyA9IHByb2ZpbGUuaXNfdmVyaWZpZWQgPT09IDEgPyAwLjUgOiAwXG4gICAgICBcbiAgICAgIC8vIEFjdGl2aXR5IGZhY3RvciAocG9zdGluZyByZWd1bGFybHkpXG4gICAgICBjb25zdCBsYXN0UG9zdEFnZSA9IERhdGUubm93KCkgLSBOdW1iZXIocHJvZmlsZS5sYXN0X3Bvc3RfdGltZXN0YW1wKSAqIDEwMDBcbiAgICAgIGNvbnN0IGRheXNTaW5jZUxhc3RQb3N0ID0gbGFzdFBvc3RBZ2UgLyAoMTAwMCAqIDYwICogNjAgKiAyNClcbiAgICAgIGNvbnN0IGFjdGl2aXR5Qm9udXMgPSBkYXlzU2luY2VMYXN0UG9zdCA8IDcgPyAwLjMgOiBkYXlzU2luY2VMYXN0UG9zdCA8IDMwID8gMC4xIDogMFxuICAgICAgXG4gICAgICB1Y3IgPSB1Y3IgKyBwb3N0c1Njb3JlICsgZm9sbG93ZXJzU2NvcmUgKyByYXRpb0JvbnVzICsgYWdlQm9udXMgKyB2ZXJpZmljYXRpb25Cb251cyArIGFjdGl2aXR5Qm9udXNcbiAgICAgIFxuICAgICAgLy8gQ2FwIGF0IDUuMCBtYXhcbiAgICAgIHJldHVybiBNYXRoLm1pbih1Y3IsIDUuMClcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNJbml0aWFsaXplZDogcHJvZmlsZUFjY291bnQuaXNfaW5pdGlhbGl6ZWQgPT09IDEsXG4gICAgICBvd25lcjogbmV3IFB1YmxpY0tleShwcm9maWxlQWNjb3VudC5vd25lciksXG4gICAgICB1c2VybmFtZTogcHJvZmlsZUFjY291bnQudXNlcm5hbWUsXG4gICAgICBiaW86IHByb2ZpbGVBY2NvdW50LmJpbyxcbiAgICAgIHByb2ZpbGVJbWFnZTogcHJvZmlsZUFjY291bnQucHJvZmlsZV9pbWFnZSxcbiAgICAgIGNvdmVySW1hZ2U6IHByb2ZpbGVBY2NvdW50LmNvdmVyX2ltYWdlLFxuICAgICAgY3JlYXRlZEF0OiBOdW1iZXIocHJvZmlsZUFjY291bnQuY3JlYXRlZF9hdCkgKiAxMDAwLCAvLyBDb252ZXJ0IHNlY29uZHMgdG8gbWlsbGlzZWNvbmRzXG4gICAgICBmb2xsb3dlcnNDb3VudDogTnVtYmVyKHByb2ZpbGVBY2NvdW50LmZvbGxvd2Vyc19jb3VudCksXG4gICAgICBmb2xsb3dpbmdDb3VudDogTnVtYmVyKHByb2ZpbGVBY2NvdW50LmZvbGxvd2luZ19jb3VudCksXG4gICAgICB1c2VyQ3JlZGl0UmF0aW5nOiBjYWxjdWxhdGVVQ1IocHJvZmlsZUFjY291bnQpLCAvLyBVc2UgY2FsY3VsYXRlZCBVQ1IgaW5zdGVhZCBvZiBzdG9yZWQgdmFsdWVcbiAgICAgIHBvc3RzQ291bnQ6IE51bWJlcihwcm9maWxlQWNjb3VudC5wb3N0c19jb3VudCksXG4gICAgICBsYXN0UG9zdFRpbWVzdGFtcDogTnVtYmVyKHByb2ZpbGVBY2NvdW50Lmxhc3RfcG9zdF90aW1lc3RhbXApICogMTAwMCwgLy8gQ29udmVydCBzZWNvbmRzIHRvIG1pbGxpc2Vjb25kc1xuICAgICAgZGFpbHlQb3N0Q291bnQ6IE51bWJlcihwcm9maWxlQWNjb3VudC5kYWlseV9wb3N0X2NvdW50KSxcbiAgICAgIGlzVmVyaWZpZWQ6IHByb2ZpbGVBY2NvdW50LmlzX3ZlcmlmaWVkID09PSAxLFxuICAgIH1cbiAgfVxuXG4gIC8vIENvbnZlcnQgUG9zdEFjY291bnQgdG8gUG9zdCBpbnRlcmZhY2VcbiAgY29uc3QgY29udmVydFBvc3RBY2NvdW50ID0gKHBvc3RBY2NvdW50OiBQb3N0QWNjb3VudCk6IFBvc3QgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBpc0luaXRpYWxpemVkOiBwb3N0QWNjb3VudC5pc19pbml0aWFsaXplZCA9PT0gMSxcbiAgICAgIGlkOiBOdW1iZXIocG9zdEFjY291bnQuaWQpLFxuICAgICAgYXV0aG9yOiBuZXcgUHVibGljS2V5KHBvc3RBY2NvdW50LmF1dGhvciksXG4gICAgICBjb250ZW50OiBwb3N0QWNjb3VudC5jb250ZW50LFxuICAgICAgdGltZXN0YW1wOiBOdW1iZXIocG9zdEFjY291bnQudGltZXN0YW1wKSAqIDEwMDAsIC8vIENvbnZlcnQgc2Vjb25kcyB0byBtaWxsaXNlY29uZHNcbiAgICAgIGxpa2VzOiBOdW1iZXIocG9zdEFjY291bnQubGlrZXMpLFxuICAgICAgY29tbWVudHM6IE51bWJlcihwb3N0QWNjb3VudC5jb21tZW50cyksXG4gICAgICBtaXJyb3JzOiBOdW1iZXIocG9zdEFjY291bnQubWlycm9ycyksXG4gICAgICBpbWFnZXM6IHBvc3RBY2NvdW50LmltYWdlcyxcbiAgICAgIHJhdGluZzogcG9zdEFjY291bnQucmF0aW5nIGFzIFBvc3RSYXRpbmcsXG4gICAgICBpbktpbGxab25lOiBwb3N0QWNjb3VudC5pbl9raWxsX3pvbmUgPT09IDEsXG4gICAgfVxuICB9XG5cbiAgLy8gQ3JlYXRlIHVzZXIgcHJvZmlsZSAtIFJFQUwgSU1QTEVNRU5UQVRJT05cbiAgY29uc3QgY3JlYXRlUHJvZmlsZSA9IGFzeW5jIChcbiAgICB1c2VybmFtZTogc3RyaW5nLFxuICAgIGJpbzogc3RyaW5nLFxuICAgIHByb2ZpbGVJbWFnZTogc3RyaW5nLFxuICAgIGNvdmVySW1hZ2U6IHN0cmluZ1xuICApID0+IHtcbiAgICBpZiAoIXB1YmxpY0tleSkgdGhyb3cgbmV3IEVycm9yKCdXYWxsZXQgbm90IGNvbm5lY3RlZCcpXG5cbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ/CflI0gUnVubmluZyBwcmUtZmxpZ2h0IGNoZWNrcy4uLicpXG4gICAgICBcbiAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBjaGVja1NPTEJhbGFuY2UoKVxuICAgICAgY29uc29sZS5sb2coYPCfkrAgU09MIEJhbGFuY2U6ICR7YmFsYW5jZX1gKVxuICAgICAgaWYgKGJhbGFuY2UgPCAwLjEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN1ZmZpY2llbnQgU09MIGJhbGFuY2U6ICR7YmFsYW5jZX0uIFlvdSBuZWVkIGF0IGxlYXN0IDAuMSBTT0wgZm9yIHRyYW5zYWN0aW9uIGZlZXMgYW5kIGFjY291bnQgY3JlYXRpb24uYClcbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJvZ3JhbUV4aXN0cyA9IGF3YWl0IGNoZWNrUHJvZ3JhbUV4aXN0cygpXG4gICAgICBjb25zb2xlLmxvZyhg8J+TiyBQcm9ncmFtIGV4aXN0czogJHtwcm9ncmFtRXhpc3RzfWApXG4gICAgICBpZiAoIXByb2dyYW1FeGlzdHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9ncmFtIG5vdCBmb3VuZCBhdCBhZGRyZXNzOiAke1BST0dSQU1fSUQudG9TdHJpbmcoKX0uIE1ha2Ugc3VyZSB0aGUgcHJvZ3JhbSBpcyBkZXBsb3llZCBvbiAke2NvbmZpZy5zb2xhbmEubmV0d29ya30uYClcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ+KchSBQcmUtZmxpZ2h0IGNoZWNrcyBwYXNzZWQnKVxuXG4gICAgICBjb25zdCBwcm9maWxlUERBID0gYXdhaXQgZ2V0UHJvZmlsZVBEQShwdWJsaWNLZXksIHVzZXJuYW1lKVxuICAgICAgY29uc29sZS5sb2coYPCfk40gUHJvZmlsZSBQREE6ICR7cHJvZmlsZVBEQS50b1N0cmluZygpfWApXG5cbiAgICAgIGNvbnN0IGluc3RydWN0aW9uRGF0YSA9IG5ldyBDcmVhdGVQcm9maWxlSW5zdHJ1Y3Rpb24oe1xuICAgICAgICB1c2VybmFtZSxcbiAgICAgICAgYmlvLFxuICAgICAgICBwcm9maWxlX2ltYWdlOiBwcm9maWxlSW1hZ2UsXG4gICAgICAgIGNvdmVyX2ltYWdlOiBjb3ZlckltYWdlLFxuICAgICAgfSlcblxuICAgICAgY29uc3QgY3JlYXRlUHJvZmlsZVZhcmlhbnQgPSBCdWZmZXIuZnJvbShbMF0pXG4gICAgICBjb25zdCBzZXJpYWxpemVkRGF0YSA9IHNlcmlhbGl6ZShjcmVhdGVQcm9maWxlU2NoZW1hLCBpbnN0cnVjdGlvbkRhdGEpXG4gICAgICBjb25zdCBmdWxsSW5zdHJ1Y3Rpb25EYXRhID0gQnVmZmVyLmNvbmNhdChbY3JlYXRlUHJvZmlsZVZhcmlhbnQsIEJ1ZmZlci5mcm9tKHNlcmlhbGl6ZWREYXRhKV0pXG5cbiAgICAgIGNvbnN0IGluc3RydWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICBrZXlzOiBbXG4gICAgICAgICAgeyBwdWJrZXk6IHB1YmxpY0tleSwgaXNTaWduZXI6IHRydWUsIGlzV3JpdGFibGU6IHRydWUgfSxcbiAgICAgICAgICB7IHB1YmtleTogcHJvZmlsZVBEQSwgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiB0cnVlIH0sXG4gICAgICAgICAgeyBwdWJrZXk6IFN5c3RlbVByb2dyYW0ucHJvZ3JhbUlkLCBpc1NpZ25lcjogZmFsc2UsIGlzV3JpdGFibGU6IGZhbHNlIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHByb2dyYW1JZDogUFJPR1JBTV9JRCxcbiAgICAgICAgZGF0YTogZnVsbEluc3RydWN0aW9uRGF0YSxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKGluc3RydWN0aW9uKVxuICAgICAgY29uc3QgeyBibG9ja2hhc2ggfSA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2toYXNoKCdwcm9jZXNzZWQnKVxuICAgICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoXG4gICAgICB0cmFuc2FjdGlvbi5mZWVQYXllciA9IHB1YmxpY0tleVxuXG4gICAgICBjb25zdCBzaW11bGF0aW9uID0gYXdhaXQgY29ubmVjdGlvbi5zaW11bGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKVxuICAgICAgaWYgKHNpbXVsYXRpb24udmFsdWUuZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gc2ltdWxhdGlvbiBmYWlsZWQ6ICR7SlNPTi5zdHJpbmdpZnkoc2ltdWxhdGlvbi52YWx1ZS5lcnIpfWApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgY29ubmVjdGlvbiwge1xuICAgICAgICBza2lwUHJlZmxpZ2h0OiBmYWxzZSxcbiAgICAgICAgcHJlZmxpZ2h0Q29tbWl0bWVudDogJ3Byb2Nlc3NlZCcsXG4gICAgICAgIG1heFJldHJpZXM6IDMsXG4gICAgICB9KVxuXG4gICAgICBhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbih7XG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgYmxvY2toYXNoLFxuICAgICAgICBsYXN0VmFsaWRCbG9ja0hlaWdodDogKGF3YWl0IGNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2toYXNoKCkpLmxhc3RWYWxpZEJsb2NrSGVpZ2h0LFxuICAgICAgfSwgJ3Byb2Nlc3NlZCcpXG4gICAgICBcbiAgICAgIC8vIEludmFsaWRhdGUgY2FjaGUgYWZ0ZXIgcHJvZmlsZSBjcmVhdGlvblxuICAgICAgY2xlYXJQcm9maWxlQ2FjaGUocHVibGljS2V5LnRvU3RyaW5nKCkpXG4gICAgICBcbiAgICAgIHRvYXN0LnN1Y2Nlc3MoJ1Byb2ZpbGUgY3JlYXRlZCBzdWNjZXNzZnVsbHkhJylcbiAgICAgIHJldHVybiBzaWduYXR1cmVcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgUHJvZmlsZSBjcmVhdGlvbiBlcnJvcjonLCBlcnJvcilcbiAgICAgIHRvYXN0LmVycm9yKGBUcmFuc2FjdGlvbiBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YClcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLy8gUHJvZHVjdGlvbi1yZWFkeSBwcm9maWxlIGRldGVjdGlvbiB3aXRoIGxvY2FsU3RvcmFnZSBjYWNoaW5nIC0gSW1wcm92ZWQgZm9yIG11bHRpcGxlIHVzZXJzXG4gIGNvbnN0IGdldFByb2ZpbGUgPSBhc3luYyAodXNlclB1YmxpY0tleTogUHVibGljS2V5KTogUHJvbWlzZTxQcm9maWxlIHwgbnVsbD4gPT4ge1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gdXNlclB1YmxpY0tleS50b1N0cmluZygpXG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIDEuIENoZWNrIGxvY2FsU3RvcmFnZSBjYWNoZSBmaXJzdCAoZmFzdGVzdClcbiAgICAgIGNvbnN0IGNhY2hlZFByb2ZpbGUgPSBnZXRQcm9maWxlRnJvbUxvY2FsU3RvcmFnZShjYWNoZUtleSlcbiAgICAgIGlmIChjYWNoZWRQcm9maWxlICE9PSBudWxsKSB7XG4gICAgICAgIC8vIEFsc28gdXBkYXRlIG1lbW9yeSBjYWNoZVxuICAgICAgICBwcm9maWxlQ2FjaGUuc2V0KGNhY2hlS2V5LCBjYWNoZWRQcm9maWxlKVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHByb2ZpbGVDYWNoZS5kZWxldGUoY2FjaGVLZXkpLCBDQUNIRV9EVVJBVElPTilcbiAgICAgICAgcmV0dXJuIGNhY2hlZFByb2ZpbGVcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gMi4gQ2hlY2sgbWVtb3J5IGNhY2hlXG4gICAgICBpZiAocHJvZmlsZUNhY2hlLmhhcyhjYWNoZUtleSkpIHtcbiAgICAgICAgY29uc3QgY2FjaGVkID0gcHJvZmlsZUNhY2hlLmdldChjYWNoZUtleSlcbiAgICAgICAgcmV0dXJuIGNhY2hlZCA/PyBudWxsXG4gICAgICB9XG5cbiAgICAgIC8vIDMuIEZldGNoIGZyb20gYmxvY2tjaGFpbiAoc2xvd2VzdClcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIEZldGNoaW5nIHByb2ZpbGUgZnJvbSBibG9ja2NoYWluIGZvcjogJHt1c2VyUHVibGljS2V5LnRvU3RyaW5nKCkuc2xpY2UoMCwgOCl9Li4uYClcbiAgICAgIFxuICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBjb25uZWN0aW9uLmdldFByb2dyYW1BY2NvdW50cyhQUk9HUkFNX0lEKVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhg8J+TiiBGb3VuZCAke2FjY291bnRzLmxlbmd0aH0gcHJvZ3JhbSBhY2NvdW50cyB0byBzY2FuIGZvciBwcm9maWxlc2ApXG5cbiAgICAgIGxldCBwcm9maWxlc0ZvdW5kID0gMFxuICAgICAgXG4gICAgICAvLyBTY2FuIHRocm91Z2ggYWNjb3VudHMgdG8gZmluZCB1c2VyJ3MgcHJvZmlsZVxuICAgICAgZm9yIChjb25zdCB7IGFjY291bnQsIHB1YmtleSB9IG9mIGFjY291bnRzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKGFjY291bnQuZGF0YS5sZW5ndGggPT09IDApIGNvbnRpbnVlXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVHJ5IG1hbnVhbCBwYXJzaW5nIGZpcnN0XG4gICAgICAgICAgY29uc3QgcHJvZmlsZUFjY291bnQgPSBtYW51YWxQYXJzZVByb2ZpbGUoYWNjb3VudC5kYXRhKVxuICAgICAgICAgIGlmICghcHJvZmlsZUFjY291bnQpIGNvbnRpbnVlXG4gICAgICAgICAgXG4gICAgICAgICAgcHJvZmlsZXNGb3VuZCsrXG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgYWNjb3VudE93bmVyID0gbmV3IFB1YmxpY0tleShwcm9maWxlQWNjb3VudC5vd25lcilcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIHByb2ZpbGUgYmVsb25ncyB0byB0aGUgdXNlciB3ZSdyZSBsb29raW5nIGZvclxuICAgICAgICAgIGlmIChwcm9maWxlQWNjb3VudC5pc19pbml0aWFsaXplZCA9PT0gMSAmJiBhY2NvdW50T3duZXIuZXF1YWxzKHVzZXJQdWJsaWNLZXkpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+OryBGT1VORCBQUk9GSUxFISBVc2VybmFtZTogXCIke3Byb2ZpbGVBY2NvdW50LnVzZXJuYW1lfVwiIGZvciAke3VzZXJQdWJsaWNLZXkudG9TdHJpbmcoKS5zbGljZSgwLCA4KX1gKVxuICAgICAgICAgICAgY29uc29sZS5sb2coYPCfk7ggUHJvZmlsZSBJbWFnZSBVUkw6IFwiJHtwcm9maWxlQWNjb3VudC5wcm9maWxlX2ltYWdlfVwiYClcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5a877iPIENvdmVyIEltYWdlIFVSTDogXCIke3Byb2ZpbGVBY2NvdW50LmNvdmVyX2ltYWdlfVwiYClcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OKIFByb2ZpbGUgRGF0YTpgLCB7XG4gICAgICAgICAgICAgIHVzZXJuYW1lOiBwcm9maWxlQWNjb3VudC51c2VybmFtZSxcbiAgICAgICAgICAgICAgYmlvOiBwcm9maWxlQWNjb3VudC5iaW8sXG4gICAgICAgICAgICAgIHByb2ZpbGVJbWFnZTogcHJvZmlsZUFjY291bnQucHJvZmlsZV9pbWFnZSxcbiAgICAgICAgICAgICAgY292ZXJJbWFnZTogcHJvZmlsZUFjY291bnQuY292ZXJfaW1hZ2UsXG4gICAgICAgICAgICAgIHBvc3RzQ291bnQ6IE51bWJlcihwcm9maWxlQWNjb3VudC5wb3N0c19jb3VudCksXG4gICAgICAgICAgICAgIGZvbGxvd2Vyc0NvdW50OiBOdW1iZXIocHJvZmlsZUFjY291bnQuZm9sbG93ZXJzX2NvdW50KSxcbiAgICAgICAgICAgICAgaXNWZXJpZmllZDogcHJvZmlsZUFjY291bnQuaXNfdmVyaWZpZWQgPT09IDFcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBjb25zdCBwcm9maWxlID0gY29udmVydFByb2ZpbGVBY2NvdW50KHByb2ZpbGVBY2NvdW50KVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDYWNoZSBpbiBib3RoIG1lbW9yeSBhbmQgbG9jYWxTdG9yYWdlXG4gICAgICAgICAgICBwcm9maWxlQ2FjaGUuc2V0KGNhY2hlS2V5LCBwcm9maWxlKVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBwcm9maWxlQ2FjaGUuZGVsZXRlKGNhY2hlS2V5KSwgQ0FDSEVfRFVSQVRJT04pXG4gICAgICAgICAgICBzYXZlUHJvZmlsZVRvTG9jYWxTdG9yYWdlKGNhY2hlS2V5LCBwcm9maWxlKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gcHJvZmlsZVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAvLyBOb3QgYSBwcm9maWxlIGFjY291bnQgb3IgcGFyc2luZyBmYWlsZWQsIGNvbnRpbnVlXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhg8J+TiiBTY2FubmVkICR7cHJvZmlsZXNGb3VuZH0gcHJvZmlsZXMsIG5vIG1hdGNoIGZvdW5kIGZvciB1c2VyOiAke3VzZXJQdWJsaWNLZXkudG9TdHJpbmcoKS5zbGljZSgwLCA4KX1gKVxuXG4gICAgICAvLyBObyBwcm9maWxlIGZvdW5kIC0gY2FjaGUgbnVsbCByZXN1bHQgdG8gYXZvaWQgcmVwZWF0ZWQgc2NhbnNcbiAgICAgIHByb2ZpbGVDYWNoZS5zZXQoY2FjaGVLZXksIG51bGwpXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHByb2ZpbGVDYWNoZS5kZWxldGUoY2FjaGVLZXkpLCBDQUNIRV9EVVJBVElPTilcbiAgICAgIHNhdmVQcm9maWxlVG9Mb2NhbFN0b3JhZ2UoY2FjaGVLZXksIG51bGwpXG4gICAgICBcbiAgICAgIHJldHVybiBudWxsXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIHByb2ZpbGUgZm9yICR7dXNlclB1YmxpY0tleS50b1N0cmluZygpLnNsaWNlKDAsIDgpfTpgLCBlcnJvcilcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgLy8gR2V0IHByb2ZpbGUgYnkgdXNlcm5hbWUgKGZvciBzcGVjaWZpYyBsb29rdXBzKVxuICBjb25zdCBnZXRQcm9maWxlQnlVc2VybmFtZSA9IGFzeW5jICh1c2VyUHVibGljS2V5OiBQdWJsaWNLZXksIHVzZXJuYW1lOiBzdHJpbmcpOiBQcm9taXNlPFByb2ZpbGUgfCBudWxsPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHByb2ZpbGVQREEgPSBhd2FpdCBnZXRQcm9maWxlUERBKHVzZXJQdWJsaWNLZXksIHVzZXJuYW1lKVxuICAgICAgY29uc3QgYWNjb3VudEluZm8gPSBhd2FpdCBjb25uZWN0aW9uLmdldEFjY291bnRJbmZvKHByb2ZpbGVQREEpXG4gICAgICBcbiAgICAgIGlmICghYWNjb3VudEluZm8gfHwgIWFjY291bnRJbmZvLmRhdGEgfHwgYWNjb3VudEluZm8uZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cblxuICAgICAgLy8gTm93IHRyeSBtYW51YWwgcGFyc2luZ1xuICAgICAgY29uc3QgcHJvZmlsZUFjY291bnQgPSBtYW51YWxQYXJzZVByb2ZpbGUoYWNjb3VudEluZm8uZGF0YSlcbiAgICAgIGlmIChwcm9maWxlQWNjb3VudCkge1xuICAgICAgICBjb25zb2xlLmxvZyhg4pyFIFN1Y2Nlc3NmdWxseSBtYW51YWxseSBwYXJzZWQgcHJvZmlsZTpgLCB7XG4gICAgICAgICAgdXNlcm5hbWU6IHByb2ZpbGVBY2NvdW50LnVzZXJuYW1lLFxuICAgICAgICAgIGJpbzogcHJvZmlsZUFjY291bnQuYmlvLFxuICAgICAgICAgIGlzSW5pdGlhbGl6ZWQ6IHByb2ZpbGVBY2NvdW50LmlzX2luaXRpYWxpemVkID09PSAxLFxuICAgICAgICAgIG93bmVyOiBuZXcgUHVibGljS2V5KHByb2ZpbGVBY2NvdW50Lm93bmVyKS50b1N0cmluZygpLFxuICAgICAgICAgIHByb2ZpbGVJbWFnZTogcHJvZmlsZUFjY291bnQucHJvZmlsZV9pbWFnZSxcbiAgICAgICAgICBjb3ZlckltYWdlOiBwcm9maWxlQWNjb3VudC5jb3Zlcl9pbWFnZSxcbiAgICAgICAgICBwb3N0c0NvdW50OiBOdW1iZXIocHJvZmlsZUFjY291bnQucG9zdHNfY291bnQpXG4gICAgICAgIH0pXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gY29udmVydFByb2ZpbGVBY2NvdW50KHByb2ZpbGVBY2NvdW50KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coYOKdjCBNYW51YWwgcGFyc2luZyBmYWlsZWRgKVxuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIC8vIEdldCBwb3N0cyAtIFNJTVBMSUZJRUQgd2l0aG91dCBjb21wbGV4IGZpbHRlcmluZ1xuICBjb25zdCBnZXRQb3N0cyA9IGFzeW5jICgpOiBQcm9taXNlPFBvc3RbXT4gPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBDaGVjayBjYWNoZSBmaXJzdFxuICAgICAgaWYgKHBvc3RzQ2FjaGUgJiYgRGF0ZS5ub3coKSAtIHBvc3RzQ2FjaGUudGltZXN0YW1wIDwgUE9TVFNfQ0FDSEVfRFVSQVRJT04pIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KaoSBVc2luZyBjYWNoZWQgcG9zdHMnKVxuICAgICAgICByZXR1cm4gcG9zdHNDYWNoZS5wb3N0c1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygn8J+UjSBGZXRjaGluZyBwb3N0cyBmcm9tIGJsb2NrY2hhaW4uLi4nKVxuICAgICAgXG4gICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0UHJvZ3JhbUFjY291bnRzKFBST0dSQU1fSUQpXG4gICAgICBjb25zdCBwb3N0czogUG9zdFtdID0gW11cblxuICAgICAgY29uc29sZS5sb2coYPCfk4ogU2Nhbm5pbmcgJHthY2NvdW50cy5sZW5ndGh9IHByb2dyYW0gYWNjb3VudHMgZm9yIHBvc3RzLi4uYClcblxuICAgICAgZm9yIChjb25zdCB7IGFjY291bnQsIHB1YmtleSB9IG9mIGFjY291bnRzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKGFjY291bnQuZGF0YS5sZW5ndGggPT09IDApIGNvbnRpbnVlXG5cbiAgICAgICAgICAvLyBTa2lwIGlmIHRoaXMgaXMgYSBrbm93biBjb21tZW50IGFjY291bnRcbiAgICAgICAgICBpZiAoaXNDb21tZW50QWNjb3VudChwdWJrZXkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDij63vuI8gU2tpcHBpbmcgY29tbWVudCBhY2NvdW50OiAke3B1YmtleS50b1N0cmluZygpLnNsaWNlKDAsIDgpfWApXG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHBvc3RBY2NvdW50ID0gbWFudWFsUGFyc2VQb3N0KGFjY291bnQuZGF0YSlcbiAgICAgICAgICBpZiAocG9zdEFjY291bnQgJiYgcG9zdEFjY291bnQuaXNfaW5pdGlhbGl6ZWQgPT09IDEgJiYgcG9zdEFjY291bnQuY29udGVudCkge1xuICAgICAgICAgICAgY29uc3QgcG9zdCA9IGNvbnZlcnRQb3N0QWNjb3VudChwb3N0QWNjb3VudClcbiAgICAgICAgICAgIHBvc3RzLnB1c2gocG9zdClcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OdIEZvdW5kIHBvc3Q6IFwiJHtwb3N0LmNvbnRlbnQuc3Vic3RyaW5nKDAsIDUwKX0uLi5cIiBieSAke3Bvc3QuYXV0aG9yLnRvU3RyaW5nKCl9YClcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwb3N0cy5zb3J0KChhLCBiKSA9PiBiLnRpbWVzdGFtcCAtIGEudGltZXN0YW1wKVxuICAgICAgY29uc29sZS5sb2coYOKchSBMb2FkZWQgJHtwb3N0cy5sZW5ndGh9IHBvc3RzIGZyb20gYmxvY2tjaGFpbiAoY29tbWVudHMgZmlsdGVyZWQgb3V0KWApXG4gICAgICBcbiAgICAgIC8vIENhY2hlIHRoZSByZXN1bHRzXG4gICAgICBwb3N0c0NhY2hlID0geyBwb3N0cywgdGltZXN0YW1wOiBEYXRlLm5vdygpIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHBvc3RzXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHBvc3RzOicsIGVycm9yKVxuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuICB9XG5cbiAgLy8gR2V0IGNvbW1lbnRzIGZvciBhIHNwZWNpZmljIHBvc3QgLSBSRUFMIEJMT0NLQ0hBSU4gSU1QTEVNRU5UQVRJT05cbiAgY29uc3QgZ2V0Q29tbWVudHNGb3JQb3N0ID0gYXN5bmMgKHBvc3RJZDogbnVtYmVyKTogUHJvbWlzZTxDb21tZW50W10+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYPCflI0gR2V0dGluZyBjb21tZW50cyBmb3IgcG9zdCBJRCAke3Bvc3RJZH0gZnJvbSBibG9ja2NoYWluLi4uYClcbiAgICAgIFxuICAgICAgLy8gU2NhbiBhbGwgcHJvZ3JhbSBhY2NvdW50cyB0byBmaW5kIGNvbW1lbnRzIGZvciB0aGlzIHBvc3RcbiAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgY29ubmVjdGlvbi5nZXRQcm9ncmFtQWNjb3VudHMoUFJPR1JBTV9JRClcbiAgICAgIGNvbnN0IGNvbW1lbnRzOiBDb21tZW50W10gPSBbXVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhg8J+TiiBTY2FubmluZyAke2FjY291bnRzLmxlbmd0aH0gcHJvZ3JhbSBhY2NvdW50cyBmb3IgY29tbWVudHMuLi5gKVxuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IHsgYWNjb3VudCwgcHVia2V5IH0gb2YgYWNjb3VudHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoYWNjb3VudC5kYXRhLmxlbmd0aCA9PT0gMCkgY29udGludWVcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGFjY291bnQgaXMgYSBrbm93biBjb21tZW50IGFjY291bnQgZm9yIG91ciB0YXJnZXQgcG9zdFxuICAgICAgICAgIGlmIChpc0NvbW1lbnRBY2NvdW50KHB1YmtleS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50UG9zdElkID0gZ2V0UGFyZW50UG9zdElkKHB1YmtleS50b1N0cmluZygpKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAocGFyZW50UG9zdElkID09PSBwb3N0SWQpIHtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIGNvbW1lbnQgZm9yIG91ciB0YXJnZXQgcG9zdFxuICAgICAgICAgICAgICBjb25zdCBwb3N0QWNjb3VudCA9IG1hbnVhbFBhcnNlUG9zdChhY2NvdW50LmRhdGEpXG4gICAgICAgICAgICAgIGlmIChwb3N0QWNjb3VudCAmJiBwb3N0QWNjb3VudC5pc19pbml0aWFsaXplZCA9PT0gMSAmJiBwb3N0QWNjb3VudC5jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCfkqwgRm91bmQgY29tbWVudDogXCIke3Bvc3RBY2NvdW50LmNvbnRlbnQuc3Vic3RyaW5nKDAsIDMwKX0uLi5cIiBmb3IgcG9zdCAke3Bvc3RJZH1gKVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgY29tbWVudCBhdXRob3IncyBwcm9maWxlXG4gICAgICAgICAgICAgICAgY29uc3QgYXV0aG9yUHVibGljS2V5ID0gbmV3IFB1YmxpY0tleShwb3N0QWNjb3VudC5hdXRob3IpXG4gICAgICAgICAgICAgICAgY29uc3QgYXV0aG9yUHJvZmlsZSA9IGF3YWl0IGdldFByb2ZpbGUoYXV0aG9yUHVibGljS2V5KVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbW1lbnQ6IENvbW1lbnQgPSB7XG4gICAgICAgICAgICAgICAgICBpZDogTnVtYmVyKHBvc3RBY2NvdW50LmlkKSxcbiAgICAgICAgICAgICAgICAgIHBhcmVudFBvc3RJZDogcG9zdElkLFxuICAgICAgICAgICAgICAgICAgYXV0aG9yOiBhdXRob3JQdWJsaWNLZXksXG4gICAgICAgICAgICAgICAgICBjb250ZW50OiBwb3N0QWNjb3VudC5jb250ZW50LFxuICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBOdW1iZXIocG9zdEFjY291bnQudGltZXN0YW1wKSAqIDEwMDAsIC8vIENvbnZlcnQgdG8gbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICAgICAgICBsaWtlczogTnVtYmVyKHBvc3RBY2NvdW50Lmxpa2VzKSxcbiAgICAgICAgICAgICAgICAgIGF1dGhvclByb2ZpbGU6IGF1dGhvclByb2ZpbGVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29tbWVudHMucHVzaChjb21tZW50KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQWxzbyBpbmNsdWRlIGFueSBjb21tZW50cyBmcm9tIGluLW1lbW9yeSBzdG9yYWdlIChmb3IgaW1tZWRpYXRlIGRpc3BsYXkgYWZ0ZXIgcG9zdGluZylcbiAgICAgIGNvbnN0IG1lbW9yeUNvbW1lbnRzID0gY29tbWVudHNTdG9yYWdlW3Bvc3RJZF0gfHwgW11cbiAgICAgIFxuICAgICAgLy8gQ29tYmluZSBhbmQgZGVkdXBsaWNhdGUgY29tbWVudHNcbiAgICAgIGNvbnN0IGFsbENvbW1lbnRzID0gWy4uLmNvbW1lbnRzXVxuICAgICAgXG4gICAgICAvLyBBZGQgbWVtb3J5IGNvbW1lbnRzIHRoYXQgYXJlbid0IGFscmVhZHkgaW4gYmxvY2tjaGFpbiBjb21tZW50c1xuICAgICAgZm9yIChjb25zdCBtZW1vcnlDb21tZW50IG9mIG1lbW9yeUNvbW1lbnRzKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0cyA9IGFsbENvbW1lbnRzLnNvbWUoYyA9PiBcbiAgICAgICAgICBjLmF1dGhvci5lcXVhbHMobWVtb3J5Q29tbWVudC5hdXRob3IpICYmIFxuICAgICAgICAgIGMuY29udGVudCA9PT0gbWVtb3J5Q29tbWVudC5jb250ZW50ICYmXG4gICAgICAgICAgTWF0aC5hYnMoYy50aW1lc3RhbXAgLSBtZW1vcnlDb21tZW50LnRpbWVzdGFtcCkgPCAxMDAwMCAvLyBXaXRoaW4gMTAgc2Vjb25kc1xuICAgICAgICApXG4gICAgICAgIGlmICghZXhpc3RzKSB7XG4gICAgICAgICAgYWxsQ29tbWVudHMucHVzaChtZW1vcnlDb21tZW50KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNvcnQgYnkgdGltZXN0YW1wIChvbGRlc3QgZmlyc3QgZm9yIGNvbW1lbnRzKVxuICAgICAgYWxsQ29tbWVudHMuc29ydCgoYSwgYikgPT4gYS50aW1lc3RhbXAgLSBiLnRpbWVzdGFtcClcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYOKchSBGb3VuZCAke2FsbENvbW1lbnRzLmxlbmd0aH0gY29tbWVudHMgZm9yIHBvc3QgJHtwb3N0SWR9ICgke2NvbW1lbnRzLmxlbmd0aH0gZnJvbSBibG9ja2NoYWluLCAke21lbW9yeUNvbW1lbnRzLmxlbmd0aH0gZnJvbSBtZW1vcnkpYClcbiAgICAgIHJldHVybiBhbGxDb21tZW50c1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBjb21tZW50cyBmcm9tIGJsb2NrY2hhaW46JywgZXJyb3IpXG4gICAgICBcbiAgICAgIC8vIEZhbGxiYWNrIHRvIGluLW1lbW9yeSBzdG9yYWdlXG4gICAgICBjb25zdCBtZW1vcnlDb21tZW50cyA9IGNvbW1lbnRzU3RvcmFnZVtwb3N0SWRdIHx8IFtdXG4gICAgICBjb25zb2xlLmxvZyhg4pqg77iPIEZhbGxiYWNrOiByZXR1cm5pbmcgJHttZW1vcnlDb21tZW50cy5sZW5ndGh9IGNvbW1lbnRzIGZyb20gbWVtb3J5YClcbiAgICAgIHJldHVybiBtZW1vcnlDb21tZW50c1xuICAgIH1cbiAgfVxuXG4gIC8vIFN0b3JlIGNvbW1lbnQgLSBTSU1QTElGSUVEXG4gIGNvbnN0IHN0b3JlQ29tbWVudCA9IChwYXJlbnRQb3N0SWQ6IG51bWJlciwgY29tbWVudDogQ29tbWVudCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+SviBTdG9yaW5nIGNvbW1lbnQgZm9yIHBvc3QgJHtwYXJlbnRQb3N0SWR9OmAsIGNvbW1lbnQuY29udGVudC5zdWJzdHJpbmcoMCwgMzApKVxuICAgICAgXG4gICAgICBpZiAoIWNvbW1lbnRzU3RvcmFnZVtwYXJlbnRQb3N0SWRdKSB7XG4gICAgICAgIGNvbW1lbnRzU3RvcmFnZVtwYXJlbnRQb3N0SWRdID0gW11cbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29tbWVudHNTdG9yYWdlW3BhcmVudFBvc3RJZF0ucHVzaChjb21tZW50KVxuICAgICAgY29uc29sZS5sb2coYOKchSBTdG9yZWQgY29tbWVudC4gUG9zdCAke3BhcmVudFBvc3RJZH0gbm93IGhhcyAke2NvbW1lbnRzU3RvcmFnZVtwYXJlbnRQb3N0SWRdLmxlbmd0aH0gY29tbWVudHNgKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc3RvcmUgY29tbWVudDonLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICAvLyBDcmVhdGUgcG9zdCAtIFJFQUwgSU1QTEVNRU5UQVRJT05cbiAgY29uc3QgY3JlYXRlUG9zdCA9IGFzeW5jIChjb250ZW50OiBzdHJpbmcsIGltYWdlczogc3RyaW5nW10gPSBbXSkgPT4ge1xuICAgIGlmICghcHVibGljS2V5KSB0aHJvdyBuZXcgRXJyb3IoJ1dhbGxldCBub3QgY29ubmVjdGVkJylcblxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+UjSBDcmVhdGluZyBwb3N0IHdpdGggY29udGVudDonLCBjb250ZW50KVxuICAgICAgXG4gICAgICAvLyBDaGVjayBTT0wgYmFsYW5jZVxuICAgICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IGNoZWNrU09MQmFsYW5jZSgpXG4gICAgICBpZiAoYmFsYW5jZSA8IDAuMDUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN1ZmZpY2llbnQgU09MIGJhbGFuY2U6ICR7YmFsYW5jZX0uIFlvdSBuZWVkIGF0IGxlYXN0IDAuMDUgU09MIGZvciB0cmFuc2FjdGlvbiBmZWVzIGFuZCBhY2NvdW50IGNyZWF0aW9uLmApXG4gICAgICB9XG5cbiAgICAgIC8vIEdldCB1c2VyJ3MgcHJvZmlsZSBQREEgLSB3ZSBuZWVkIHRoaXMgZm9yIHRoZSBpbnN0cnVjdGlvblxuICAgICAgY29uc3QgdXNlclByb2ZpbGUgPSBhd2FpdCBnZXRQcm9maWxlKHB1YmxpY0tleSlcbiAgICAgIGlmICghdXNlclByb2ZpbGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBjcmVhdGUgYSBwcm9maWxlIGJlZm9yZSBwb3N0aW5nJylcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IHVzZXIncyBjdXJyZW50IHBvc3QgY291bnQgdG8gZ2VuZXJhdGUgdGhlIGNvcnJlY3QgcG9zdCBJRFxuICAgICAgLy8gVGhlIFJ1c3QgY29udHJhY3QgaW5jcmVtZW50cyBwb3N0c19jb3VudCBmaXJzdCwgdGhlbiB1c2VzIHRoYXQgYXMgdGhlIHBvc3QgSURcbiAgICAgIGNvbnN0IHBvc3RJZCA9IHVzZXJQcm9maWxlLnBvc3RzQ291bnQgKyAxXG4gICAgICBjb25zdCBwb3N0UERBID0gYXdhaXQgZ2V0UG9zdFBEQShwdWJsaWNLZXksIHBvc3RJZClcbiAgICAgIGNvbnNvbGUubG9nKGDwn5ONIFBvc3QgUERBOiAke3Bvc3RQREEudG9TdHJpbmcoKX0gZm9yIHBvc3QgSUQ6ICR7cG9zdElkfWApXG5cbiAgICAgIC8vIEdlbmVyYXRlIGEgbmV3IGtleXBhaXIgZm9yIHRoZSBwb3N0IGFjY291bnRcbiAgICAgIC8vIFRoZSBSdXN0IGNvbnRyYWN0IHVzZXMgaW52b2tlIHdpdGggc3lzdGVtX2luc3RydWN0aW9uOjpjcmVhdGVfYWNjb3VudFxuICAgICAgLy8gVGhpcyBtZWFucyB0aGUgcG9zdCBhY2NvdW50IE1VU1QgYmUgYSBrZXlwYWlyIHRoYXQgc2lnbnMgdGhlIHRyYW5zYWN0aW9uXG4gICAgICBjb25zdCBwb3N0S2V5cGFpciA9IEtleXBhaXIuZ2VuZXJhdGUoKVxuICAgICAgY29uc29sZS5sb2coYPCfk40gUG9zdCBBY2NvdW50OiAke3Bvc3RLZXlwYWlyLnB1YmxpY0tleS50b1N0cmluZygpfWApXG5cbiAgICAgIC8vIEdldCBwcm9maWxlIFBEQSBmb3IgdGhlIHVzZXIgKHdlIG5lZWQgdGhlIGFjdHVhbCB1c2VybmFtZSlcbiAgICAgIC8vIFRyeSB0byBmaW5kIHRoZSBwcm9maWxlIGFjY291bnQgYW1vbmcgYWxsIHByb2dyYW0gYWNjb3VudHNcbiAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgY29ubmVjdGlvbi5nZXRQcm9ncmFtQWNjb3VudHMoUFJPR1JBTV9JRClcbiAgICAgIGxldCB1c2VyUHJvZmlsZVBEQTogUHVibGljS2V5IHwgbnVsbCA9IG51bGxcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCB7IGFjY291bnQsIHB1YmtleSB9IG9mIGFjY291bnRzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcHJvZmlsZUFjY291bnQgPSBtYW51YWxQYXJzZVByb2ZpbGUoYWNjb3VudC5kYXRhKVxuICAgICAgICAgIGlmIChwcm9maWxlQWNjb3VudCAmJiBcbiAgICAgICAgICAgICAgcHJvZmlsZUFjY291bnQuaXNfaW5pdGlhbGl6ZWQgPT09IDEgJiYgXG4gICAgICAgICAgICAgIG5ldyBQdWJsaWNLZXkocHJvZmlsZUFjY291bnQub3duZXIpLmVxdWFscyhwdWJsaWNLZXkpKSB7XG4gICAgICAgICAgICB1c2VyUHJvZmlsZVBEQSA9IHB1YmtleVxuICAgICAgICAgICAgY29uc29sZS5sb2coYPCfk40gVXNlciBQcm9maWxlIFBEQTogJHt1c2VyUHJvZmlsZVBEQS50b1N0cmluZygpfWApXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdXNlclByb2ZpbGVQREEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCB5b3VyIHByb2ZpbGUgUERBLiBQbGVhc2UgcmVmcmVzaCBhbmQgdHJ5IGFnYWluLicpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGluc3RydWN0aW9uRGF0YSA9IG5ldyBDcmVhdGVQb3N0SW5zdHJ1Y3Rpb24oe1xuICAgICAgICBjb250ZW50LFxuICAgICAgICBpbWFnZXMsXG4gICAgICB9KVxuXG4gICAgICBjb25zdCBjcmVhdGVQb3N0VmFyaWFudCA9IEJ1ZmZlci5mcm9tKFsyXSkgLy8gQ3JlYXRlUG9zdCBlbnVtIGluZGV4XG4gICAgICBjb25zdCBzZXJpYWxpemVkRGF0YSA9IHNlcmlhbGl6ZShjcmVhdGVQb3N0U2NoZW1hLCBpbnN0cnVjdGlvbkRhdGEpXG4gICAgICBjb25zdCBmdWxsSW5zdHJ1Y3Rpb25EYXRhID0gQnVmZmVyLmNvbmNhdChbY3JlYXRlUG9zdFZhcmlhbnQsIEJ1ZmZlci5mcm9tKHNlcmlhbGl6ZWREYXRhKV0pXG5cbiAgICAgIGNvbnNvbGUubG9nKGDwn5SiIEluc3RydWN0aW9uIGRhdGEgbGVuZ3RoOiAke2Z1bGxJbnN0cnVjdGlvbkRhdGEubGVuZ3RofSBieXRlc2ApXG5cbiAgICAgIGNvbnN0IGluc3RydWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICBrZXlzOiBbXG4gICAgICAgICAgeyBwdWJrZXk6IHB1YmxpY0tleSwgaXNTaWduZXI6IHRydWUsIGlzV3JpdGFibGU6IHRydWUgfSwgLy8gVXNlciBhY2NvdW50IChwYXllcilcbiAgICAgICAgICB7IHB1YmtleTogcG9zdEtleXBhaXIucHVibGljS2V5LCBpc1NpZ25lcjogdHJ1ZSwgaXNXcml0YWJsZTogdHJ1ZSB9LCAvLyBQb3N0IGFjY291bnQgKG11c3QgYmUgc2lnbmVyKVxuICAgICAgICAgIHsgcHVia2V5OiB1c2VyUHJvZmlsZVBEQSwgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiB0cnVlIH0sIC8vIFVzZXIgcHJvZmlsZSAoZm9yIHBvc3QgY291bnQpXG4gICAgICAgICAgeyBwdWJrZXk6IFN5c3RlbVByb2dyYW0ucHJvZ3JhbUlkLCBpc1NpZ25lcjogZmFsc2UsIGlzV3JpdGFibGU6IGZhbHNlIH0sIC8vIFN5c3RlbSBwcm9ncmFtXG4gICAgICAgIF0sXG4gICAgICAgIHByb2dyYW1JZDogUFJPR1JBTV9JRCxcbiAgICAgICAgZGF0YTogZnVsbEluc3RydWN0aW9uRGF0YSxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnNvbGUubG9nKCfwn5OdIFRyYW5zYWN0aW9uIGluc3RydWN0aW9uIGNyZWF0ZWQnKVxuICAgICAgY29uc29sZS5sb2coJ/CflJEgS2V5czonLCBpbnN0cnVjdGlvbi5rZXlzLm1hcChrID0+ICh7XG4gICAgICAgIHB1YmtleTogay5wdWJrZXkudG9TdHJpbmcoKSxcbiAgICAgICAgaXNTaWduZXI6IGsuaXNTaWduZXIsXG4gICAgICAgIGlzV3JpdGFibGU6IGsuaXNXcml0YWJsZVxuICAgICAgfSkpKVxuXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpLmFkZChpbnN0cnVjdGlvbilcbiAgICAgIGNvbnN0IHsgYmxvY2toYXNoIH0gPSBhd2FpdCBjb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCgncHJvY2Vzc2VkJylcbiAgICAgIHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCA9IGJsb2NraGFzaFxuICAgICAgdHJhbnNhY3Rpb24uZmVlUGF5ZXIgPSBwdWJsaWNLZXlcblxuICAgICAgLy8gU2lnbiB0cmFuc2FjdGlvbiBiZWZvcmUgc2ltdWxhdGlvblxuICAgICAgdHJhbnNhY3Rpb24ucGFydGlhbFNpZ24ocG9zdEtleXBhaXIpXG4gICAgICBcbiAgICAgIC8vIFNpbXVsYXRlIHRyYW5zYWN0aW9uIFxuICAgICAgY29uc3Qgc2ltdWxhdGlvbiA9IGF3YWl0IGNvbm5lY3Rpb24uc2ltdWxhdGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbilcbiAgICAgIGNvbnNvbGUubG9nKCfwn46vIFRyYW5zYWN0aW9uIHNpbXVsYXRpb246Jywgc2ltdWxhdGlvbilcbiAgICAgIFxuICAgICAgaWYgKHNpbXVsYXRpb24udmFsdWUuZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gc2ltdWxhdGlvbiBmYWlsZWQ6ICR7SlNPTi5zdHJpbmdpZnkoc2ltdWxhdGlvbi52YWx1ZS5lcnIpfWApXG4gICAgICB9XG5cbiAgICAgIC8vIFNlbmQgdHJhbnNhY3Rpb24gd2l0aCBwb3N0IGtleXBhaXIgYXMgYWRkaXRpb25hbCBzaWduZXJcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgY29ubmVjdGlvbiwge1xuICAgICAgICBza2lwUHJlZmxpZ2h0OiBmYWxzZSxcbiAgICAgICAgcHJlZmxpZ2h0Q29tbWl0bWVudDogJ3Byb2Nlc3NlZCcsXG4gICAgICAgIG1heFJldHJpZXM6IDMsXG4gICAgICAgIHNpZ25lcnM6IFtwb3N0S2V5cGFpcl0sIC8vIFBvc3Qga2V5cGFpciBtdXN0IHNpZ24gdGhlIHRyYW5zYWN0aW9uXG4gICAgICB9KVxuXG4gICAgICBjb25zb2xlLmxvZyhg8J+TiyBUcmFuc2FjdGlvbiBzaWduYXR1cmU6ICR7c2lnbmF0dXJlfWApXG4gICAgICBcbiAgICAgIGF3YWl0IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHtcbiAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICBibG9ja2hhc2gsXG4gICAgICAgIGxhc3RWYWxpZEJsb2NrSGVpZ2h0OiAoYXdhaXQgY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goKSkubGFzdFZhbGlkQmxvY2tIZWlnaHQsXG4gICAgICB9LCAncHJvY2Vzc2VkJylcblxuICAgICAgLy8gSW52YWxpZGF0ZSBjYWNoZSBhZnRlciBwb3N0IGNyZWF0aW9uIChwcm9maWxlIHBvc3QgY291bnQgY2hhbmdlZClcbiAgICAgIGNsZWFyUHJvZmlsZUNhY2hlKHB1YmxpY0tleS50b1N0cmluZygpKVxuICAgICAgcG9zdHNDYWNoZSA9IG51bGwgLy8gQWxzbyBjbGVhciBwb3N0cyBjYWNoZSB0byBzaG93IG5ldyBwb3N0IGltbWVkaWF0ZWx5XG5cbiAgICAgIGNvbnNvbGUubG9nKCfinIUgUG9zdCBjcmVhdGVkIHN1Y2Nlc3NmdWxseSEnKVxuICAgICAgdG9hc3Quc3VjY2VzcygnUG9zdCBjcmVhdGVkIHN1Y2Nlc3NmdWxseSEnKVxuICAgICAgcmV0dXJuIHNpZ25hdHVyZVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBQb3N0IGNyZWF0aW9uIGVycm9yOicsIGVycm9yKVxuICAgICAgXG4gICAgICBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ2luc3VmZmljaWVudCBmdW5kcycpKSB7XG4gICAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBjaGVja1NPTEJhbGFuY2UoKVxuICAgICAgICB0b2FzdC5lcnJvcihgSW5zdWZmaWNpZW50IFNPTDogJHtiYWxhbmNlLnRvRml4ZWQoNCl9IFNPTC4gTmVlZCBhdCBsZWFzdCAwLjA1IFNPTCBmb3IgZmVlcy5gKVxuICAgICAgfSBlbHNlIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnc2ltdWxhdGlvbiBmYWlsZWQnKSkge1xuICAgICAgICB0b2FzdC5lcnJvcignVHJhbnNhY3Rpb24gd291bGQgZmFpbDogQ2hlY2sgYWNjb3VudCBzZXR1cCBhbmQgYmFsYW5jZScpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1NpbXVsYXRpb24gZXJyb3IgZGV0YWlsczonLCBlcnJvci5tZXNzYWdlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9hc3QuZXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgcG9zdDogJHtlcnJvci5tZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJ31gKVxuICAgICAgfVxuICAgICAgXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8vIExpa2UgcG9zdCAtIFJFQUwgSU1QTEVNRU5UQVRJT04gLSBGaXhlZCB0byBmaW5kIGFjdHVhbCBwb3N0IGFjY291bnRzXG4gIGNvbnN0IGxpa2VQb3N0ID0gYXN5bmMgKHBvc3RJZDogbnVtYmVyLCBwb3N0QXV0aG9yOiBQdWJsaWNLZXkpID0+IHtcbiAgICBpZiAoIXB1YmxpY0tleSkgdGhyb3cgbmV3IEVycm9yKCdXYWxsZXQgbm90IGNvbm5lY3RlZCcpXG5cbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYPCflI0gQXR0ZW1wdGluZyB0byBsaWtlIHBvc3QgSUQgJHtwb3N0SWR9IGJ5IGF1dGhvciAke3Bvc3RBdXRob3IudG9TdHJpbmcoKS5zbGljZSgwLCA4KX0uLi5gKVxuICAgICAgXG4gICAgICAvLyBDaGVjayBTT0wgYmFsYW5jZSBmaXJzdFxuICAgICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IGNoZWNrU09MQmFsYW5jZSgpXG4gICAgICBjb25zb2xlLmxvZyhg8J+SsCBDdXJyZW50IFNPTCBiYWxhbmNlOiAke2JhbGFuY2V9YClcbiAgICAgIGlmIChiYWxhbmNlIDwgMC4wMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluc3VmZmljaWVudCBTT0wgYmFsYW5jZTogJHtiYWxhbmNlfS4gTmVlZCBhdCBsZWFzdCAwLjAxIFNPTCBmb3IgdHJhbnNhY3Rpb24gZmVlcy5gKVxuICAgICAgfVxuXG4gICAgICAvLyBGaW5kIHRoZSBhY3R1YWwgcG9zdCBhY2NvdW50IGFuZCBhdXRob3IncyBwcm9maWxlIGFjY291bnQgYnkgc2Nhbm5pbmcgYWxsIHByb2dyYW0gYWNjb3VudHNcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIFNlYXJjaGluZyBmb3IgcG9zdCBJRCAke3Bvc3RJZH0gYnkgYXV0aG9yICR7cG9zdEF1dGhvci50b1N0cmluZygpLnNsaWNlKDAsIDgpfS4uLmApXG4gICAgICBcbiAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgY29ubmVjdGlvbi5nZXRQcm9ncmFtQWNjb3VudHMoUFJPR1JBTV9JRClcbiAgICAgIGxldCBwb3N0QWNjb3VudEFkZHJlc3M6IFB1YmxpY0tleSB8IG51bGwgPSBudWxsXG4gICAgICBsZXQgcG9zdEFjY291bnQ6IFBvc3RBY2NvdW50IHwgbnVsbCA9IG51bGxcbiAgICAgIGxldCBhdXRob3JQcm9maWxlQWRkcmVzczogUHVibGljS2V5IHwgbnVsbCA9IG51bGxcbiAgICAgIFxuICAgICAgLy8gRmlyc3QgcGFzczogZmluZCB0aGUgcG9zdCBhY2NvdW50XG4gICAgICBmb3IgKGNvbnN0IHsgYWNjb3VudCwgcHVia2V5IH0gb2YgYWNjb3VudHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBwYXJzZWRQb3N0ID0gbWFudWFsUGFyc2VQb3N0KGFjY291bnQuZGF0YSlcbiAgICAgICAgICBpZiAocGFyc2VkUG9zdCAmJiBcbiAgICAgICAgICAgICAgcGFyc2VkUG9zdC5pc19pbml0aWFsaXplZCA9PT0gMSAmJiBcbiAgICAgICAgICAgICAgTnVtYmVyKHBhcnNlZFBvc3QuaWQpID09PSBwb3N0SWQgJiZcbiAgICAgICAgICAgICAgbmV3IFB1YmxpY0tleShwYXJzZWRQb3N0LmF1dGhvcikuZXF1YWxzKHBvc3RBdXRob3IpKSB7XG4gICAgICAgICAgICBwb3N0QWNjb3VudEFkZHJlc3MgPSBwdWJrZXlcbiAgICAgICAgICAgIHBvc3RBY2NvdW50ID0gcGFyc2VkUG9zdFxuICAgICAgICAgICAgY29uc29sZS5sb2coYPCfjq8gRm91bmQgcG9zdCBJRCAke3Bvc3RJZH0gYXQgYWRkcmVzczogJHtwdWJrZXkudG9TdHJpbmcoKX1gKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgLy8gTm90IGEgcG9zdCBhY2NvdW50LCBjb250aW51ZVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFwb3N0QWNjb3VudEFkZHJlc3MgfHwgIXBvc3RBY2NvdW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9zdCBJRCAke3Bvc3RJZH0gYnkgYXV0aG9yICR7cG9zdEF1dGhvci50b1N0cmluZygpLnNsaWNlKDAsIDgpfSBub3QgZm91bmQgb24gYmxvY2tjaGFpbmApXG4gICAgICB9XG5cbiAgICAgIC8vIFNlY29uZCBwYXNzOiBmaW5kIHRoZSBhdXRob3IncyBwcm9maWxlIGFjY291bnRcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIFNlYXJjaGluZyBmb3IgYXV0aG9yJ3MgcHJvZmlsZTogJHtwb3N0QXV0aG9yLnRvU3RyaW5nKCkuc2xpY2UoMCwgOCl9Li4uYClcbiAgICAgIGZvciAoY29uc3QgeyBhY2NvdW50LCBwdWJrZXkgfSBvZiBhY2NvdW50cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHBhcnNlZFByb2ZpbGUgPSBtYW51YWxQYXJzZVByb2ZpbGUoYWNjb3VudC5kYXRhKVxuICAgICAgICAgIGlmIChwYXJzZWRQcm9maWxlICYmIFxuICAgICAgICAgICAgICBwYXJzZWRQcm9maWxlLmlzX2luaXRpYWxpemVkID09PSAxICYmIFxuICAgICAgICAgICAgICBuZXcgUHVibGljS2V5KHBhcnNlZFByb2ZpbGUub3duZXIpLmVxdWFscyhwb3N0QXV0aG9yKSkge1xuICAgICAgICAgICAgYXV0aG9yUHJvZmlsZUFkZHJlc3MgPSBwdWJrZXlcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgRm91bmQgYXV0aG9yIHByb2ZpbGUgYWNjb3VudDogJHtwdWJrZXkudG9TdHJpbmcoKX1gKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgLy8gTm90IGEgcHJvZmlsZSBhY2NvdW50LCBjb250aW51ZVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFhdXRob3JQcm9maWxlQWRkcmVzcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF1dGhvcidzIHByb2ZpbGUgbm90IGZvdW5kIGZvciAke3Bvc3RBdXRob3IudG9TdHJpbmcoKS5zbGljZSgwLCA4KX1gKVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhg8J+TnSBQb3N0IGRhdGEgdmVyaWZpZWQ6IFwiJHtwb3N0QWNjb3VudC5jb250ZW50LnNsaWNlKDAsIDMwKX0uLi5cIiB3aXRoICR7TnVtYmVyKHBvc3RBY2NvdW50Lmxpa2VzKX0gbGlrZXNgKVxuXG4gICAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSBuZXcgTGlrZVBvc3RJbnN0cnVjdGlvbih7XG4gICAgICAgIHBvc3RfaWQ6IEJpZ0ludChwb3N0SWQpLFxuICAgICAgfSlcblxuICAgICAgY29uc3QgbGlrZVBvc3RWYXJpYW50ID0gQnVmZmVyLmZyb20oWzNdKSAvLyBMaWtlUG9zdCBpbnN0cnVjdGlvbiB2YXJpYW50XG4gICAgICBjb25zdCBzZXJpYWxpemVkRGF0YSA9IHNlcmlhbGl6ZShsaWtlUG9zdFNjaGVtYSwgaW5zdHJ1Y3Rpb25EYXRhKVxuICAgICAgY29uc3QgZnVsbEluc3RydWN0aW9uRGF0YSA9IEJ1ZmZlci5jb25jYXQoW2xpa2VQb3N0VmFyaWFudCwgQnVmZmVyLmZyb20oc2VyaWFsaXplZERhdGEpXSlcblxuICAgICAgY29uc29sZS5sb2coYPCflKIgSW5zdHJ1Y3Rpb24gZGF0YTogdmFyaWFudCBbM10sIHNlcmlhbGl6ZWQgbGVuZ3RoOiAke3NlcmlhbGl6ZWREYXRhLmxlbmd0aH0sIHRvdGFsOiAke2Z1bGxJbnN0cnVjdGlvbkRhdGEubGVuZ3RofSBieXRlc2ApXG5cbiAgICAgIGNvbnN0IGluc3RydWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICBrZXlzOiBbXG4gICAgICAgICAgeyBwdWJrZXk6IHB1YmxpY0tleSwgaXNTaWduZXI6IHRydWUsIGlzV3JpdGFibGU6IGZhbHNlIH0sIC8vIFVzZXIgYWNjb3VudCAobGlrZXIpXG4gICAgICAgICAgeyBwdWJrZXk6IHBvc3RBY2NvdW50QWRkcmVzcywgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiB0cnVlIH0sIC8vIFBvc3QgYWNjb3VudCAodG8gdXBkYXRlIGxpa2VzKVxuICAgICAgICAgIHsgcHVia2V5OiBhdXRob3JQcm9maWxlQWRkcmVzcywgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiB0cnVlIH0sIC8vIEF1dGhvciBwcm9maWxlIGFjY291bnQgKHRvIHVwZGF0ZSBVQ1IpXG4gICAgICAgIF0sXG4gICAgICAgIHByb2dyYW1JZDogUFJPR1JBTV9JRCxcbiAgICAgICAgZGF0YTogZnVsbEluc3RydWN0aW9uRGF0YSxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnNvbGUubG9nKCfwn5SRIFRyYW5zYWN0aW9uIGFjY291bnRzOicpXG4gICAgICBjb25zb2xlLmxvZyhgICBVc2VyIChsaWtlcik6ICR7cHVibGljS2V5LnRvU3RyaW5nKCl9IChzaWduZXIsIHJlYWRvbmx5KWApXG4gICAgICBjb25zb2xlLmxvZyhgICBQb3N0OiAke3Bvc3RBY2NvdW50QWRkcmVzcy50b1N0cmluZygpfSAobm90IHNpZ25lciwgd3JpdGFibGUpYClcbiAgICAgIGNvbnNvbGUubG9nKGAgIEF1dGhvciBQcm9maWxlOiAke2F1dGhvclByb2ZpbGVBZGRyZXNzLnRvU3RyaW5nKCl9IChub3Qgc2lnbmVyLCB3cml0YWJsZSlgKVxuICAgICAgY29uc29sZS5sb2coYCAgUHJvZ3JhbTogJHtQUk9HUkFNX0lELnRvU3RyaW5nKCl9YClcblxuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoaW5zdHJ1Y3Rpb24pXG4gICAgICBjb25zdCB7IGJsb2NraGFzaCB9ID0gYXdhaXQgY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goJ3Byb2Nlc3NlZCcpXG4gICAgICB0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBibG9ja2hhc2hcbiAgICAgIHRyYW5zYWN0aW9uLmZlZVBheWVyID0gcHVibGljS2V5XG5cbiAgICAgIC8vIFNpbXVsYXRlIHRyYW5zYWN0aW9uIGJlZm9yZSBzZW5kaW5nXG4gICAgICBjb25zb2xlLmxvZygn8J+OryBTaW11bGF0aW5nIHRyYW5zYWN0aW9uLi4uJylcbiAgICAgIGNvbnN0IHNpbXVsYXRpb24gPSBhd2FpdCBjb25uZWN0aW9uLnNpbXVsYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pXG4gICAgICBjb25zb2xlLmxvZygn8J+TiiBTaW11bGF0aW9uIHJlc3VsdDonLCBzaW11bGF0aW9uKVxuICAgICAgXG4gICAgICBpZiAoc2ltdWxhdGlvbi52YWx1ZS5lcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiBzaW11bGF0aW9uIGZhaWxlZDogJHtKU09OLnN0cmluZ2lmeShzaW11bGF0aW9uLnZhbHVlLmVycil9YClcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUubG9nKCfinIUgVHJhbnNhY3Rpb24gc2ltdWxhdGlvbiBzdWNjZXNzZnVsJylcblxuICAgICAgY29uc29sZS5sb2coJ/CfmoAgU2VuZGluZyB0cmFuc2FjdGlvbi4uLicpXG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIGNvbm5lY3Rpb24sIHtcbiAgICAgICAgc2tpcFByZWZsaWdodDogZmFsc2UsXG4gICAgICAgIHByZWZsaWdodENvbW1pdG1lbnQ6ICdwcm9jZXNzZWQnLFxuICAgICAgICBtYXhSZXRyaWVzOiAzLFxuICAgICAgfSlcblxuICAgICAgY29uc29sZS5sb2coYPCfk4sgVHJhbnNhY3Rpb24gc2VudCB3aXRoIHNpZ25hdHVyZTogJHtzaWduYXR1cmV9YClcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ+KPsyBDb25maXJtaW5nIHRyYW5zYWN0aW9uLi4uJylcbiAgICAgIGF3YWl0IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHtcbiAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICBibG9ja2hhc2gsXG4gICAgICAgIGxhc3RWYWxpZEJsb2NrSGVpZ2h0OiAoYXdhaXQgY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goKSkubGFzdFZhbGlkQmxvY2tIZWlnaHQsXG4gICAgICB9LCAncHJvY2Vzc2VkJylcblxuICAgICAgY29uc29sZS5sb2coJ+KchSBUcmFuc2FjdGlvbiBjb25maXJtZWQhIFBvc3QgbGlrZWQgc3VjY2Vzc2Z1bGx5IScpXG4gICAgICBcbiAgICAgIC8vIFRyYWNrIHVzZXIgbGlrZSBpbiBsb2NhbFN0b3JhZ2VcbiAgICAgIGlmIChwdWJsaWNLZXkpIHtcbiAgICAgICAgYWRkVXNlckxpa2UocHVibGljS2V5LnRvU3RyaW5nKCksIHBvc3RJZClcbiAgICAgICAgY29uc29sZS5sb2coYPCfk50gVHJhY2tlZCBsaWtlIGZvciB1c2VyICR7cHVibGljS2V5LnRvU3RyaW5nKCkuc2xpY2UoMCwgOCl9IG9uIHBvc3QgJHtwb3N0SWR9YClcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2xlYXIgcG9zdHMgY2FjaGUgdG8gZm9yY2UgcmVmcmVzaFxuICAgICAgcG9zdHNDYWNoZSA9IG51bGxcbiAgICAgIFxuICAgICAgdG9hc3Quc3VjY2VzcygnUG9zdCBsaWtlZCEnKVxuICAgICAgcmV0dXJuIHNpZ25hdHVyZVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBMaWtlIHBvc3QgZXJyb3I6JywgZXJyb3IpXG4gICAgICBcbiAgICAgIC8vIE1vcmUgc3BlY2lmaWMgZXJyb3IgbWVzc2FnZXNcbiAgICAgIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnaW5zdWZmaWNpZW50IGZ1bmRzJykpIHtcbiAgICAgICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IGNoZWNrU09MQmFsYW5jZSgpXG4gICAgICAgIHRvYXN0LmVycm9yKGBJbnN1ZmZpY2llbnQgU09MOiAke2JhbGFuY2UudG9GaXhlZCg0KX0gU09MLiBOZWVkIGF0IGxlYXN0IDAuMDEgU09MIGZvciBmZWVzLmApXG4gICAgICB9IGVsc2UgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdzaW11bGF0aW9uIGZhaWxlZCcpKSB7XG4gICAgICAgIHRvYXN0LmVycm9yKCdUcmFuc2FjdGlvbiB3b3VsZCBmYWlsOiBDaGVjayBwb3N0IGV4aXN0cyBhbmQgd2FsbGV0IGhhcyBwZXJtaXNzaW9uJylcbiAgICAgICAgY29uc29sZS5lcnJvcignU2ltdWxhdGlvbiBlcnJvciBkZXRhaWxzOicsIGVycm9yLm1lc3NhZ2UpXG4gICAgICB9IGVsc2UgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdub3QgZm91bmQgb24gYmxvY2tjaGFpbicpKSB7XG4gICAgICAgIHRvYXN0LmVycm9yKCdQb3N0IG5vdCBmb3VuZCBvbiBibG9ja2NoYWluJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvYXN0LmVycm9yKGBGYWlsZWQgdG8gbGlrZSBwb3N0OiAke2Vycm9yLm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InfWApXG4gICAgICB9XG4gICAgICBcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLy8gVW5saWtlIHBvc3QgLSBSRUFMIElNUExFTUVOVEFUSU9OXG4gIGNvbnN0IHVubGlrZVBvc3QgPSBhc3luYyAocG9zdElkOiBudW1iZXIsIHBvc3RBdXRob3I6IFB1YmxpY0tleSkgPT4ge1xuICAgIGlmICghcHVibGljS2V5KSB0aHJvdyBuZXcgRXJyb3IoJ1dhbGxldCBub3QgY29ubmVjdGVkJylcblxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+RjiBBdHRlbXB0aW5nIHRvIHVubGlrZSBwb3N0IElEICR7cG9zdElkfSBieSBhdXRob3IgJHtwb3N0QXV0aG9yLnRvU3RyaW5nKCkuc2xpY2UoMCwgOCl9Li4uYClcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgU09MIGJhbGFuY2UgZmlyc3RcbiAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBjaGVja1NPTEJhbGFuY2UoKVxuICAgICAgY29uc29sZS5sb2coYPCfkrAgQ3VycmVudCBTT0wgYmFsYW5jZTogJHtiYWxhbmNlfWApXG4gICAgICBpZiAoYmFsYW5jZSA8IDAuMDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN1ZmZpY2llbnQgU09MIGJhbGFuY2U6ICR7YmFsYW5jZX0uIE5lZWQgYXQgbGVhc3QgMC4wMSBTT0wgZm9yIHRyYW5zYWN0aW9uIGZlZXMuYClcbiAgICAgIH1cblxuICAgICAgLy8gRmluZCB0aGUgYWN0dWFsIHBvc3QgYWNjb3VudCBhbmQgYXV0aG9yJ3MgcHJvZmlsZSBhY2NvdW50IGJ5IHNjYW5uaW5nIGFsbCBwcm9ncmFtIGFjY291bnRzXG4gICAgICBjb25zb2xlLmxvZyhg8J+UjSBTZWFyY2hpbmcgZm9yIHBvc3QgSUQgJHtwb3N0SWR9IGJ5IGF1dGhvciAke3Bvc3RBdXRob3IudG9TdHJpbmcoKS5zbGljZSgwLCA4KX0uLi5gKVxuICAgICAgXG4gICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0UHJvZ3JhbUFjY291bnRzKFBST0dSQU1fSUQpXG4gICAgICBsZXQgcG9zdEFjY291bnRBZGRyZXNzOiBQdWJsaWNLZXkgfCBudWxsID0gbnVsbFxuICAgICAgbGV0IHBvc3RBY2NvdW50OiBQb3N0QWNjb3VudCB8IG51bGwgPSBudWxsXG4gICAgICBsZXQgYXV0aG9yUHJvZmlsZUFkZHJlc3M6IFB1YmxpY0tleSB8IG51bGwgPSBudWxsXG4gICAgICBcbiAgICAgIC8vIEZpcnN0IHBhc3M6IGZpbmQgdGhlIHBvc3QgYWNjb3VudFxuICAgICAgZm9yIChjb25zdCB7IGFjY291bnQsIHB1YmtleSB9IG9mIGFjY291bnRzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gU2tpcCBjb21tZW50IGFjY291bnRzXG4gICAgICAgICAgaWYgKGlzQ29tbWVudEFjY291bnQocHVia2V5LnRvU3RyaW5nKCkpKSBjb250aW51ZVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHBhcnNlZFBvc3QgPSBtYW51YWxQYXJzZVBvc3QoYWNjb3VudC5kYXRhKVxuICAgICAgICAgIGlmIChwYXJzZWRQb3N0ICYmIFxuICAgICAgICAgICAgICBwYXJzZWRQb3N0LmlzX2luaXRpYWxpemVkID09PSAxICYmIFxuICAgICAgICAgICAgICBOdW1iZXIocGFyc2VkUG9zdC5pZCkgPT09IHBvc3RJZCAmJlxuICAgICAgICAgICAgICBuZXcgUHVibGljS2V5KHBhcnNlZFBvc3QuYXV0aG9yKS5lcXVhbHMocG9zdEF1dGhvcikpIHtcbiAgICAgICAgICAgIHBvc3RBY2NvdW50QWRkcmVzcyA9IHB1YmtleVxuICAgICAgICAgICAgcG9zdEFjY291bnQgPSBwYXJzZWRQb3N0XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+OryBGb3VuZCBwb3N0IElEICR7cG9zdElkfSBhdCBhZGRyZXNzOiAke3B1YmtleS50b1N0cmluZygpfWApXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghcG9zdEFjY291bnRBZGRyZXNzIHx8ICFwb3N0QWNjb3VudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc3QgSUQgJHtwb3N0SWR9IGJ5IGF1dGhvciAke3Bvc3RBdXRob3IudG9TdHJpbmcoKS5zbGljZSgwLCA4KX0gbm90IGZvdW5kIG9uIGJsb2NrY2hhaW5gKVxuICAgICAgfVxuXG4gICAgICAvLyBTZWNvbmQgcGFzczogZmluZCB0aGUgYXV0aG9yJ3MgcHJvZmlsZSBhY2NvdW50XG4gICAgICBjb25zb2xlLmxvZyhg8J+UjSBTZWFyY2hpbmcgZm9yIGF1dGhvcidzIHByb2ZpbGU6ICR7cG9zdEF1dGhvci50b1N0cmluZygpLnNsaWNlKDAsIDgpfS4uLmApXG4gICAgICBmb3IgKGNvbnN0IHsgYWNjb3VudCwgcHVia2V5IH0gb2YgYWNjb3VudHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBwYXJzZWRQcm9maWxlID0gbWFudWFsUGFyc2VQcm9maWxlKGFjY291bnQuZGF0YSlcbiAgICAgICAgICBpZiAocGFyc2VkUHJvZmlsZSAmJiBcbiAgICAgICAgICAgICAgcGFyc2VkUHJvZmlsZS5pc19pbml0aWFsaXplZCA9PT0gMSAmJiBcbiAgICAgICAgICAgICAgbmV3IFB1YmxpY0tleShwYXJzZWRQcm9maWxlLm93bmVyKS5lcXVhbHMocG9zdEF1dGhvcikpIHtcbiAgICAgICAgICAgIGF1dGhvclByb2ZpbGVBZGRyZXNzID0gcHVia2V5XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEZvdW5kIGF1dGhvciBwcm9maWxlIGFjY291bnQ6ICR7cHVia2V5LnRvU3RyaW5nKCl9YClcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFhdXRob3JQcm9maWxlQWRkcmVzcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF1dGhvcidzIHByb2ZpbGUgbm90IGZvdW5kIGZvciAke3Bvc3RBdXRob3IudG9TdHJpbmcoKS5zbGljZSgwLCA4KX1gKVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhg8J+TnSBQb3N0IGRhdGEgdmVyaWZpZWQ6IFwiJHtwb3N0QWNjb3VudC5jb250ZW50LnNsaWNlKDAsIDMwKX0uLi5cIiB3aXRoICR7TnVtYmVyKHBvc3RBY2NvdW50Lmxpa2VzKX0gbGlrZXNgKVxuXG4gICAgICAvLyBGb3IgdW5saWtlLCB3ZSdsbCB1c2UgdGhlIHNhbWUgaW5zdHJ1Y3Rpb24gYXMgbGlrZSAodGhlIHNtYXJ0IGNvbnRyYWN0IHNob3VsZCBoYW5kbGUgdGhlIHRvZ2dsZSlcbiAgICAgIGNvbnN0IGluc3RydWN0aW9uRGF0YSA9IG5ldyBMaWtlUG9zdEluc3RydWN0aW9uKHtcbiAgICAgICAgcG9zdF9pZDogQmlnSW50KHBvc3RJZCksXG4gICAgICB9KVxuXG4gICAgICBjb25zdCBsaWtlUG9zdFZhcmlhbnQgPSBCdWZmZXIuZnJvbShbM10pIC8vIExpa2VQb3N0IGluc3RydWN0aW9uIHZhcmlhbnQgKHNhbWUgZm9yIHVubGlrZSlcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWREYXRhID0gc2VyaWFsaXplKGxpa2VQb3N0U2NoZW1hLCBpbnN0cnVjdGlvbkRhdGEpXG4gICAgICBjb25zdCBmdWxsSW5zdHJ1Y3Rpb25EYXRhID0gQnVmZmVyLmNvbmNhdChbbGlrZVBvc3RWYXJpYW50LCBCdWZmZXIuZnJvbShzZXJpYWxpemVkRGF0YSldKVxuXG4gICAgICBjb25zdCBpbnN0cnVjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgICAga2V5czogW1xuICAgICAgICAgIHsgcHVia2V5OiBwdWJsaWNLZXksIGlzU2lnbmVyOiB0cnVlLCBpc1dyaXRhYmxlOiBmYWxzZSB9LCAvLyBVc2VyIGFjY291bnQgKHVubGlrZXIpXG4gICAgICAgICAgeyBwdWJrZXk6IHBvc3RBY2NvdW50QWRkcmVzcywgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiB0cnVlIH0sIC8vIFBvc3QgYWNjb3VudCAodG8gdXBkYXRlIGxpa2VzKVxuICAgICAgICAgIHsgcHVia2V5OiBhdXRob3JQcm9maWxlQWRkcmVzcywgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiB0cnVlIH0sIC8vIEF1dGhvciBwcm9maWxlIGFjY291bnQgKHRvIHVwZGF0ZSBVQ1IpXG4gICAgICAgIF0sXG4gICAgICAgIHByb2dyYW1JZDogUFJPR1JBTV9JRCxcbiAgICAgICAgZGF0YTogZnVsbEluc3RydWN0aW9uRGF0YSxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKGluc3RydWN0aW9uKVxuICAgICAgY29uc3QgeyBibG9ja2hhc2ggfSA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2toYXNoKCdwcm9jZXNzZWQnKVxuICAgICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoXG4gICAgICB0cmFuc2FjdGlvbi5mZWVQYXllciA9IHB1YmxpY0tleVxuXG4gICAgICBjb25zb2xlLmxvZygn8J+agCBTZW5kaW5nIHVubGlrZSB0cmFuc2FjdGlvbi4uLicpXG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIGNvbm5lY3Rpb24sIHtcbiAgICAgICAgc2tpcFByZWZsaWdodDogZmFsc2UsXG4gICAgICAgIHByZWZsaWdodENvbW1pdG1lbnQ6ICdwcm9jZXNzZWQnLFxuICAgICAgICBtYXhSZXRyaWVzOiAzLFxuICAgICAgfSlcblxuICAgICAgYXdhaXQgY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oe1xuICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgIGJsb2NraGFzaCxcbiAgICAgICAgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IChhd2FpdCBjb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCgpKS5sYXN0VmFsaWRCbG9ja0hlaWdodCxcbiAgICAgIH0sICdwcm9jZXNzZWQnKVxuXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFRyYW5zYWN0aW9uIGNvbmZpcm1lZCEgUG9zdCB1bmxpa2VkIHN1Y2Nlc3NmdWxseSEnKVxuICAgICAgXG4gICAgICAvLyBSZW1vdmUgdXNlciBsaWtlIGZyb20gbG9jYWxTdG9yYWdlXG4gICAgICBpZiAocHVibGljS2V5KSB7XG4gICAgICAgIHJlbW92ZVVzZXJMaWtlKHB1YmxpY0tleS50b1N0cmluZygpLCBwb3N0SWQpXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5OdIFJlbW92ZWQgbGlrZSBmb3IgdXNlciAke3B1YmxpY0tleS50b1N0cmluZygpLnNsaWNlKDAsIDgpfSBvbiBwb3N0ICR7cG9zdElkfWApXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENsZWFyIHBvc3RzIGNhY2hlIHRvIGZvcmNlIHJlZnJlc2hcbiAgICAgIHBvc3RzQ2FjaGUgPSBudWxsXG4gICAgICBcbiAgICAgIHJldHVybiBzaWduYXR1cmVcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgVW5saWtlIHBvc3QgZXJyb3I6JywgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8vIENoZWNrIHNwZWNpZmljIHByb2ZpbGUgUERBIC0gZm9yIGRlYnVnZ2luZyBwcm9maWxlIGRldGVjdGlvbiBpc3N1ZXNcbiAgY29uc3QgY2hlY2tQcm9maWxlQXRQREEgPSBhc3luYyAocGRhQWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIENoZWNraW5nIHNwZWNpZmljIFBEQTogJHtwZGFBZGRyZXNzfWApXG4gICAgICBjb25zdCBwZGEgPSBuZXcgUHVibGljS2V5KHBkYUFkZHJlc3MpXG4gICAgICBjb25zdCBhY2NvdW50SW5mbyA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0QWNjb3VudEluZm8ocGRhKVxuICAgICAgXG4gICAgICBpZiAoIWFjY291bnRJbmZvKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDinYwgTm8gYWNjb3VudCBmb3VuZCBhdCBQREE6ICR7cGRhQWRkcmVzc31gKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYOKchSBBY2NvdW50IGV4aXN0cyEgT3duZXI6ICR7YWNjb3VudEluZm8ub3duZXIudG9TdHJpbmcoKX0sIFNpemU6ICR7YWNjb3VudEluZm8uZGF0YS5sZW5ndGh9IGJ5dGVzYClcbiAgICAgIFxuICAgICAgLy8gSW5zcGVjdCByYXcgZGF0YVxuICAgICAgY29uc29sZS5sb2coYPCflI0gUmF3IGRhdGEgKGZpcnN0IDEwMCBieXRlcyk6YCwgQXJyYXkuZnJvbShhY2NvdW50SW5mby5kYXRhLnNsaWNlKDAsIDEwMCkpKVxuICAgICAgXG4gICAgICBpZiAoYWNjb3VudEluZm8ub3duZXIuZXF1YWxzKFBST0dSQU1fSUQpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDinIUgQWNjb3VudCBpcyBvd25lZCBieSBvdXIgcHJvZ3JhbWApXG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRyeSBtYW51YWwgcGFyc2luZyB0byB1bmRlcnN0YW5kIHRoZSBzdHJ1Y3R1cmVcbiAgICAgICAgICBsZXQgb2Zmc2V0ID0gMFxuICAgICAgICAgIGNvbnN0IGlzX2luaXRpYWxpemVkID0gYWNjb3VudEluZm8uZGF0YVtvZmZzZXRdXG4gICAgICAgICAgb2Zmc2V0ICs9IDFcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TiiBpc19pbml0aWFsaXplZDogJHtpc19pbml0aWFsaXplZH1gKVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IG93bmVyID0gYWNjb3VudEluZm8uZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIDMyKVxuICAgICAgICAgIG9mZnNldCArPSAzMlxuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OKIG93bmVyOiAke25ldyBQdWJsaWNLZXkob3duZXIpLnRvU3RyaW5nKCl9YClcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBUcnkgdG8gcmVhZCB0aGUgdXNlcm5hbWUgbGVuZ3RoIChCb3JzaCBzdHJpbmcgZm9ybWF0OiA0IGJ5dGVzIGxlbmd0aCArIHN0cmluZylcbiAgICAgICAgICBjb25zdCB1c2VybmFtZUxlbmd0aCA9IGFjY291bnRJbmZvLmRhdGEucmVhZFVJbnQzMkxFKG9mZnNldClcbiAgICAgICAgICBvZmZzZXQgKz0gNFxuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OKIHVzZXJuYW1lIGxlbmd0aDogJHt1c2VybmFtZUxlbmd0aH1gKVxuICAgICAgICAgIFxuICAgICAgICAgIGlmICh1c2VybmFtZUxlbmd0aCA+IDAgJiYgdXNlcm5hbWVMZW5ndGggPCAxMDApIHtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJuYW1lID0gYWNjb3VudEluZm8uZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIHVzZXJuYW1lTGVuZ3RoKS50b1N0cmluZygndXRmOCcpXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TiiB1c2VybmFtZTogXCIke3VzZXJuYW1lfVwiYClcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTm93IHRyeSBtYW51YWwgcGFyc2luZ1xuICAgICAgICAgIGNvbnN0IHByb2ZpbGVBY2NvdW50ID0gbWFudWFsUGFyc2VQcm9maWxlKGFjY291bnRJbmZvLmRhdGEpXG4gICAgICAgICAgaWYgKHByb2ZpbGVBY2NvdW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIFN1Y2Nlc3NmdWxseSBtYW51YWxseSBwYXJzZWQgcHJvZmlsZTpgLCB7XG4gICAgICAgICAgICAgIHVzZXJuYW1lOiBwcm9maWxlQWNjb3VudC51c2VybmFtZSxcbiAgICAgICAgICAgICAgYmlvOiBwcm9maWxlQWNjb3VudC5iaW8sXG4gICAgICAgICAgICAgIGlzSW5pdGlhbGl6ZWQ6IHByb2ZpbGVBY2NvdW50LmlzX2luaXRpYWxpemVkID09PSAxLFxuICAgICAgICAgICAgICBvd25lcjogbmV3IFB1YmxpY0tleShwcm9maWxlQWNjb3VudC5vd25lcikudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgcHJvZmlsZUltYWdlOiBwcm9maWxlQWNjb3VudC5wcm9maWxlX2ltYWdlLFxuICAgICAgICAgICAgICBjb3ZlckltYWdlOiBwcm9maWxlQWNjb3VudC5jb3Zlcl9pbWFnZSxcbiAgICAgICAgICAgICAgcG9zdHNDb3VudDogTnVtYmVyKHByb2ZpbGVBY2NvdW50LnBvc3RzX2NvdW50KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYOKdjCBNYW51YWwgcGFyc2luZyBmYWlsZWRgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBBbHNvIHRyeSBCb3JzaCBmb3IgY29tcGFyaXNvblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwcm9maWxlQWNjb3VudCA9IGRlc2VyaWFsaXplKHByb2ZpbGVBY2NvdW50U2NoZW1hLCBQcm9maWxlQWNjb3VudCwgYWNjb3VudEluZm8uZGF0YSkgYXMgUHJvZmlsZUFjY291bnRcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgQm9yc2ggZGVzZXJpYWxpemF0aW9uIGFsc28gd29ya2VkOmAsIHtcbiAgICAgICAgICAgICAgdXNlcm5hbWU6IHByb2ZpbGVBY2NvdW50LnVzZXJuYW1lLFxuICAgICAgICAgICAgICBiaW86IHByb2ZpbGVBY2NvdW50LmJpbyxcbiAgICAgICAgICAgICAgaXNJbml0aWFsaXplZDogcHJvZmlsZUFjY291bnQuaXNfaW5pdGlhbGl6ZWQgPT09IDEsXG4gICAgICAgICAgICAgIG93bmVyOiBuZXcgUHVibGljS2V5KHByb2ZpbGVBY2NvdW50Lm93bmVyKS50b1N0cmluZygpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4p2MIEJvcnNoIGRlc2VyaWFsaXphdGlvbiBzdGlsbCBmYWlsczpgLCBlcnJvcilcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKdjCBFcnJvciBjaGVja2luZyBQREE6YCwgZXJyb3IpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDinYwgQWNjb3VudCBpcyBvd25lZCBieSBkaWZmZXJlbnQgcHJvZ3JhbTogJHthY2NvdW50SW5mby5vd25lci50b1N0cmluZygpfWApXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUubG9nKGDinYwgRXJyb3IgY2hlY2tpbmcgUERBOmAsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8vIE1hbnVhbCBwcm9maWxlIHBhcnNlciAtIGJ5cGFzc2VzIEJvcnNoIGRlc2VyaWFsaXphdGlvbiBpc3N1ZXNcbiAgY29uc3QgbWFudWFsUGFyc2VQcm9maWxlID0gKGRhdGE6IEJ1ZmZlcik6IFByb2ZpbGVBY2NvdW50IHwgbnVsbCA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEJhc2ljIHZhbGlkYXRpb24gLSBwcm9maWxlcyBzaG91bGQgaGF2ZSBhIG1pbmltdW0gc2l6ZVxuICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgMTUwKSByZXR1cm4gbnVsbCAvLyBQcm9maWxlcyBuZWVkIGF0IGxlYXN0IDE1MCBieXRlcyBmb3IgYmFzaWMgc3RydWN0dXJlXG4gICAgICBcbiAgICAgIGxldCBvZmZzZXQgPSAwXG4gICAgICBcbiAgICAgIC8vIFBhcnNlIGVhY2ggZmllbGQgbWFudWFsbHlcbiAgICAgIGNvbnN0IGlzX2luaXRpYWxpemVkID0gZGF0YVtvZmZzZXRdXG4gICAgICBpZiAoaXNfaW5pdGlhbGl6ZWQgIT09IDEpIHJldHVybiBudWxsIC8vIE11c3QgYmUgaW5pdGlhbGl6ZWRcbiAgICAgIG9mZnNldCArPSAxXG4gICAgICBcbiAgICAgIGNvbnN0IG93bmVyID0gZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIDMyKVxuICAgICAgb2Zmc2V0ICs9IDMyXG4gICAgICBcbiAgICAgIC8vIFZhbGlkYXRlIHdlIGhhdmUgZW5vdWdoIGRhdGEgZm9yIHVzZXJuYW1lIGxlbmd0aFxuICAgICAgaWYgKG9mZnNldCArIDQgPiBkYXRhLmxlbmd0aCkgcmV0dXJuIG51bGxcbiAgICAgIFxuICAgICAgLy8gU3RyaW5nIGZpZWxkcyAodXNlcm5hbWUsIGJpbywgcHJvZmlsZV9pbWFnZSwgY292ZXJfaW1hZ2UpXG4gICAgICBjb25zdCB1c2VybmFtZUxlbmd0aCA9IGRhdGEucmVhZFVJbnQzMkxFKG9mZnNldClcbiAgICAgIG9mZnNldCArPSA0XG4gICAgICBcbiAgICAgIC8vIFZhbGlkYXRlIHVzZXJuYW1lIGxlbmd0aCBpcyByZWFzb25hYmxlXG4gICAgICBpZiAodXNlcm5hbWVMZW5ndGggPiAxMDAgfHwgdXNlcm5hbWVMZW5ndGggPT09IDApIHJldHVybiBudWxsXG4gICAgICBpZiAob2Zmc2V0ICsgdXNlcm5hbWVMZW5ndGggPiBkYXRhLmxlbmd0aCkgcmV0dXJuIG51bGxcbiAgICAgIFxuICAgICAgY29uc3QgdXNlcm5hbWUgPSBkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgdXNlcm5hbWVMZW5ndGgpLnRvU3RyaW5nKCd1dGY4JylcbiAgICAgIG9mZnNldCArPSB1c2VybmFtZUxlbmd0aFxuICAgICAgXG4gICAgICAvLyBWYWxpZGF0ZSB3ZSBoYXZlIGVub3VnaCBkYXRhIGZvciBiaW8gbGVuZ3RoXG4gICAgICBpZiAob2Zmc2V0ICsgNCA+IGRhdGEubGVuZ3RoKSByZXR1cm4gbnVsbFxuICAgICAgXG4gICAgICBjb25zdCBiaW9MZW5ndGggPSBkYXRhLnJlYWRVSW50MzJMRShvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gNFxuICAgICAgXG4gICAgICAvLyBWYWxpZGF0ZSBiaW8gbGVuZ3RoIGlzIHJlYXNvbmFibGVcbiAgICAgIGlmIChiaW9MZW5ndGggPiAxMDAwKSByZXR1cm4gbnVsbFxuICAgICAgaWYgKG9mZnNldCArIGJpb0xlbmd0aCA+IGRhdGEubGVuZ3RoKSByZXR1cm4gbnVsbFxuICAgICAgXG4gICAgICBjb25zdCBiaW8gPSBkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYmlvTGVuZ3RoKS50b1N0cmluZygndXRmOCcpXG4gICAgICBvZmZzZXQgKz0gYmlvTGVuZ3RoXG4gICAgICBcbiAgICAgIC8vIFZhbGlkYXRlIHdlIGhhdmUgZW5vdWdoIGRhdGEgZm9yIHByb2ZpbGUgaW1hZ2UgbGVuZ3RoXG4gICAgICBpZiAob2Zmc2V0ICsgNCA+IGRhdGEubGVuZ3RoKSByZXR1cm4gbnVsbFxuICAgICAgXG4gICAgICBjb25zdCBwcm9maWxlSW1hZ2VMZW5ndGggPSBkYXRhLnJlYWRVSW50MzJMRShvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gNFxuICAgICAgXG4gICAgICAvLyBWYWxpZGF0ZSBwcm9maWxlIGltYWdlIGxlbmd0aCBpcyByZWFzb25hYmxlXG4gICAgICBpZiAocHJvZmlsZUltYWdlTGVuZ3RoID4gNTAwKSByZXR1cm4gbnVsbFxuICAgICAgaWYgKG9mZnNldCArIHByb2ZpbGVJbWFnZUxlbmd0aCA+IGRhdGEubGVuZ3RoKSByZXR1cm4gbnVsbFxuICAgICAgXG4gICAgICBjb25zdCBwcm9maWxlX2ltYWdlID0gZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIHByb2ZpbGVJbWFnZUxlbmd0aCkudG9TdHJpbmcoJ3V0ZjgnKVxuICAgICAgb2Zmc2V0ICs9IHByb2ZpbGVJbWFnZUxlbmd0aFxuICAgICAgXG4gICAgICAvLyBWYWxpZGF0ZSB3ZSBoYXZlIGVub3VnaCBkYXRhIGZvciBjb3ZlciBpbWFnZSBsZW5ndGhcbiAgICAgIGlmIChvZmZzZXQgKyA0ID4gZGF0YS5sZW5ndGgpIHJldHVybiBudWxsXG4gICAgICBcbiAgICAgIGNvbnN0IGNvdmVySW1hZ2VMZW5ndGggPSBkYXRhLnJlYWRVSW50MzJMRShvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gNFxuICAgICAgXG4gICAgICAvLyBWYWxpZGF0ZSBjb3ZlciBpbWFnZSBsZW5ndGggaXMgcmVhc29uYWJsZVxuICAgICAgaWYgKGNvdmVySW1hZ2VMZW5ndGggPiA1MDApIHJldHVybiBudWxsXG4gICAgICBpZiAob2Zmc2V0ICsgY292ZXJJbWFnZUxlbmd0aCA+IGRhdGEubGVuZ3RoKSByZXR1cm4gbnVsbFxuICAgICAgXG4gICAgICBjb25zdCBjb3Zlcl9pbWFnZSA9IGRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBjb3ZlckltYWdlTGVuZ3RoKS50b1N0cmluZygndXRmOCcpXG4gICAgICBvZmZzZXQgKz0gY292ZXJJbWFnZUxlbmd0aFxuICAgICAgXG4gICAgICAvLyBWYWxpZGF0ZSB3ZSBoYXZlIGVub3VnaCBkYXRhIGZvciBhbGwgdGhlIHU2NCBmaWVsZHMgKDggYnl0ZXMgZWFjaCAqIDYgZmllbGRzID0gNDggYnl0ZXMpXG4gICAgICBpZiAob2Zmc2V0ICsgNDggPiBkYXRhLmxlbmd0aCkgcmV0dXJuIG51bGxcbiAgICAgIFxuICAgICAgLy8gdTY0IGZpZWxkc1xuICAgICAgY29uc3QgY3JlYXRlZF9hdCA9IGRhdGEucmVhZEJpZ1VJbnQ2NExFKG9mZnNldClcbiAgICAgIG9mZnNldCArPSA4XG4gICAgICBcbiAgICAgIGNvbnN0IGZvbGxvd2Vyc19jb3VudCA9IGRhdGEucmVhZEJpZ1VJbnQ2NExFKG9mZnNldClcbiAgICAgIG9mZnNldCArPSA4XG4gICAgICBcbiAgICAgIGNvbnN0IGZvbGxvd2luZ19jb3VudCA9IGRhdGEucmVhZEJpZ1VJbnQ2NExFKG9mZnNldClcbiAgICAgIG9mZnNldCArPSA4XG4gICAgICBcbiAgICAgIC8vIGk2NCBmaWVsZFxuICAgICAgY29uc3QgdXNlcl9jcmVkaXRfcmF0aW5nID0gZGF0YS5yZWFkQmlnSW50NjRMRShvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gOFxuICAgICAgXG4gICAgICBjb25zdCBwb3N0c19jb3VudCA9IGRhdGEucmVhZEJpZ1VJbnQ2NExFKG9mZnNldClcbiAgICAgIG9mZnNldCArPSA4XG4gICAgICBcbiAgICAgIGNvbnN0IGxhc3RfcG9zdF90aW1lc3RhbXAgPSBkYXRhLnJlYWRCaWdVSW50NjRMRShvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gOFxuICAgICAgXG4gICAgICBjb25zdCBkYWlseV9wb3N0X2NvdW50ID0gZGF0YS5yZWFkQmlnVUludDY0TEUob2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IDhcbiAgICAgIFxuICAgICAgLy8gVmFsaWRhdGUgd2UgaGF2ZSBlbm91Z2ggZGF0YSBmb3IgdGhlIGZpbmFsIHU4IGZpZWxkXG4gICAgICBpZiAob2Zmc2V0ICsgMSA+IGRhdGEubGVuZ3RoKSByZXR1cm4gbnVsbFxuICAgICAgXG4gICAgICBjb25zdCBpc192ZXJpZmllZCA9IGRhdGFbb2Zmc2V0XVxuICAgICAgb2Zmc2V0ICs9IDFcbiAgICAgIFxuICAgICAgcmV0dXJuIG5ldyBQcm9maWxlQWNjb3VudCh7XG4gICAgICAgIGlzX2luaXRpYWxpemVkLFxuICAgICAgICBvd25lcjogbmV3IFVpbnQ4QXJyYXkob3duZXIpLFxuICAgICAgICB1c2VybmFtZSxcbiAgICAgICAgYmlvLFxuICAgICAgICBwcm9maWxlX2ltYWdlLFxuICAgICAgICBjb3Zlcl9pbWFnZSxcbiAgICAgICAgY3JlYXRlZF9hdCxcbiAgICAgICAgZm9sbG93ZXJzX2NvdW50LFxuICAgICAgICBmb2xsb3dpbmdfY291bnQsXG4gICAgICAgIHVzZXJfY3JlZGl0X3JhdGluZyxcbiAgICAgICAgcG9zdHNfY291bnQsXG4gICAgICAgIGxhc3RfcG9zdF90aW1lc3RhbXAsXG4gICAgICAgIGRhaWx5X3Bvc3RfY291bnQsXG4gICAgICAgIGlzX3ZlcmlmaWVkXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBTaWxlbnQgZmFpbHVyZSAtIG5vdCBhIHByb2ZpbGUgYWNjb3VudCBvciBpbnZhbGlkIGRhdGFcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgLy8gTWFudWFsIHBvc3QgcGFyc2VyIC0gYnlwYXNzZXMgQm9yc2ggZGVzZXJpYWxpemF0aW9uIGlzc3Vlc1xuICBjb25zdCBtYW51YWxQYXJzZVBvc3QgPSAoZGF0YTogQnVmZmVyKTogUG9zdEFjY291bnQgfCBudWxsID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gUXVpY2sgdmFsaWRhdGlvbjogcG9zdHMgc2hvdWxkIGhhdmUgc3BlY2lmaWMgc2l6ZSBhbmQgc3RydWN0dXJlXG4gICAgICBpZiAoZGF0YS5sZW5ndGggPCAxMDApIHJldHVybiBudWxsIC8vIFBvc3RzIHNob3VsZCBiZSBsYXJnZXIgdGhhbiBwcm9maWxlc1xuICAgICAgXG4gICAgICBsZXQgb2Zmc2V0ID0gMFxuICAgICAgXG4gICAgICAvLyBQYXJzZSBlYWNoIGZpZWxkIG1hbnVhbGx5XG4gICAgICBjb25zdCBpc19pbml0aWFsaXplZCA9IGRhdGFbb2Zmc2V0XVxuICAgICAgaWYgKGlzX2luaXRpYWxpemVkICE9PSAxKSByZXR1cm4gbnVsbCAvLyBNdXN0IGJlIGluaXRpYWxpemVkXG4gICAgICBvZmZzZXQgKz0gMVxuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGxvb2tzIGxpa2UgYSBwb3N0IHZzIHByb2ZpbGUgYnkgZXhhbWluaW5nIHRoZSBzdHJ1Y3R1cmVcbiAgICAgIC8vIFBvc3RzIHN0YXJ0IHdpdGg6IHU4IChpbml0KSwgdTY0IChpZCksIFszMl11OCAoYXV0aG9yKSwgc3RyaW5nIChjb250ZW50KVxuICAgICAgLy8gUHJvZmlsZXMgc3RhcnQgd2l0aDogdTggKGluaXQpLCBbMzJddTggKG93bmVyKSwgc3RyaW5nICh1c2VybmFtZSlcbiAgICAgIFxuICAgICAgY29uc3QgaWQgPSBkYXRhLnJlYWRCaWdVSW50NjRMRShvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gOFxuICAgICAgXG4gICAgICBjb25zdCBhdXRob3IgPSBkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgMzIpXG4gICAgICBvZmZzZXQgKz0gMzJcbiAgICAgIFxuICAgICAgY29uc3QgY29udGVudExlbmd0aCA9IGRhdGEucmVhZFVJbnQzMkxFKG9mZnNldClcbiAgICAgIG9mZnNldCArPSA0XG4gICAgICBcbiAgICAgIC8vIFZhbGlkYXRlIGNvbnRlbnQgbGVuZ3RoIGlzIHJlYXNvbmFibGUgKG5vdCB0b28gbGFyZ2UpXG4gICAgICBpZiAoY29udGVudExlbmd0aCA+IDEwMDAwIHx8IGNvbnRlbnRMZW5ndGggPT09IDApIHJldHVybiBudWxsXG4gICAgICBpZiAob2Zmc2V0ICsgY29udGVudExlbmd0aCA+IGRhdGEubGVuZ3RoKSByZXR1cm4gbnVsbFxuICAgICAgXG4gICAgICBjb25zdCBjb250ZW50ID0gZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIGNvbnRlbnRMZW5ndGgpLnRvU3RyaW5nKCd1dGY4JylcbiAgICAgIG9mZnNldCArPSBjb250ZW50TGVuZ3RoXG4gICAgICBcbiAgICAgIC8vIEVuc3VyZSB3ZSBoYXZlIGVub3VnaCByZW1haW5pbmcgZGF0YSBmb3IgdGhlIHJlc3Qgb2YgdGhlIHBvc3Qgc3RydWN0dXJlXG4gICAgICBpZiAob2Zmc2V0ICsgNDAgPiBkYXRhLmxlbmd0aCkgcmV0dXJuIG51bGwgLy8gTmVlZCBhdCBsZWFzdCA0MCBtb3JlIGJ5dGVzIGZvciB0aW1lc3RhbXBzIGFuZCBjb3VudHNcbiAgICAgIFxuICAgICAgY29uc3QgdGltZXN0YW1wID0gZGF0YS5yZWFkQmlnVUludDY0TEUob2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IDhcbiAgICAgIFxuICAgICAgY29uc3QgbGlrZXMgPSBkYXRhLnJlYWRCaWdVSW50NjRMRShvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gOFxuICAgICAgXG4gICAgICBjb25zdCBjb21tZW50cyA9IGRhdGEucmVhZEJpZ1VJbnQ2NExFKG9mZnNldClcbiAgICAgIG9mZnNldCArPSA4XG4gICAgICBcbiAgICAgIGNvbnN0IG1pcnJvcnMgPSBkYXRhLnJlYWRCaWdVSW50NjRMRShvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gOFxuICAgICAgXG4gICAgICAvLyBQYXJzZSBpbWFnZXMgYXJyYXkgbGVuZ3RoXG4gICAgICBpZiAob2Zmc2V0ICsgNCA+IGRhdGEubGVuZ3RoKSByZXR1cm4gbnVsbFxuICAgICAgY29uc3QgaW1hZ2VzTGVuZ3RoID0gZGF0YS5yZWFkVUludDMyTEUob2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IDRcbiAgICAgIGNvbnN0IGltYWdlczogc3RyaW5nW10gPSBbXVxuICAgICAgXG4gICAgICAvLyBQYXJzZSBpbWFnZXMgYXJyYXkgLSBlYWNoIGltYWdlIGlzIGEgbGVuZ3RoLXByZWZpeGVkIHN0cmluZ1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbWFnZXNMZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAob2Zmc2V0ICsgNCA+IGRhdGEubGVuZ3RoKSByZXR1cm4gbnVsbFxuICAgICAgICBjb25zdCBpbWFnZUxlbmd0aCA9IGRhdGEucmVhZFVJbnQzMkxFKG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IDRcbiAgICAgICAgaWYgKG9mZnNldCArIGltYWdlTGVuZ3RoID4gZGF0YS5sZW5ndGgpIHJldHVybiBudWxsXG4gICAgICAgIGNvbnN0IGltYWdlID0gZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIGltYWdlTGVuZ3RoKS50b1N0cmluZygndXRmOCcpXG4gICAgICAgIG9mZnNldCArPSBpbWFnZUxlbmd0aFxuICAgICAgICBpbWFnZXMucHVzaChpbWFnZSlcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRW5zdXJlIHdlIGhhdmUgZW5vdWdoIGRhdGEgZm9yIHJhdGluZyBhbmQga2lsbCB6b25lXG4gICAgICBpZiAob2Zmc2V0ICsgMiA+IGRhdGEubGVuZ3RoKSByZXR1cm4gbnVsbFxuICAgICAgXG4gICAgICBjb25zdCByYXRpbmcgPSBkYXRhW29mZnNldF1cbiAgICAgIG9mZnNldCArPSAxXG4gICAgICBcbiAgICAgIGNvbnN0IGluX2tpbGxfem9uZSA9IGRhdGFbb2Zmc2V0XVxuICAgICAgb2Zmc2V0ICs9IDFcbiAgICAgIFxuICAgICAgcmV0dXJuIG5ldyBQb3N0QWNjb3VudCh7XG4gICAgICAgIGlzX2luaXRpYWxpemVkLFxuICAgICAgICBpZCxcbiAgICAgICAgYXV0aG9yOiBuZXcgVWludDhBcnJheShhdXRob3IpLFxuICAgICAgICBjb250ZW50LFxuICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgIGxpa2VzLFxuICAgICAgICBjb21tZW50cyxcbiAgICAgICAgbWlycm9ycyxcbiAgICAgICAgaW1hZ2VzLFxuICAgICAgICByYXRpbmcsXG4gICAgICAgIGluX2tpbGxfem9uZVxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gU2lsZW50IGZhaWx1cmUgLSBub3QgYSBwb3N0IGFjY291bnRcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgLy8gQ29udmVydCBDb21tdW5pdHlBY2NvdW50IHRvIENvbW11bml0eSBpbnRlcmZhY2VcbiAgY29uc3QgY29udmVydENvbW11bml0eUFjY291bnQgPSAoY29tbXVuaXR5QWNjb3VudDogQ29tbXVuaXR5QWNjb3VudCk6IENvbW11bml0eSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzSW5pdGlhbGl6ZWQ6IGNvbW11bml0eUFjY291bnQuaXNfaW5pdGlhbGl6ZWQgPT09IDEsXG4gICAgICBpZDogTnVtYmVyKGNvbW11bml0eUFjY291bnQuaWQpLFxuICAgICAgY3JlYXRvcjogbmV3IFB1YmxpY0tleShjb21tdW5pdHlBY2NvdW50LmNyZWF0b3IpLFxuICAgICAgbmFtZTogY29tbXVuaXR5QWNjb3VudC5uYW1lLFxuICAgICAgZGVzY3JpcHRpb246IGNvbW11bml0eUFjY291bnQuZGVzY3JpcHRpb24sXG4gICAgICBhdmF0YXI6IGNvbW11bml0eUFjY291bnQuYXZhdGFyLFxuICAgICAgcnVsZXM6IGNvbW11bml0eUFjY291bnQucnVsZXMsXG4gICAgICBtZW1iZXJDb3VudDogTnVtYmVyKGNvbW11bml0eUFjY291bnQubWVtYmVyX2NvdW50KSxcbiAgICAgIGNyZWF0ZWRBdDogTnVtYmVyKGNvbW11bml0eUFjY291bnQuY3JlYXRlZF9hdCkgKiAxMDAwLCAvLyBDb252ZXJ0IHNlY29uZHMgdG8gbWlsbGlzZWNvbmRzXG4gICAgICBpc1ByaXZhdGU6IGNvbW11bml0eUFjY291bnQuaXNfcHJpdmF0ZSA9PT0gMSxcbiAgICB9XG4gIH1cblxuICAvLyBDcmVhdGUgQ29tbXVuaXR5XG4gIGNvbnN0IGNyZWF0ZUNvbW11bml0eSA9IGFzeW5jIChcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgZGVzY3JpcHRpb246IHN0cmluZyxcbiAgICBhdmF0YXI6IHN0cmluZyxcbiAgICBydWxlczogc3RyaW5nW10gPSBbXVxuICApID0+IHtcbiAgICBpZiAoIXB1YmxpY0tleSkgdGhyb3cgbmV3IEVycm9yKCdXYWxsZXQgbm90IGNvbm5lY3RlZCcpXG5cbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ/Cfj5jvuI8gQ3JlYXRpbmcgY29tbXVuaXR5OicsIG5hbWUpXG4gICAgICBcbiAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBjaGVja1NPTEJhbGFuY2UoKVxuICAgICAgaWYgKGJhbGFuY2UgPCAwLjA1KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdWZmaWNpZW50IFNPTCBiYWxhbmNlOiAke2JhbGFuY2V9LiBOZWVkIGF0IGxlYXN0IDAuMDUgU09MLmApXG4gICAgICB9XG5cbiAgICAgIC8vIEdlbmVyYXRlIGEga2V5cGFpciBmb3IgdGhlIGNvbW11bml0eSBhY2NvdW50XG4gICAgICBjb25zdCBjb21tdW5pdHlLZXlwYWlyID0gS2V5cGFpci5nZW5lcmF0ZSgpXG4gICAgICBjb25zb2xlLmxvZyhg8J+TjSBDb21tdW5pdHkgQWNjb3VudDogJHtjb21tdW5pdHlLZXlwYWlyLnB1YmxpY0tleS50b1N0cmluZygpfWApXG5cbiAgICAgIGNvbnN0IGluc3RydWN0aW9uRGF0YSA9IG5ldyBDcmVhdGVDb21tdW5pdHlJbnN0cnVjdGlvbih7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICBhdmF0YXIsXG4gICAgICAgIHJ1bGVzLFxuICAgICAgfSlcblxuICAgICAgY29uc3QgY3JlYXRlQ29tbXVuaXR5VmFyaWFudCA9IEJ1ZmZlci5mcm9tKFs3XSkgLy8gQ3JlYXRlQ29tbXVuaXR5IGVudW0gaW5kZXhcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWREYXRhID0gc2VyaWFsaXplKGNyZWF0ZUNvbW11bml0eVNjaGVtYSwgaW5zdHJ1Y3Rpb25EYXRhKVxuICAgICAgY29uc3QgZnVsbEluc3RydWN0aW9uRGF0YSA9IEJ1ZmZlci5jb25jYXQoW2NyZWF0ZUNvbW11bml0eVZhcmlhbnQsIEJ1ZmZlci5mcm9tKHNlcmlhbGl6ZWREYXRhKV0pXG5cbiAgICAgIGNvbnN0IGluc3RydWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICBrZXlzOiBbXG4gICAgICAgICAgeyBwdWJrZXk6IHB1YmxpY0tleSwgaXNTaWduZXI6IHRydWUsIGlzV3JpdGFibGU6IHRydWUgfSwgLy8gQ3JlYXRvciBhY2NvdW50XG4gICAgICAgICAgeyBwdWJrZXk6IGNvbW11bml0eUtleXBhaXIucHVibGljS2V5LCBpc1NpZ25lcjogdHJ1ZSwgaXNXcml0YWJsZTogdHJ1ZSB9LCAvLyBDb21tdW5pdHkgYWNjb3VudFxuICAgICAgICAgIHsgcHVia2V5OiBTeXN0ZW1Qcm9ncmFtLnByb2dyYW1JZCwgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiBmYWxzZSB9LCAvLyBTeXN0ZW0gcHJvZ3JhbVxuICAgICAgICBdLFxuICAgICAgICBwcm9ncmFtSWQ6IFBST0dSQU1fSUQsXG4gICAgICAgIGRhdGE6IGZ1bGxJbnN0cnVjdGlvbkRhdGEsXG4gICAgICB9KVxuXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpLmFkZChpbnN0cnVjdGlvbilcbiAgICAgIGNvbnN0IHsgYmxvY2toYXNoIH0gPSBhd2FpdCBjb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCgncHJvY2Vzc2VkJylcbiAgICAgIHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCA9IGJsb2NraGFzaFxuICAgICAgdHJhbnNhY3Rpb24uZmVlUGF5ZXIgPSBwdWJsaWNLZXlcblxuICAgICAgLy8gU2lnbiB3aXRoIGNvbW11bml0eSBrZXlwYWlyXG4gICAgICB0cmFuc2FjdGlvbi5wYXJ0aWFsU2lnbihjb21tdW5pdHlLZXlwYWlyKVxuXG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIGNvbm5lY3Rpb24sIHtcbiAgICAgICAgc2tpcFByZWZsaWdodDogZmFsc2UsXG4gICAgICAgIHByZWZsaWdodENvbW1pdG1lbnQ6ICdwcm9jZXNzZWQnLFxuICAgICAgICBtYXhSZXRyaWVzOiAzLFxuICAgICAgICBzaWduZXJzOiBbY29tbXVuaXR5S2V5cGFpcl0sXG4gICAgICB9KVxuXG4gICAgICBhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbih7XG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgYmxvY2toYXNoLFxuICAgICAgICBsYXN0VmFsaWRCbG9ja0hlaWdodDogKGF3YWl0IGNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2toYXNoKCkpLmxhc3RWYWxpZEJsb2NrSGVpZ2h0LFxuICAgICAgfSwgJ3Byb2Nlc3NlZCcpXG5cbiAgICAgIGNvbnNvbGUubG9nKCfinIUgQ29tbXVuaXR5IGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5IScpXG4gICAgICB0b2FzdC5zdWNjZXNzKGBDb21tdW5pdHkgXCIke25hbWV9XCIgY3JlYXRlZCBzdWNjZXNzZnVsbHkhYClcbiAgICAgIHJldHVybiBzaWduYXR1cmVcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgQ29tbXVuaXR5IGNyZWF0aW9uIGVycm9yOicsIGVycm9yKVxuICAgICAgdG9hc3QuZXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgY29tbXVuaXR5OiAke2Vycm9yLm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InfWApXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8vIEZvbGxvdyBQcm9maWxlXG4gIGNvbnN0IGZvbGxvd1Byb2ZpbGUgPSBhc3luYyAocHJvZmlsZVB1YmxpY0tleTogUHVibGljS2V5KSA9PiB7XG4gICAgaWYgKCFwdWJsaWNLZXkpIHRocm93IG5ldyBFcnJvcignV2FsbGV0IG5vdCBjb25uZWN0ZWQnKVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5GlIEZvbGxvd2luZyBwcm9maWxlOicsIHByb2ZpbGVQdWJsaWNLZXkudG9TdHJpbmcoKSlcblxuICAgICAgLy8gQ2hlY2sgU09MIGJhbGFuY2UgZmlyc3RcbiAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBjaGVja1NPTEJhbGFuY2UoKVxuICAgICAgY29uc29sZS5sb2coYPCfkrAgQ3VycmVudCBTT0wgYmFsYW5jZTogJHtiYWxhbmNlfWApXG4gICAgICBpZiAoYmFsYW5jZSA8IDAuMDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN1ZmZpY2llbnQgU09MIGJhbGFuY2U6ICR7YmFsYW5jZX0uIE5lZWQgYXQgbGVhc3QgMC4wMSBTT0wgZm9yIHRyYW5zYWN0aW9uIGZlZXMuYClcbiAgICAgIH1cblxuICAgICAgLy8gRW5zdXJlIHByb2ZpbGVQdWJsaWNLZXkgaXMgYSBwcm9wZXIgUHVibGljS2V5IGluc3RhbmNlXG4gICAgICBsZXQgdGFyZ2V0T3duZXJLZXk6IFB1YmxpY0tleVxuICAgICAgaWYgKHByb2ZpbGVQdWJsaWNLZXkgaW5zdGFuY2VvZiBQdWJsaWNLZXkpIHtcbiAgICAgICAgdGFyZ2V0T3duZXJLZXkgPSBwcm9maWxlUHVibGljS2V5XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9maWxlUHVibGljS2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0YXJnZXRPd25lcktleSA9IG5ldyBQdWJsaWNLZXkocHJvZmlsZVB1YmxpY0tleSlcbiAgICAgICAgY29uc29sZS5sb2coJ/CflIQgQ29udmVydGVkIHN0cmluZyB0byBQdWJsaWNLZXk6JywgdGFyZ2V0T3duZXJLZXkudG9TdHJpbmcoKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwcm9maWxlUHVibGljS2V5IHR5cGU6ICR7dHlwZW9mIHByb2ZpbGVQdWJsaWNLZXl9YClcbiAgICAgIH1cblxuICAgICAgLy8gRmluZCBib3RoIHRoZSB0YXJnZXQgcHJvZmlsZSBhY2NvdW50IGFuZCBmb2xsb3dlciBwcm9maWxlIGFjY291bnRcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIFNlYXJjaGluZyBmb3IgdGFyZ2V0IHByb2ZpbGUgb3duZWQgYnk6ICR7dGFyZ2V0T3duZXJLZXkudG9TdHJpbmcoKS5zbGljZSgwLCA4KX0uLi5gKVxuICAgICAgY29uc29sZS5sb2coYPCflI0gU2VhcmNoaW5nIGZvciBmb2xsb3dlciBwcm9maWxlIG93bmVkIGJ5OiAke3B1YmxpY0tleS50b1N0cmluZygpLnNsaWNlKDAsIDgpfS4uLmApXG4gICAgICBcbiAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgY29ubmVjdGlvbi5nZXRQcm9ncmFtQWNjb3VudHMoUFJPR1JBTV9JRClcbiAgICAgIGxldCB0YXJnZXRQcm9maWxlQWRkcmVzczogUHVibGljS2V5IHwgbnVsbCA9IG51bGxcbiAgICAgIGxldCBmb2xsb3dlclByb2ZpbGVBZGRyZXNzOiBQdWJsaWNLZXkgfCBudWxsID0gbnVsbFxuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IHsgYWNjb3VudCwgcHVia2V5IH0gb2YgYWNjb3VudHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBDaGVjayBpZiBhY2NvdW50IGJlbG9uZ3MgdG8gb3VyIHByb2dyYW1cbiAgICAgICAgICBjb25zdCBhY2NvdW50SW5mbyA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0QWNjb3VudEluZm8ocHVia2V5KVxuICAgICAgICAgIGlmICghYWNjb3VudEluZm8gfHwgIWFjY291bnRJbmZvLm93bmVyLmVxdWFscyhQUk9HUkFNX0lEKSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYOKaoO+4jyBBY2NvdW50ICR7cHVia2V5LnRvU3RyaW5nKCkuc2xpY2UoMCwgOCl9IGRvZXNuJ3QgYmVsb25nIHRvIG91ciBwcm9ncmFtIChvd25lcjogJHthY2NvdW50SW5mbz8ub3duZXIudG9TdHJpbmcoKX0pYClcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcGFyc2VkUHJvZmlsZSA9IG1hbnVhbFBhcnNlUHJvZmlsZShhY2NvdW50LmRhdGEpXG4gICAgICAgICAgaWYgKHBhcnNlZFByb2ZpbGUgJiYgcGFyc2VkUHJvZmlsZS5pc19pbml0aWFsaXplZCA9PT0gMSkge1xuICAgICAgICAgICAgY29uc3QgcHJvZmlsZU93bmVyID0gbmV3IFB1YmxpY0tleShwYXJzZWRQcm9maWxlLm93bmVyKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIHRoZSB0YXJnZXQgcHJvZmlsZSAob3duZWQgYnkgdGhlIHBlcnNvbiB3ZSB3YW50IHRvIGZvbGxvdylcbiAgICAgICAgICAgIGlmIChwcm9maWxlT3duZXIuZXF1YWxzKHRhcmdldE93bmVyS2V5KSkge1xuICAgICAgICAgICAgICAvLyBJZiB3ZSBhbHJlYWR5IGZvdW5kIGEgdGFyZ2V0IHByb2ZpbGUsIHByZWZlciB0aGUgZmlyc3Qgb25lIChvciB5b3UgY291bGQgYWRkIGxvZ2ljIHRvIHBpY2sgYSBzcGVjaWZpYyBvbmUpXG4gICAgICAgICAgICAgIGlmICghdGFyZ2V0UHJvZmlsZUFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRQcm9maWxlQWRkcmVzcyA9IHB1YmtleVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn46vIEZvdW5kIHRhcmdldCBwcm9maWxlIGFjY291bnQ6ICR7cHVia2V5LnRvU3RyaW5nKCl9YClcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgT3duZXI6ICR7cHJvZmlsZU93bmVyLnRvU3RyaW5nKCl9YClcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgVXNlcm5hbWU6ICR7cGFyc2VkUHJvZmlsZS51c2VybmFtZX1gKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDimqDvuI8gRm91bmQgYWRkaXRpb25hbCBwcm9maWxlIGZvciBzYW1lIG93bmVyOiAke3B1YmtleS50b1N0cmluZygpfSAoJHtwYXJzZWRQcm9maWxlLnVzZXJuYW1lfSkgLSBza2lwcGluZ2ApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyB0aGUgZm9sbG93ZXIncyBwcm9maWxlIChjdXJyZW50IHVzZXIpXG4gICAgICAgICAgICBpZiAocHJvZmlsZU93bmVyLmVxdWFscyhwdWJsaWNLZXkpKSB7XG4gICAgICAgICAgICAgIC8vIElmIHdlIGFscmVhZHkgZm91bmQgYSBmb2xsb3dlciBwcm9maWxlLCBwcmVmZXIgdGhlIGZpcnN0IG9uZVxuICAgICAgICAgICAgICBpZiAoIWZvbGxvd2VyUHJvZmlsZUFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICBmb2xsb3dlclByb2ZpbGVBZGRyZXNzID0gcHVia2V5XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBGb3VuZCBmb2xsb3dlciBwcm9maWxlIGFjY291bnQ6ICR7cHVia2V5LnRvU3RyaW5nKCl9YClcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgT3duZXI6ICR7cHJvZmlsZU93bmVyLnRvU3RyaW5nKCl9YClcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgVXNlcm5hbWU6ICR7cGFyc2VkUHJvZmlsZS51c2VybmFtZX1gKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDimqDvuI8gRm91bmQgYWRkaXRpb25hbCBwcm9maWxlIGZvciBmb2xsb3dlcjogJHtwdWJrZXkudG9TdHJpbmcoKX0gKCR7cGFyc2VkUHJvZmlsZS51c2VybmFtZX0pIC0gc2tpcHBpbmdgKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIC8vIFNpbGVudCBmYWlsdXJlIC0gbm90IGEgcHJvZmlsZSBhY2NvdW50XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRhcmdldFByb2ZpbGVBZGRyZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGFyZ2V0IHByb2ZpbGUgb3duZWQgYnkgJHt0YXJnZXRPd25lcktleS50b1N0cmluZygpLnNsaWNlKDAsIDgpfSBub3QgZm91bmQgb24gYmxvY2tjaGFpbi4gTWFrZSBzdXJlIHRoaXMgdXNlciBoYXMgY3JlYXRlZCBhIHByb2ZpbGUuYClcbiAgICAgIH1cblxuICAgICAgaWYgKCFmb2xsb3dlclByb2ZpbGVBZGRyZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgY3JlYXRlIGEgcHJvZmlsZSBiZWZvcmUgZm9sbG93aW5nIG90aGVycycpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGluc3RydWN0aW9uRGF0YSA9IG5ldyBGb2xsb3dQcm9maWxlSW5zdHJ1Y3Rpb24oe1xuICAgICAgICBwcm9maWxlX2lkOiB0YXJnZXRQcm9maWxlQWRkcmVzcywgLy8gTVVTVCBiZSB0aGUgcHJvZmlsZSBhY2NvdW50IGFkZHJlc3MsIG5vdCBvd25lciBrZXlcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IGZvbGxvd1Byb2ZpbGVWYXJpYW50ID0gQnVmZmVyLmZyb20oWzVdKSAvLyBGb2xsb3dQcm9maWxlIGVudW0gaW5kZXhcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWREYXRhID0gc2VyaWFsaXplKGZvbGxvd1Byb2ZpbGVTY2hlbWEsIGluc3RydWN0aW9uRGF0YSlcbiAgICAgIGNvbnN0IGZ1bGxJbnN0cnVjdGlvbkRhdGEgPSBCdWZmZXIuY29uY2F0KFtmb2xsb3dQcm9maWxlVmFyaWFudCwgQnVmZmVyLmZyb20oc2VyaWFsaXplZERhdGEpXSlcblxuICAgICAgY29uc29sZS5sb2coYPCflKIgSW5zdHJ1Y3Rpb24gZGF0YTogdmFyaWFudCBbNV0sIHNlcmlhbGl6ZWQgbGVuZ3RoOiAke3NlcmlhbGl6ZWREYXRhLmxlbmd0aH0sIHRvdGFsOiAke2Z1bGxJbnN0cnVjdGlvbkRhdGEubGVuZ3RofSBieXRlc2ApXG4gICAgICBjb25zb2xlLmxvZyhg8J+UoiBVc2luZyB0YXJnZXQgcHJvZmlsZSBhY2NvdW50IGFkZHJlc3MgaW4gaW5zdHJ1Y3Rpb246ICR7dGFyZ2V0UHJvZmlsZUFkZHJlc3MudG9TdHJpbmcoKX1gKVxuXG4gICAgICAvLyBEZWJ1ZzogdmVyaWZ5IGFsbCBwdWJrZXlzIGFyZSBwcm9wZXIgUHVibGljS2V5IGluc3RhbmNlcyBhbmQgYmVsb25nIHRvIG91ciBwcm9ncmFtXG4gICAgICBjb25zb2xlLmxvZygn8J+UjSBWZXJpZnlpbmcgdHJhbnNhY3Rpb24ga2V5czonKVxuICAgICAgY29uc29sZS5sb2coJyAgcHVibGljS2V5IChmb2xsb3dlcik6JywgcHVibGljS2V5LnRvU3RyaW5nKCksICdpbnN0YW5jZW9mIFB1YmxpY0tleTonLCBwdWJsaWNLZXkgaW5zdGFuY2VvZiBQdWJsaWNLZXkpXG4gICAgICBjb25zb2xlLmxvZygnICB0YXJnZXRQcm9maWxlQWRkcmVzcyAoYWNjb3VudCk6JywgdGFyZ2V0UHJvZmlsZUFkZHJlc3MudG9TdHJpbmcoKSwgJ2luc3RhbmNlb2YgUHVibGljS2V5OicsIHRhcmdldFByb2ZpbGVBZGRyZXNzIGluc3RhbmNlb2YgUHVibGljS2V5KVxuICAgICAgY29uc29sZS5sb2coJyAgZm9sbG93ZXJQcm9maWxlQWRkcmVzcyAoYWNjb3VudCk6JywgZm9sbG93ZXJQcm9maWxlQWRkcmVzcy50b1N0cmluZygpLCAnaW5zdGFuY2VvZiBQdWJsaWNLZXk6JywgZm9sbG93ZXJQcm9maWxlQWRkcmVzcyBpbnN0YW5jZW9mIFB1YmxpY0tleSlcbiAgICAgIGNvbnNvbGUubG9nKCcgIFBST0dSQU1fSUQ6JywgUFJPR1JBTV9JRC50b1N0cmluZygpKVxuXG4gICAgICAvLyBWZXJpZnkgYWNjb3VudCBvd25lcnNoaXBcbiAgICAgIGNvbnN0IHRhcmdldEFjY291bnRJbmZvID0gYXdhaXQgY29ubmVjdGlvbi5nZXRBY2NvdW50SW5mbyh0YXJnZXRQcm9maWxlQWRkcmVzcylcbiAgICAgIGNvbnN0IGZvbGxvd2VyQWNjb3VudEluZm8gPSBhd2FpdCBjb25uZWN0aW9uLmdldEFjY291bnRJbmZvKGZvbGxvd2VyUHJvZmlsZUFkZHJlc3MpXG4gICAgICBjb25zb2xlLmxvZygn8J+UjSBBY2NvdW50IG93bmVyc2hpcCB2ZXJpZmljYXRpb246JylcbiAgICAgIGNvbnNvbGUubG9nKCcgIFRhcmdldCBwcm9maWxlIG93bmVyOicsIHRhcmdldEFjY291bnRJbmZvPy5vd25lci50b1N0cmluZygpKVxuICAgICAgY29uc29sZS5sb2coJyAgRm9sbG93ZXIgcHJvZmlsZSBvd25lcjonLCBmb2xsb3dlckFjY291bnRJbmZvPy5vd25lci50b1N0cmluZygpKVxuICAgICAgY29uc29sZS5sb2coJyAgRXhwZWN0ZWQgb3duZXIgKFBST0dSQU1fSUQpOicsIFBST0dSQU1fSUQudG9TdHJpbmcoKSlcbiAgICAgIGNvbnNvbGUubG9nKCcgIFRhcmdldCBwcm9maWxlIG93bmVkIGJ5OicsIHRhcmdldE93bmVyS2V5LnRvU3RyaW5nKCkpXG5cbiAgICAgIC8vIFNtYXJ0IGNvbnRyYWN0IGV4cGVjdHMgdGhpcyBFWEFDVCBhY2NvdW50IG9yZGVyOlxuICAgICAgLy8gMC4gZm9sbG93ZXJfYWNjb3VudCAoc2lnbmVyLCB3cml0YWJsZSkgLSBUaGUgZm9sbG93ZXIncyB3YWxsZXRcbiAgICAgIC8vIDEuIGZvbGxvd2VkX3Byb2ZpbGVfYWNjb3VudCAod3JpdGFibGUpIC0gVGhlIHByb2ZpbGUgYWNjb3VudCB0byBmb2xsb3cgIFxuICAgICAgLy8gMi4gZm9sbG93ZXJfcHJvZmlsZV9hY2NvdW50ICh3cml0YWJsZSkgLSBUaGUgZm9sbG93ZXIncyBwcm9maWxlIGFjY291bnRcbiAgICAgIGNvbnN0IGluc3RydWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICBrZXlzOiBbXG4gICAgICAgICAgeyBwdWJrZXk6IHB1YmxpY0tleSwgaXNTaWduZXI6IHRydWUsIGlzV3JpdGFibGU6IHRydWUgfSwgLy8gZm9sbG93ZXJfYWNjb3VudCAobXVzdCBiZSB3cml0YWJsZSBwZXIgc21hcnQgY29udHJhY3QpXG4gICAgICAgICAgeyBwdWJrZXk6IHRhcmdldFByb2ZpbGVBZGRyZXNzLCBpc1NpZ25lcjogZmFsc2UsIGlzV3JpdGFibGU6IHRydWUgfSwgLy8gZm9sbG93ZWRfcHJvZmlsZV9hY2NvdW50XG4gICAgICAgICAgeyBwdWJrZXk6IGZvbGxvd2VyUHJvZmlsZUFkZHJlc3MsIGlzU2lnbmVyOiBmYWxzZSwgaXNXcml0YWJsZTogdHJ1ZSB9LCAvLyBmb2xsb3dlcl9wcm9maWxlX2FjY291bnRcbiAgICAgICAgXSxcbiAgICAgICAgcHJvZ3JhbUlkOiBQUk9HUkFNX0lELFxuICAgICAgICBkYXRhOiBmdWxsSW5zdHJ1Y3Rpb25EYXRhLFxuICAgICAgfSlcblxuICAgICAgY29uc29sZS5sb2coJ/CflJEgVHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gY3JlYXRlZCcpXG4gICAgICBjb25zb2xlLmxvZygn8J+UkSBLZXlzOicsIGluc3RydWN0aW9uLmtleXMubWFwKGsgPT4gKHtcbiAgICAgICAgcHVia2V5OiBrLnB1YmtleS50b1N0cmluZygpLFxuICAgICAgICBpc1NpZ25lcjogay5pc1NpZ25lcixcbiAgICAgICAgaXNXcml0YWJsZTogay5pc1dyaXRhYmxlXG4gICAgICB9KSkpXG5cbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKGluc3RydWN0aW9uKVxuICAgICAgY29uc3QgeyBibG9ja2hhc2ggfSA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2toYXNoKCdwcm9jZXNzZWQnKVxuICAgICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoXG4gICAgICB0cmFuc2FjdGlvbi5mZWVQYXllciA9IHB1YmxpY0tleVxuXG4gICAgICAvLyBTaW11bGF0ZSB0cmFuc2FjdGlvbiBiZWZvcmUgc2VuZGluZ1xuICAgICAgY29uc29sZS5sb2coJ/Cfjq8gU2ltdWxhdGluZyB0cmFuc2FjdGlvbi4uLicpXG4gICAgICBjb25zdCBzaW11bGF0aW9uID0gYXdhaXQgY29ubmVjdGlvbi5zaW11bGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKVxuICAgICAgY29uc29sZS5sb2coJ/Cfk4ogU2ltdWxhdGlvbiByZXN1bHQ6Jywgc2ltdWxhdGlvbilcbiAgICAgIFxuICAgICAgaWYgKHNpbXVsYXRpb24udmFsdWUuZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gc2ltdWxhdGlvbiBmYWlsZWQ6ICR7SlNPTi5zdHJpbmdpZnkoc2ltdWxhdGlvbi52YWx1ZS5lcnIpfWApXG4gICAgICB9XG4gICAgICBjb25zb2xlLmxvZygn4pyFIFRyYW5zYWN0aW9uIHNpbXVsYXRpb24gc3VjY2Vzc2Z1bCcpXG5cbiAgICAgIGNvbnNvbGUubG9nKCfwn5qAIFNlbmRpbmcgdHJhbnNhY3Rpb24uLi4nKVxuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBjb25uZWN0aW9uLCB7XG4gICAgICAgIHNraXBQcmVmbGlnaHQ6IGZhbHNlLFxuICAgICAgICBwcmVmbGlnaHRDb21taXRtZW50OiAncHJvY2Vzc2VkJyxcbiAgICAgICAgbWF4UmV0cmllczogMyxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnNvbGUubG9nKGDwn5OLIFRyYW5zYWN0aW9uIHNlbnQgd2l0aCBzaWduYXR1cmU6ICR7c2lnbmF0dXJlfWApXG5cbiAgICAgIGNvbnNvbGUubG9nKCfij7MgQ29uZmlybWluZyB0cmFuc2FjdGlvbi4uLicpXG4gICAgICBhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbih7XG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgYmxvY2toYXNoLFxuICAgICAgICBsYXN0VmFsaWRCbG9ja0hlaWdodDogKGF3YWl0IGNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2toYXNoKCkpLmxhc3RWYWxpZEJsb2NrSGVpZ2h0LFxuICAgICAgfSwgJ3Byb2Nlc3NlZCcpXG5cbiAgICAgIGNvbnNvbGUubG9nKCfinIUgVHJhbnNhY3Rpb24gY29uZmlybWVkISBQcm9maWxlIGZvbGxvd2VkIHN1Y2Nlc3NmdWxseSEnKVxuICAgICAgXG4gICAgICAvLyBUcmFjayB0aGUgZm9sbG93IGluIGxvY2FsU3RvcmFnZVxuICAgICAgaWYgKHB1YmxpY0tleSkge1xuICAgICAgICBhZGRVc2VyRm9sbG93KHB1YmxpY0tleS50b1N0cmluZygpLCB0YXJnZXRPd25lcktleS50b1N0cmluZygpKVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDbGVhciBwcm9maWxlIGNhY2hlIHRvIGZvcmNlIHJlZnJlc2ggb2YgZm9sbG93ZXIgY291bnRzIGZvciBib3RoIHByb2ZpbGVzXG4gICAgICBjbGVhclByb2ZpbGVDYWNoZShwdWJsaWNLZXkudG9TdHJpbmcoKSkgLy8gQ2xlYXIgZm9sbG93ZXIncyBwcm9maWxlIGNhY2hlXG4gICAgICBjbGVhclByb2ZpbGVDYWNoZSh0YXJnZXRPd25lcktleS50b1N0cmluZygpKSAvLyBDbGVhciB0YXJnZXQncyBwcm9maWxlIGNhY2hlXG4gICAgICBjbGVhclByb2ZpbGVDYWNoZSgpIC8vIENsZWFyIGFsbCBjYWNoZXMgdG8gYmUgc2FmZVxuICAgICAgXG4gICAgICB0b2FzdC5zdWNjZXNzKCdQcm9maWxlIGZvbGxvd2VkIScpXG4gICAgICByZXR1cm4gc2lnbmF0dXJlXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEZvbGxvdyBlcnJvcjonLCBlcnJvcilcbiAgICAgIFxuICAgICAgLy8gTW9yZSBzcGVjaWZpYyBlcnJvciBtZXNzYWdlc1xuICAgICAgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdpbnN1ZmZpY2llbnQgZnVuZHMnKSkge1xuICAgICAgICBjb25zdCBiYWxhbmNlID0gYXdhaXQgY2hlY2tTT0xCYWxhbmNlKClcbiAgICAgICAgdG9hc3QuZXJyb3IoYEluc3VmZmljaWVudCBTT0w6ICR7YmFsYW5jZS50b0ZpeGVkKDQpfSBTT0wuIE5lZWQgYXQgbGVhc3QgMC4wMSBTT0wgZm9yIGZlZXMuYClcbiAgICAgIH0gZWxzZSBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ3NpbXVsYXRpb24gZmFpbGVkJykpIHtcbiAgICAgICAgdG9hc3QuZXJyb3IoJ1RyYW5zYWN0aW9uIHdvdWxkIGZhaWw6IENoZWNrIGFjY291bnRzIGFuZCBwZXJtaXNzaW9ucycpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1NpbXVsYXRpb24gZXJyb3IgZGV0YWlsczonLCBlcnJvci5tZXNzYWdlKVxuICAgICAgfSBlbHNlIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnbm90IGZvdW5kIG9uIGJsb2NrY2hhaW4nKSkge1xuICAgICAgICB0b2FzdC5lcnJvcignUHJvZmlsZSBub3QgZm91bmQ6IFVzZXIgbWF5IG5vdCBoYXZlIGNyZWF0ZWQgYSBwcm9maWxlIHlldCcpXG4gICAgICB9IGVsc2UgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdVbmV4cGVjdGVkIGVycm9yJykpIHtcbiAgICAgICAgdG9hc3QuZXJyb3IoJ1dhbGxldCB0cmFuc2FjdGlvbiBmYWlsZWQ6IENoZWNrIGNvbm5lY3Rpb24gYW5kIHRyeSBhZ2FpbicpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b2FzdC5lcnJvcihgRmFpbGVkIHRvIGZvbGxvdyBwcm9maWxlOiAke2Vycm9yLm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InfWApXG4gICAgICB9XG4gICAgICBcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLy8gVW5mb2xsb3cgUHJvZmlsZVxuICBjb25zdCB1bmZvbGxvd1Byb2ZpbGUgPSBhc3luYyAocHJvZmlsZVB1YmxpY0tleTogUHVibGljS2V5KSA9PiB7XG4gICAgaWYgKCFwdWJsaWNLZXkpIHRocm93IG5ldyBFcnJvcignV2FsbGV0IG5vdCBjb25uZWN0ZWQnKVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5GlIFVuZm9sbG93aW5nIHByb2ZpbGU6JywgcHJvZmlsZVB1YmxpY0tleS50b1N0cmluZygpKVxuXG4gICAgICAvLyBFbnN1cmUgcHJvZmlsZVB1YmxpY0tleSBpcyBhIHByb3BlciBQdWJsaWNLZXkgaW5zdGFuY2VcbiAgICAgIGxldCB0YXJnZXRQcm9maWxlS2V5OiBQdWJsaWNLZXlcbiAgICAgIGlmIChwcm9maWxlUHVibGljS2V5IGluc3RhbmNlb2YgUHVibGljS2V5KSB7XG4gICAgICAgIHRhcmdldFByb2ZpbGVLZXkgPSBwcm9maWxlUHVibGljS2V5XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9maWxlUHVibGljS2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0YXJnZXRQcm9maWxlS2V5ID0gbmV3IFB1YmxpY0tleShwcm9maWxlUHVibGljS2V5KVxuICAgICAgICBjb25zb2xlLmxvZygn8J+UhCBDb252ZXJ0ZWQgc3RyaW5nIHRvIFB1YmxpY0tleTonLCB0YXJnZXRQcm9maWxlS2V5LnRvU3RyaW5nKCkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcHJvZmlsZVB1YmxpY0tleSB0eXBlOiAke3R5cGVvZiBwcm9maWxlUHVibGljS2V5fWApXG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmQgdGhlIGZvbGxvd2VyJ3MgcHJvZmlsZSBhY2NvdW50IChjdXJyZW50IHVzZXIncyBwcm9maWxlKVxuICAgICAgY29uc29sZS5sb2coYPCflI0gU2VhcmNoaW5nIGZvciBmb2xsb3dlciBwcm9maWxlOiAke3B1YmxpY0tleS50b1N0cmluZygpLnNsaWNlKDAsIDgpfS4uLmApXG4gICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0UHJvZ3JhbUFjY291bnRzKFBST0dSQU1fSUQpXG4gICAgICBsZXQgZm9sbG93ZXJQcm9maWxlQWRkcmVzczogUHVibGljS2V5IHwgbnVsbCA9IG51bGxcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCB7IGFjY291bnQsIHB1YmtleSB9IG9mIGFjY291bnRzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkUHJvZmlsZSA9IG1hbnVhbFBhcnNlUHJvZmlsZShhY2NvdW50LmRhdGEpXG4gICAgICAgICAgaWYgKHBhcnNlZFByb2ZpbGUgJiYgXG4gICAgICAgICAgICAgIHBhcnNlZFByb2ZpbGUuaXNfaW5pdGlhbGl6ZWQgPT09IDEgJiYgXG4gICAgICAgICAgICAgIG5ldyBQdWJsaWNLZXkocGFyc2VkUHJvZmlsZS5vd25lcikuZXF1YWxzKHB1YmxpY0tleSkpIHtcbiAgICAgICAgICAgIGZvbGxvd2VyUHJvZmlsZUFkZHJlc3MgPSBwdWJrZXlcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgRm91bmQgZm9sbG93ZXIgcHJvZmlsZSBhY2NvdW50OiAke3B1YmtleS50b1N0cmluZygpfWApXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAvLyBTaWxlbnQgZmFpbHVyZSAtIG5vdCBhIHByb2ZpbGUgYWNjb3VudFxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFmb2xsb3dlclByb2ZpbGVBZGRyZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgY3JlYXRlIGEgcHJvZmlsZSBiZWZvcmUgdW5mb2xsb3dpbmcgb3RoZXJzJylcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0gbmV3IEZvbGxvd1Byb2ZpbGVJbnN0cnVjdGlvbih7XG4gICAgICAgIHByb2ZpbGVfaWQ6IHRhcmdldFByb2ZpbGVLZXksXG4gICAgICB9KVxuXG4gICAgICBjb25zdCB1bmZvbGxvd1Byb2ZpbGVWYXJpYW50ID0gQnVmZmVyLmZyb20oWzZdKSAvLyBVbmZvbGxvd1Byb2ZpbGUgZW51bSBpbmRleFxuICAgICAgY29uc3Qgc2VyaWFsaXplZERhdGEgPSBzZXJpYWxpemUoZm9sbG93UHJvZmlsZVNjaGVtYSwgaW5zdHJ1Y3Rpb25EYXRhKVxuICAgICAgY29uc3QgZnVsbEluc3RydWN0aW9uRGF0YSA9IEJ1ZmZlci5jb25jYXQoW3VuZm9sbG93UHJvZmlsZVZhcmlhbnQsIEJ1ZmZlci5mcm9tKHNlcmlhbGl6ZWREYXRhKV0pXG5cbiAgICAgIGNvbnN0IGluc3RydWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICBrZXlzOiBbXG4gICAgICAgICAgeyBwdWJrZXk6IHB1YmxpY0tleSwgaXNTaWduZXI6IHRydWUsIGlzV3JpdGFibGU6IGZhbHNlIH0sIC8vIEZvbGxvd2VyIGFjY291bnRcbiAgICAgICAgICB7IHB1YmtleTogdGFyZ2V0UHJvZmlsZUtleSwgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiB0cnVlIH0sIC8vIFByb2ZpbGUgdG8gdW5mb2xsb3dcbiAgICAgICAgICB7IHB1YmtleTogZm9sbG93ZXJQcm9maWxlQWRkcmVzcywgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiB0cnVlIH0sIC8vIEZvbGxvd2VyJ3MgcHJvZmlsZSBhY2NvdW50XG4gICAgICAgIF0sXG4gICAgICAgIHByb2dyYW1JZDogUFJPR1JBTV9JRCxcbiAgICAgICAgZGF0YTogZnVsbEluc3RydWN0aW9uRGF0YSxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKGluc3RydWN0aW9uKVxuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBjb25uZWN0aW9uKVxuXG4gICAgICBhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbihzaWduYXR1cmUsICdwcm9jZXNzZWQnKVxuICAgICAgXG4gICAgICAvLyBUcmFjayB0aGUgdW5mb2xsb3cgaW4gbG9jYWxTdG9yYWdlXG4gICAgICBpZiAocHVibGljS2V5KSB7XG4gICAgICAgIHJlbW92ZVVzZXJGb2xsb3cocHVibGljS2V5LnRvU3RyaW5nKCksIHRhcmdldFByb2ZpbGVLZXkudG9TdHJpbmcoKSlcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2xlYXIgcHJvZmlsZSBjYWNoZSB0byBmb3JjZSByZWZyZXNoIG9mIGZvbGxvd2VyIGNvdW50cyBmb3IgYm90aCBwcm9maWxlc1xuICAgICAgY2xlYXJQcm9maWxlQ2FjaGUocHVibGljS2V5LnRvU3RyaW5nKCkpIC8vIENsZWFyIGZvbGxvd2VyJ3MgcHJvZmlsZSBjYWNoZVxuICAgICAgY2xlYXJQcm9maWxlQ2FjaGUodGFyZ2V0UHJvZmlsZUtleS50b1N0cmluZygpKSAvLyBDbGVhciB0YXJnZXQncyBwcm9maWxlIGNhY2hlXG4gICAgICBjbGVhclByb2ZpbGVDYWNoZSgpIC8vIENsZWFyIGFsbCBjYWNoZXMgdG8gYmUgc2FmZVxuICAgICAgXG4gICAgICB0b2FzdC5zdWNjZXNzKCdQcm9maWxlIHVuZm9sbG93ZWQhJylcbiAgICAgIHJldHVybiBzaWduYXR1cmVcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdVbmZvbGxvdyBlcnJvcjonLCBlcnJvcilcbiAgICAgIHRvYXN0LmVycm9yKCdGYWlsZWQgdG8gdW5mb2xsb3cgcHJvZmlsZScpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8vIFVwZGF0ZSBQcm9maWxlXG4gIGNvbnN0IHVwZGF0ZVByb2ZpbGUgPSBhc3luYyAoXG4gICAgdXNlcm5hbWU6IHN0cmluZyxcbiAgICBiaW86IHN0cmluZyxcbiAgICBwcm9maWxlSW1hZ2U6IHN0cmluZyxcbiAgICBjb3ZlckltYWdlOiBzdHJpbmdcbiAgKSA9PiB7XG4gICAgaWYgKCFwdWJsaWNLZXkpIHRocm93IG5ldyBFcnJvcignV2FsbGV0IG5vdCBjb25uZWN0ZWQnKVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SEIFVwZGF0aW5nIHByb2ZpbGU6JywgdXNlcm5hbWUpXG4gICAgICBcbiAgICAgIGNvbnN0IGluc3RydWN0aW9uRGF0YSA9IG5ldyBDcmVhdGVQcm9maWxlSW5zdHJ1Y3Rpb24oe1xuICAgICAgICB1c2VybmFtZSxcbiAgICAgICAgYmlvLFxuICAgICAgICBwcm9maWxlX2ltYWdlOiBwcm9maWxlSW1hZ2UsXG4gICAgICAgIGNvdmVyX2ltYWdlOiBjb3ZlckltYWdlLFxuICAgICAgfSlcblxuICAgICAgY29uc3QgdXBkYXRlUHJvZmlsZVZhcmlhbnQgPSBCdWZmZXIuZnJvbShbMV0pIC8vIFVwZGF0ZVByb2ZpbGUgZW51bSBpbmRleCAoc2FtZSBhcyBDcmVhdGVQcm9maWxlKVxuICAgICAgY29uc3Qgc2VyaWFsaXplZERhdGEgPSBzZXJpYWxpemUoY3JlYXRlUHJvZmlsZVNjaGVtYSwgaW5zdHJ1Y3Rpb25EYXRhKVxuICAgICAgY29uc3QgZnVsbEluc3RydWN0aW9uRGF0YSA9IEJ1ZmZlci5jb25jYXQoW3VwZGF0ZVByb2ZpbGVWYXJpYW50LCBCdWZmZXIuZnJvbShzZXJpYWxpemVkRGF0YSldKVxuXG4gICAgICBjb25zdCBpbnN0cnVjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgICAga2V5czogW1xuICAgICAgICAgIHsgcHVia2V5OiBwdWJsaWNLZXksIGlzU2lnbmVyOiB0cnVlLCBpc1dyaXRhYmxlOiB0cnVlIH0sIC8vIFByb2ZpbGUgb3duZXIgYWNjb3VudFxuICAgICAgICBdLFxuICAgICAgICBwcm9ncmFtSWQ6IFBST0dSQU1fSUQsXG4gICAgICAgIGRhdGE6IGZ1bGxJbnN0cnVjdGlvbkRhdGEsXG4gICAgICB9KVxuXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpLmFkZChpbnN0cnVjdGlvbilcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgY29ubmVjdGlvbilcblxuICAgICAgYXdhaXQgY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oc2lnbmF0dXJlLCAncHJvY2Vzc2VkJylcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgUHJvZmlsZSB1cGRhdGVkIHN1Y2Nlc3NmdWxseSEnKVxuICAgICAgXG4gICAgICAvLyBDbGVhciBjYWNoZSB0byBmb3JjZSByZWZyZXNoXG4gICAgICBwcm9maWxlQ2FjaGUuZGVsZXRlKHB1YmxpY0tleS50b1N0cmluZygpKVxuICAgICAgXG4gICAgICByZXR1cm4gc2lnbmF0dXJlXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIFVwZGF0ZSBwcm9maWxlIGVycm9yOicsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvLyBDb21tZW50IG9uIFBvc3QgLSBSRUFMIEJMT0NLQ0hBSU4gSU1QTEVNRU5UQVRJT05cbiAgY29uc3QgY29tbWVudE9uUG9zdCA9IGFzeW5jIChwb3N0SWQ6IG51bWJlciwgY29udGVudDogc3RyaW5nLCBwb3N0QXV0aG9yOiBQdWJsaWNLZXkpID0+IHtcbiAgICBpZiAoIXB1YmxpY0tleSkgdGhyb3cgbmV3IEVycm9yKCdXYWxsZXQgbm90IGNvbm5lY3RlZCcpXG5cbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYPCfkqwgQ3JlYXRpbmcgY29tbWVudCBvbiBwb3N0IElEICR7cG9zdElkfS4uLmApXG4gICAgICBcbiAgICAgIC8vIENoZWNrIFNPTCBiYWxhbmNlXG4gICAgICBjb25zdCBiYWxhbmNlID0gYXdhaXQgY2hlY2tTT0xCYWxhbmNlKClcbiAgICAgIGlmIChiYWxhbmNlIDwgMC4wNSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluc3VmZmljaWVudCBTT0wgYmFsYW5jZTogJHtiYWxhbmNlfS4gWW91IG5lZWQgYXQgbGVhc3QgMC4wNSBTT0wgZm9yIHRyYW5zYWN0aW9uIGZlZXMgYW5kIGFjY291bnQgY3JlYXRpb24uYClcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IHVzZXIncyBwcm9maWxlIGZvciB0aGUgY29tbWVudFxuICAgICAgY29uc3QgdXNlclByb2ZpbGUgPSBhd2FpdCBnZXRQcm9maWxlKHB1YmxpY0tleSlcbiAgICAgIGlmICghdXNlclByb2ZpbGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBjcmVhdGUgYSBwcm9maWxlIGJlZm9yZSBjb21tZW50aW5nJylcbiAgICAgIH1cblxuICAgICAgLy8gRmluZCB0aGUgcGFyZW50IHBvc3QgYWNjb3VudCBieSBzY2FubmluZyBhbGwgcHJvZ3JhbSBhY2NvdW50c1xuICAgICAgY29uc29sZS5sb2coYPCflI0gU2VhcmNoaW5nIGZvciBwb3N0IElEICR7cG9zdElkfSBieSBhdXRob3IgJHtwb3N0QXV0aG9yLnRvU3RyaW5nKCkuc2xpY2UoMCwgOCl9Li4uYClcbiAgICAgIFxuICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBjb25uZWN0aW9uLmdldFByb2dyYW1BY2NvdW50cyhQUk9HUkFNX0lEKVxuICAgICAgbGV0IHBhcmVudFBvc3RBY2NvdW50QWRkcmVzczogUHVibGljS2V5IHwgbnVsbCA9IG51bGxcbiAgICAgIGxldCBwYXJlbnRQb3N0QWNjb3VudDogUG9zdEFjY291bnQgfCBudWxsID0gbnVsbFxuICAgICAgbGV0IHVzZXJQcm9maWxlQWNjb3VudEFkZHJlc3M6IFB1YmxpY0tleSB8IG51bGwgPSBudWxsXG4gICAgICBcbiAgICAgIC8vIEZpcnN0IHBhc3M6IGZpbmQgdGhlIHBhcmVudCBwb3N0IGFjY291bnRcbiAgICAgIGZvciAoY29uc3QgeyBhY2NvdW50LCBwdWJrZXkgfSBvZiBhY2NvdW50cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHBhcnNlZFBvc3QgPSBtYW51YWxQYXJzZVBvc3QoYWNjb3VudC5kYXRhKVxuICAgICAgICAgIGlmIChwYXJzZWRQb3N0ICYmIFxuICAgICAgICAgICAgICBwYXJzZWRQb3N0LmlzX2luaXRpYWxpemVkID09PSAxICYmIFxuICAgICAgICAgICAgICBOdW1iZXIocGFyc2VkUG9zdC5pZCkgPT09IHBvc3RJZCAmJlxuICAgICAgICAgICAgICBuZXcgUHVibGljS2V5KHBhcnNlZFBvc3QuYXV0aG9yKS5lcXVhbHMocG9zdEF1dGhvcikpIHtcbiAgICAgICAgICAgIHBhcmVudFBvc3RBY2NvdW50QWRkcmVzcyA9IHB1YmtleVxuICAgICAgICAgICAgcGFyZW50UG9zdEFjY291bnQgPSBwYXJzZWRQb3N0XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+OryBGb3VuZCBwYXJlbnQgcG9zdCBJRCAke3Bvc3RJZH0gYXQgYWRkcmVzczogJHtwdWJrZXkudG9TdHJpbmcoKX1gKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXBhcmVudFBvc3RBY2NvdW50QWRkcmVzcyB8fCAhcGFyZW50UG9zdEFjY291bnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXJlbnQgcG9zdCBJRCAke3Bvc3RJZH0gYnkgYXV0aG9yICR7cG9zdEF1dGhvci50b1N0cmluZygpLnNsaWNlKDAsIDgpfSBub3QgZm91bmQgb24gYmxvY2tjaGFpbmApXG4gICAgICB9XG5cbiAgICAgIC8vIFNlY29uZCBwYXNzOiBmaW5kIHRoZSB1c2VyJ3MgcHJvZmlsZSBhY2NvdW50XG4gICAgICBjb25zb2xlLmxvZyhg8J+UjSBTZWFyY2hpbmcgZm9yIHVzZXIncyBwcm9maWxlOiAke3B1YmxpY0tleS50b1N0cmluZygpLnNsaWNlKDAsIDgpfS4uLmApXG4gICAgICBmb3IgKGNvbnN0IHsgYWNjb3VudCwgcHVia2V5IH0gb2YgYWNjb3VudHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBwYXJzZWRQcm9maWxlID0gbWFudWFsUGFyc2VQcm9maWxlKGFjY291bnQuZGF0YSlcbiAgICAgICAgICBpZiAocGFyc2VkUHJvZmlsZSAmJiBcbiAgICAgICAgICAgICAgcGFyc2VkUHJvZmlsZS5pc19pbml0aWFsaXplZCA9PT0gMSAmJiBcbiAgICAgICAgICAgICAgbmV3IFB1YmxpY0tleShwYXJzZWRQcm9maWxlLm93bmVyKS5lcXVhbHMocHVibGljS2V5KSkge1xuICAgICAgICAgICAgdXNlclByb2ZpbGVBY2NvdW50QWRkcmVzcyA9IHB1YmtleVxuICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBGb3VuZCB1c2VyIHByb2ZpbGUgYWNjb3VudDogJHtwdWJrZXkudG9TdHJpbmcoKX1gKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXVzZXJQcm9maWxlQWNjb3VudEFkZHJlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVc2VyJ3MgcHJvZmlsZSBub3QgZm91bmQgZm9yICR7cHVibGljS2V5LnRvU3RyaW5nKCkuc2xpY2UoMCwgOCl9YClcbiAgICAgIH1cblxuICAgICAgLy8gR2VuZXJhdGUgYSBuZXcga2V5cGFpciBmb3IgdGhlIGNvbW1lbnQgYWNjb3VudFxuICAgICAgY29uc3QgY29tbWVudEtleXBhaXIgPSBLZXlwYWlyLmdlbmVyYXRlKClcbiAgICAgIGNvbnNvbGUubG9nKGDwn5ONIENvbW1lbnQgYWNjb3VudDogJHtjb21tZW50S2V5cGFpci5wdWJsaWNLZXkudG9TdHJpbmcoKX1gKVxuXG4gICAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSBuZXcgQ29tbWVudE9uUG9zdEluc3RydWN0aW9uKHtcbiAgICAgICAgY29udGVudDogY29udGVudCxcbiAgICAgICAgcGFyZW50X2lkOiBCaWdJbnQocG9zdElkKSxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IGNvbW1lbnRPblBvc3RWYXJpYW50ID0gQnVmZmVyLmZyb20oWzRdKSAvLyBDb21tZW50T25Qb3N0IGluc3RydWN0aW9uIHZhcmlhbnRcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWREYXRhID0gc2VyaWFsaXplKGNvbW1lbnRPblBvc3RTY2hlbWEsIGluc3RydWN0aW9uRGF0YSlcbiAgICAgIGNvbnN0IGZ1bGxJbnN0cnVjdGlvbkRhdGEgPSBCdWZmZXIuY29uY2F0KFtjb21tZW50T25Qb3N0VmFyaWFudCwgQnVmZmVyLmZyb20oc2VyaWFsaXplZERhdGEpXSlcblxuICAgICAgY29uc29sZS5sb2coYPCflKIgSW5zdHJ1Y3Rpb24gZGF0YTogdmFyaWFudCBbNF0sIHNlcmlhbGl6ZWQgbGVuZ3RoOiAke3NlcmlhbGl6ZWREYXRhLmxlbmd0aH0sIHRvdGFsOiAke2Z1bGxJbnN0cnVjdGlvbkRhdGEubGVuZ3RofSBieXRlc2ApXG5cbiAgICAgIGNvbnN0IGluc3RydWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICBrZXlzOiBbXG4gICAgICAgICAgeyBwdWJrZXk6IHB1YmxpY0tleSwgaXNTaWduZXI6IHRydWUsIGlzV3JpdGFibGU6IHRydWUgfSwgLy8gVXNlciBhY2NvdW50IChjb21tZW50ZXIpXG4gICAgICAgICAgeyBwdWJrZXk6IGNvbW1lbnRLZXlwYWlyLnB1YmxpY0tleSwgaXNTaWduZXI6IHRydWUsIGlzV3JpdGFibGU6IHRydWUgfSwgLy8gQ29tbWVudCBhY2NvdW50ICh0byBiZSBjcmVhdGVkKVxuICAgICAgICAgIHsgcHVia2V5OiBwYXJlbnRQb3N0QWNjb3VudEFkZHJlc3MsIGlzU2lnbmVyOiBmYWxzZSwgaXNXcml0YWJsZTogdHJ1ZSB9LCAvLyBQYXJlbnQgcG9zdCBhY2NvdW50ICh0byB1cGRhdGUgY29tbWVudCBjb3VudClcbiAgICAgICAgICB7IHB1YmtleTogdXNlclByb2ZpbGVBY2NvdW50QWRkcmVzcywgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiB0cnVlIH0sIC8vIFVzZXIgcHJvZmlsZSBhY2NvdW50ICh0byB1cGRhdGUgcG9zdCBjb3VudClcbiAgICAgICAgICB7IHB1YmtleTogU3lzdGVtUHJvZ3JhbS5wcm9ncmFtSWQsIGlzU2lnbmVyOiBmYWxzZSwgaXNXcml0YWJsZTogZmFsc2UgfSwgLy8gU3lzdGVtIHByb2dyYW1cbiAgICAgICAgXSxcbiAgICAgICAgcHJvZ3JhbUlkOiBQUk9HUkFNX0lELFxuICAgICAgICBkYXRhOiBmdWxsSW5zdHJ1Y3Rpb25EYXRhLFxuICAgICAgfSlcblxuICAgICAgY29uc29sZS5sb2coJ/CflJEgVHJhbnNhY3Rpb24gYWNjb3VudHM6JylcbiAgICAgIGNvbnNvbGUubG9nKGAgIFVzZXIgKGNvbW1lbnRlcik6ICR7cHVibGljS2V5LnRvU3RyaW5nKCl9IChzaWduZXIsIHdyaXRhYmxlKWApXG4gICAgICBjb25zb2xlLmxvZyhgICBDb21tZW50OiAke2NvbW1lbnRLZXlwYWlyLnB1YmxpY0tleS50b1N0cmluZygpfSAoc2lnbmVyLCB3cml0YWJsZSlgKVxuICAgICAgY29uc29sZS5sb2coYCAgUGFyZW50IFBvc3Q6ICR7cGFyZW50UG9zdEFjY291bnRBZGRyZXNzLnRvU3RyaW5nKCl9IChub3Qgc2lnbmVyLCB3cml0YWJsZSlgKVxuICAgICAgY29uc29sZS5sb2coYCAgVXNlciBQcm9maWxlOiAke3VzZXJQcm9maWxlQWNjb3VudEFkZHJlc3MudG9TdHJpbmcoKX0gKG5vdCBzaWduZXIsIHdyaXRhYmxlKWApXG4gICAgICBjb25zb2xlLmxvZyhgICBTeXN0ZW0gUHJvZ3JhbTogJHtTeXN0ZW1Qcm9ncmFtLnByb2dyYW1JZC50b1N0cmluZygpfWApXG5cbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKGluc3RydWN0aW9uKVxuICAgICAgY29uc3QgeyBibG9ja2hhc2ggfSA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2toYXNoKCdwcm9jZXNzZWQnKVxuICAgICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoXG4gICAgICB0cmFuc2FjdGlvbi5mZWVQYXllciA9IHB1YmxpY0tleVxuXG4gICAgICAvLyBUaGUgY29tbWVudCBhY2NvdW50IG11c3Qgc2lnbiB0aGUgdHJhbnNhY3Rpb25cbiAgICAgIHRyYW5zYWN0aW9uLnBhcnRpYWxTaWduKGNvbW1lbnRLZXlwYWlyKVxuXG4gICAgICAvLyBTaW11bGF0ZSB0cmFuc2FjdGlvbiBiZWZvcmUgc2VuZGluZ1xuICAgICAgY29uc29sZS5sb2coJ/Cfjq8gU2ltdWxhdGluZyB0cmFuc2FjdGlvbi4uLicpXG4gICAgICBjb25zdCBzaW11bGF0aW9uID0gYXdhaXQgY29ubmVjdGlvbi5zaW11bGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKVxuICAgICAgY29uc29sZS5sb2coJ/Cfk4ogU2ltdWxhdGlvbiByZXN1bHQ6Jywgc2ltdWxhdGlvbilcbiAgICAgIFxuICAgICAgaWYgKHNpbXVsYXRpb24udmFsdWUuZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gc2ltdWxhdGlvbiBmYWlsZWQ6ICR7SlNPTi5zdHJpbmdpZnkoc2ltdWxhdGlvbi52YWx1ZS5lcnIpfWApXG4gICAgICB9XG4gICAgICBjb25zb2xlLmxvZygn4pyFIFRyYW5zYWN0aW9uIHNpbXVsYXRpb24gc3VjY2Vzc2Z1bCcpXG5cbiAgICAgIGNvbnNvbGUubG9nKCfwn5qAIFNlbmRpbmcgdHJhbnNhY3Rpb24uLi4nKVxuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBjb25uZWN0aW9uLCB7XG4gICAgICAgIHNraXBQcmVmbGlnaHQ6IGZhbHNlLFxuICAgICAgICBwcmVmbGlnaHRDb21taXRtZW50OiAncHJvY2Vzc2VkJyxcbiAgICAgICAgbWF4UmV0cmllczogMyxcbiAgICAgICAgc2lnbmVyczogW2NvbW1lbnRLZXlwYWlyXSwgLy8gQ29tbWVudCBrZXlwYWlyIG11c3Qgc2lnbiB0aGUgdHJhbnNhY3Rpb25cbiAgICAgIH0pXG5cbiAgICAgIGNvbnNvbGUubG9nKGDwn5OLIFRyYW5zYWN0aW9uIHNlbnQgd2l0aCBzaWduYXR1cmU6ICR7c2lnbmF0dXJlfWApXG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCfij7MgQ29uZmlybWluZyB0cmFuc2FjdGlvbi4uLicpXG4gICAgICBhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbih7XG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgYmxvY2toYXNoLFxuICAgICAgICBsYXN0VmFsaWRCbG9ja0hlaWdodDogKGF3YWl0IGNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2toYXNoKCkpLmxhc3RWYWxpZEJsb2NrSGVpZ2h0LFxuICAgICAgfSwgJ3Byb2Nlc3NlZCcpXG5cbiAgICAgIGNvbnNvbGUubG9nKCfinIUgVHJhbnNhY3Rpb24gY29uZmlybWVkISBDb21tZW50IGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5IScpXG4gICAgICBcbiAgICAgIC8vIFRyYWNrIHRoaXMgY29tbWVudCBhY2NvdW50IHNvIHdlIGNhbiBkaXN0aW5ndWlzaCBpdCBmcm9tIHJlZ3VsYXIgcG9zdHNcbiAgICAgIHRyYWNrQ29tbWVudEFjY291bnQoY29tbWVudEtleXBhaXIucHVibGljS2V5LnRvU3RyaW5nKCksIHBvc3RJZClcbiAgICAgIFxuICAgICAgLy8gQ2xlYXIgcG9zdHMgY2FjaGUgdG8gZm9yY2UgcmVmcmVzaFxuICAgICAgcG9zdHNDYWNoZSA9IG51bGxcbiAgICAgIFxuICAgICAgLy8gQWxzbyBzdG9yZSBjb21tZW50IGxvY2FsbHkgZm9yIGltbWVkaWF0ZSBkaXNwbGF5XG4gICAgICBjb25zdCBjb21tZW50OiBDb21tZW50ID0ge1xuICAgICAgICBpZDogRGF0ZS5ub3coKSxcbiAgICAgICAgcGFyZW50UG9zdElkOiBwb3N0SWQsXG4gICAgICAgIGF1dGhvcjogcHVibGljS2V5LFxuICAgICAgICBjb250ZW50OiBjb250ZW50LFxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgIGxpa2VzOiAwLFxuICAgICAgICBhdXRob3JQcm9maWxlOiB1c2VyUHJvZmlsZVxuICAgICAgfVxuICAgICAgXG4gICAgICBzdG9yZUNvbW1lbnQocG9zdElkLCBjb21tZW50KVxuICAgICAgXG4gICAgICB0b2FzdC5zdWNjZXNzKCdDb21tZW50IHBvc3RlZCEnKVxuICAgICAgcmV0dXJuIHNpZ25hdHVyZVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBDb21tZW50IGNyZWF0aW9uIGVycm9yOicsIGVycm9yKVxuICAgICAgXG4gICAgICAvLyBNb3JlIHNwZWNpZmljIGVycm9yIG1lc3NhZ2VzXG4gICAgICBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ2luc3VmZmljaWVudCBmdW5kcycpKSB7XG4gICAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBjaGVja1NPTEJhbGFuY2UoKVxuICAgICAgICB0b2FzdC5lcnJvcihgSW5zdWZmaWNpZW50IFNPTDogJHtiYWxhbmNlLnRvRml4ZWQoNCl9IFNPTC4gTmVlZCBhdCBsZWFzdCAwLjA1IFNPTCBmb3IgZmVlcyBhbmQgYWNjb3VudCBjcmVhdGlvbi5gKVxuICAgICAgfSBlbHNlIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnc2ltdWxhdGlvbiBmYWlsZWQnKSkge1xuICAgICAgICB0b2FzdC5lcnJvcignVHJhbnNhY3Rpb24gd291bGQgZmFpbDogQ2hlY2sgcG9zdCBleGlzdHMgYW5kIHdhbGxldCBoYXMgcGVybWlzc2lvbicpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1NpbXVsYXRpb24gZXJyb3IgZGV0YWlsczonLCBlcnJvci5tZXNzYWdlKVxuICAgICAgfSBlbHNlIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnbm90IGZvdW5kIG9uIGJsb2NrY2hhaW4nKSkge1xuICAgICAgICB0b2FzdC5lcnJvcignUG9zdCBub3QgZm91bmQgb24gYmxvY2tjaGFpbicpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b2FzdC5lcnJvcihgRmFpbGVkIHRvIGNvbW1lbnQ6ICR7ZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YClcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvLyBCb29rbWFyayBQb3N0ICh1c2luZyBsb2NhbFN0b3JhZ2Ugc2luY2Ugd2UgZG9uJ3QgaGF2ZSBib29rbWFyayBmdW5jdGlvbmFsaXR5KVxuICBjb25zdCBib29rbWFya1Bvc3QgPSBhc3luYyAocG9zdElkOiBudW1iZXIpID0+IHtcbiAgICBpZiAoIXB1YmxpY0tleSkgdGhyb3cgbmV3IEVycm9yKCdXYWxsZXQgbm90IGNvbm5lY3RlZCcpXG5cbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYPCflJYgQm9va21hcmtpbmcgcG9zdCBJRCAke3Bvc3RJZH0uLi5gKVxuICAgICAgXG4gICAgICBjb25zdCBib29rbWFya3NLZXkgPSBgYm9va21hcmtzXyR7cHVibGljS2V5LnRvU3RyaW5nKCl9YFxuICAgICAgY29uc3QgZXhpc3RpbmdCb29rbWFya3MgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShib29rbWFya3NLZXkpXG4gICAgICBjb25zdCBib29rbWFya3M6IG51bWJlcltdID0gZXhpc3RpbmdCb29rbWFya3MgPyBKU09OLnBhcnNlKGV4aXN0aW5nQm9va21hcmtzKSA6IFtdXG4gICAgICBcbiAgICAgIGlmIChib29rbWFya3MuaW5jbHVkZXMocG9zdElkKSkge1xuICAgICAgICAvLyBSZW1vdmUgYm9va21hcmtcbiAgICAgICAgY29uc3QgdXBkYXRlZEJvb2ttYXJrcyA9IGJvb2ttYXJrcy5maWx0ZXIoaWQgPT4gaWQgIT09IHBvc3RJZClcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oYm9va21hcmtzS2V5LCBKU09OLnN0cmluZ2lmeSh1cGRhdGVkQm9va21hcmtzKSlcbiAgICAgICAgdG9hc3Quc3VjY2VzcygnQm9va21hcmsgcmVtb3ZlZCEnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQWRkIGJvb2ttYXJrXG4gICAgICAgIGJvb2ttYXJrcy5wdXNoKHBvc3RJZClcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oYm9va21hcmtzS2V5LCBKU09OLnN0cmluZ2lmeShib29rbWFya3MpKVxuICAgICAgICB0b2FzdC5zdWNjZXNzKCdQb3N0IGJvb2ttYXJrZWQhJylcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuICdib29rbWFya2VkJ1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBCb29rbWFyayBlcnJvcjonLCBlcnJvcilcbiAgICAgIHRvYXN0LmVycm9yKCdGYWlsZWQgdG8gYm9va21hcmsgcG9zdCcpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8vIEdldCB1c2VyIGJvb2ttYXJrc1xuICBjb25zdCBnZXRVc2VyQm9va21hcmtzID0gKCk6IG51bWJlcltdID0+IHtcbiAgICBpZiAoIXB1YmxpY0tleSkgcmV0dXJuIFtdXG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGJvb2ttYXJrc0tleSA9IGBib29rbWFya3NfJHtwdWJsaWNLZXkudG9TdHJpbmcoKX1gXG4gICAgICBjb25zdCBleGlzdGluZ0Jvb2ttYXJrcyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGJvb2ttYXJrc0tleSlcbiAgICAgIHJldHVybiBleGlzdGluZ0Jvb2ttYXJrcyA/IEpTT04ucGFyc2UoZXhpc3RpbmdCb29rbWFya3MpIDogW11cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGdldCBib29rbWFya3M6JywgZXJyb3IpXG4gICAgICByZXR1cm4gW11cbiAgICB9XG4gIH1cblxuICAvLyBDaGVjayBpZiBwb3N0IGlzIGJvb2ttYXJrZWRcbiAgY29uc3QgaXNQb3N0Qm9va21hcmtlZCA9IChwb3N0SWQ6IG51bWJlcik6IGJvb2xlYW4gPT4ge1xuICAgIGNvbnN0IGJvb2ttYXJrcyA9IGdldFVzZXJCb29rbWFya3MoKVxuICAgIHJldHVybiBib29rbWFya3MuaW5jbHVkZXMocG9zdElkKVxuICB9XG5cbiAgLy8gVXRpbGl0eSBmdW5jdGlvbiB0byBwcmVsb2FkIHByb2ZpbGUgb24gd2FsbGV0IGNvbm5lY3Rpb25cbiAgY29uc3QgcHJlbG9hZFByb2ZpbGUgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFwdWJsaWNLZXkpIHJldHVyblxuICAgIFxuICAgIGNvbnNvbGUubG9nKCfwn5qAIFByZWxvYWRpbmcgcHJvZmlsZSBvbiB3YWxsZXQgY29ubmVjdGlvbi4uLicpXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGdldFByb2ZpbGUocHVibGljS2V5KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBwcmVsb2FkIHByb2ZpbGU6JywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gRm9yY2UgcmVmcmVzaCBhbGwgZGF0YSAtIGNsZWFycyBhbGwgY2FjaGVzXG4gIGNvbnN0IHJlZnJlc2hEYXRhID0gKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCfwn5SEIEZvcmNlIHJlZnJlc2hpbmcgYWxsIGRhdGEuLi4nKVxuICAgIGNsZWFyUHJvZmlsZUNhY2hlKClcbiAgICBwb3N0c0NhY2hlID0gbnVsbFxuICAgIC8vIENsZWFyIGNvbW1lbnRzIHN0b3JhZ2VcbiAgICBjb21tZW50c1N0b3JhZ2UgPSB7fVxuICAgIC8vIENsZWFyIGNvbW1lbnQgdHJhY2tpbmcgZGF0YVxuICAgIHRyeSB7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShnZXRDb21tZW50QWNjb3VudHNLZXkoKSlcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGdldENvbW1lbnRNYXBwaW5nS2V5KCkpXG4gICAgICBjb25zb2xlLmxvZygn8J+Xke+4jyBDbGVhcmVkIGNvbW1lbnQgdHJhY2tpbmcgZGF0YScpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjbGVhciBjb21tZW50IHRyYWNraW5nIGRhdGE6JywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gRm9yY2UgcmVmcmVzaCBhIHNwZWNpZmljIHVzZXIncyBwcm9maWxlICh1c2VmdWwgYWZ0ZXIgZm9sbG93L3VuZm9sbG93KVxuICBjb25zdCByZWZyZXNoVXNlclByb2ZpbGUgPSBhc3luYyAodXNlclB1YmxpY0tleTogUHVibGljS2V5KSA9PiB7XG4gICAgY29uc29sZS5sb2coYPCflIQgRm9yY2UgcmVmcmVzaGluZyBwcm9maWxlIGZvcjogJHt1c2VyUHVibGljS2V5LnRvU3RyaW5nKCkuc2xpY2UoMCwgOCl9YClcbiAgICBcbiAgICAvLyBDbGVhciBhbGwgY2FjaGVzIGZvciB0aGlzIHVzZXJcbiAgICBjbGVhclByb2ZpbGVDYWNoZSh1c2VyUHVibGljS2V5LnRvU3RyaW5nKCkpXG4gICAgXG4gICAgLy8gRm9yY2UgZmV0Y2ggZnJlc2ggZGF0YSBmcm9tIGJsb2NrY2hhaW5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZnJlc2hQcm9maWxlID0gYXdhaXQgZ2V0UHJvZmlsZSh1c2VyUHVibGljS2V5KVxuICAgICAgY29uc29sZS5sb2coYOKchSBSZWZyZXNoZWQgcHJvZmlsZSBmb3IgJHt1c2VyUHVibGljS2V5LnRvU3RyaW5nKCkuc2xpY2UoMCwgOCl9OmAsIHtcbiAgICAgICAgdXNlcm5hbWU6IGZyZXNoUHJvZmlsZT8udXNlcm5hbWUsXG4gICAgICAgIGZvbGxvd2Vyc0NvdW50OiBmcmVzaFByb2ZpbGU/LmZvbGxvd2Vyc0NvdW50LFxuICAgICAgICBmb2xsb3dpbmdDb3VudDogZnJlc2hQcm9maWxlPy5mb2xsb3dpbmdDb3VudFxuICAgICAgfSlcbiAgICAgIHJldHVybiBmcmVzaFByb2ZpbGVcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHJlZnJlc2ggdXNlciBwcm9maWxlOicsIGVycm9yKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICAvLyBDaGVjayBpZiB1c2VyIGlzIGZvbGxvd2luZyBhbm90aGVyIHVzZXIgLSBoeWJyaWQgYXBwcm9hY2hcbiAgY29uc3QgaXNGb2xsb3dpbmdVc2VyID0gYXN5bmMgKGZvbGxvd2VyUHVibGljS2V5OiBQdWJsaWNLZXksIHRhcmdldFB1YmxpY0tleTogUHVibGljS2V5KTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIENoZWNraW5nIGZvbGxvdyBzdGF0ZTogJHtmb2xsb3dlclB1YmxpY0tleS50b1N0cmluZygpLnNsaWNlKDAsIDgpfSAtPiAke3RhcmdldFB1YmxpY0tleS50b1N0cmluZygpLnNsaWNlKDAsIDgpfWApXG4gICAgICBcbiAgICAgIC8vIEZpcnN0IGNoZWNrIGxvY2FsU3RvcmFnZSBmb3IgaW1tZWRpYXRlIGZlZWRiYWNrXG4gICAgICBjb25zdCBsb2NhbFN0b3JhZ2VLZXkgPSBgdXNlcl9mb2xsb3dzXyR7Zm9sbG93ZXJQdWJsaWNLZXkudG9TdHJpbmcoKX1gXG4gICAgICBjb25zdCBzdG9yZWRGb2xsb3dzID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0obG9jYWxTdG9yYWdlS2V5KVxuICAgICAgY29uc3QgZm9sbG93c0xpc3QgPSBzdG9yZWRGb2xsb3dzID8gSlNPTi5wYXJzZShzdG9yZWRGb2xsb3dzKSA6IFtdXG4gICAgICBjb25zdCBpc0ZvbGxvd2luZ0luTG9jYWxTdG9yYWdlID0gZm9sbG93c0xpc3QuaW5jbHVkZXModGFyZ2V0UHVibGljS2V5LnRvU3RyaW5nKCkpXG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OxIGxvY2FsU3RvcmFnZSBjaGVjazogJHtpc0ZvbGxvd2luZ0luTG9jYWxTdG9yYWdlfWApXG4gICAgICBcbiAgICAgIC8vIEdldCBib3RoIHByb2ZpbGVzIHRvIGNoZWNrIGZvbGxvdyBjb3VudHNcbiAgICAgIGNvbnN0IFtmb2xsb3dlclByb2ZpbGUsIHRhcmdldFByb2ZpbGVdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBnZXRQcm9maWxlKGZvbGxvd2VyUHVibGljS2V5KSxcbiAgICAgICAgZ2V0UHJvZmlsZSh0YXJnZXRQdWJsaWNLZXkpXG4gICAgICBdKVxuICAgICAgXG4gICAgICBpZiAoIWZvbGxvd2VyUHJvZmlsZSB8fCAhdGFyZ2V0UHJvZmlsZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhg4p2MIE9uZSBvciBib3RoIHByb2ZpbGVzIG5vdCBmb3VuZGApXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhg8J+TiiBGb2xsb3dlciBcIiR7Zm9sbG93ZXJQcm9maWxlLnVzZXJuYW1lfVwiIGZvbGxvd2luZzogJHtmb2xsb3dlclByb2ZpbGUuZm9sbG93aW5nQ291bnR9YClcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OKIFRhcmdldCBcIiR7dGFyZ2V0UHJvZmlsZS51c2VybmFtZX1cIiBmb2xsb3dlcnM6ICR7dGFyZ2V0UHJvZmlsZS5mb2xsb3dlcnNDb3VudH1gKVxuICAgICAgXG4gICAgICAvLyBJZiBsb2NhbFN0b3JhZ2Ugc2F5cyBmb2xsb3dpbmcgYW5kIGJvdGggaGF2ZSBub24temVybyBjb3VudHMsIGxpa2VseSBmb2xsb3dpbmdcbiAgICAgIGlmIChpc0ZvbGxvd2luZ0luTG9jYWxTdG9yYWdlICYmIGZvbGxvd2VyUHJvZmlsZS5mb2xsb3dpbmdDb3VudCA+IDAgJiYgdGFyZ2V0UHJvZmlsZS5mb2xsb3dlcnNDb3VudCA+IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coYOKchSBDb25maXJtZWQgZm9sbG93aW5nIHZpYSBsb2NhbFN0b3JhZ2UgKyBibG9ja2NoYWluIGNvdW50c2ApXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIElmIGxvY2FsU3RvcmFnZSBzYXlzIG5vdCBmb2xsb3dpbmcsIHRydXN0IHRoYXRcbiAgICAgIGlmICghaXNGb2xsb3dpbmdJbkxvY2FsU3RvcmFnZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhg4p2MIE5vdCBmb2xsb3dpbmcgYWNjb3JkaW5nIHRvIGxvY2FsU3RvcmFnZWApXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBGYWxsYmFjazogaWYgbG9jYWxTdG9yYWdlIGlzIGluY29uc2lzdGVudCwgZGVmYXVsdCB0byBmYWxzZSB0byBwcmV2ZW50IGRvdWJsZSBmb2xsb3dzXG4gICAgICBjb25zb2xlLmxvZyhg4pqg77iPIEluY29uc2lzdGVudCBzdGF0ZSwgZGVmYXVsdGluZyB0byBub3QgZm9sbG93aW5nYClcbiAgICAgIHJldHVybiBmYWxzZVxuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIGZvbGxvdyBzdGF0ZTonLCBlcnJvcilcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY3JlYXRlUHJvZmlsZSxcbiAgICBjcmVhdGVQb3N0LFxuICAgIGxpa2VQb3N0LFxuICAgIHVubGlrZVBvc3QsXG4gICAgZ2V0UHJvZmlsZSxcbiAgICBnZXRQcm9maWxlQnlVc2VybmFtZSxcbiAgICBnZXRQb3N0cyxcbiAgICBnZXRQcm9maWxlUERBLFxuICAgIGdldFBvc3RQREEsXG4gICAgY2hlY2tQcm9maWxlQXRQREEsXG4gICAgcHJlbG9hZFByb2ZpbGUsXG4gICAgY2xlYXJQcm9maWxlQ2FjaGUsXG4gICAgcmVmcmVzaERhdGEsXG4gICAgcmVmcmVzaFVzZXJQcm9maWxlLFxuICAgIGNyZWF0ZUNvbW11bml0eSxcbiAgICBmb2xsb3dQcm9maWxlLFxuICAgIHVuZm9sbG93UHJvZmlsZSxcbiAgICB1cGRhdGVQcm9maWxlLFxuICAgIGNvbW1lbnRPblBvc3QsXG4gICAgYm9va21hcmtQb3N0LFxuICAgIGdldFVzZXJCb29rbWFya3MsXG4gICAgaXNQb3N0Qm9va21hcmtlZCxcbiAgICBnZXRDb21tZW50c0ZvclBvc3QsXG4gICAgaGFzVXNlckxpa2VkUG9zdDogKHBvc3RJZDogbnVtYmVyKSA9PiBwdWJsaWNLZXkgPyBoYXNVc2VyTGlrZWRQb3N0KHB1YmxpY0tleS50b1N0cmluZygpLCBwb3N0SWQpIDogZmFsc2UsXG4gICAgZ2V0VXNlckxpa2VkUG9zdHM6ICgpID0+IHB1YmxpY0tleSA/IGdldFVzZXJMaWtlZFBvc3RzKHB1YmxpY0tleS50b1N0cmluZygpKSA6IFtdLFxuICAgIGdldFVzZXJGb2xsb3dlZFByb2ZpbGVzOiAoKSA9PiBwdWJsaWNLZXkgPyBnZXRVc2VyRm9sbG93ZWRQcm9maWxlcyhwdWJsaWNLZXkudG9TdHJpbmcoKSkgOiBbXSxcbiAgICBhZGRVc2VyRm9sbG93OiAocHJvZmlsZU93bmVyS2V5OiBzdHJpbmcpID0+IHB1YmxpY0tleSA/IGFkZFVzZXJGb2xsb3cocHVibGljS2V5LnRvU3RyaW5nKCksIHByb2ZpbGVPd25lcktleSkgOiBudWxsLFxuICAgIHJlbW92ZVVzZXJGb2xsb3c6IChwcm9maWxlT3duZXJLZXk6IHN0cmluZykgPT4gcHVibGljS2V5ID8gcmVtb3ZlVXNlckZvbGxvdyhwdWJsaWNLZXkudG9TdHJpbmcoKSwgcHJvZmlsZU93bmVyS2V5KSA6IG51bGwsXG4gICAgaXNVc2VyRm9sbG93aW5nUHJvZmlsZTogKHByb2ZpbGVPd25lcktleTogc3RyaW5nKSA9PiBwdWJsaWNLZXkgPyBpc1VzZXJGb2xsb3dpbmdQcm9maWxlKHB1YmxpY0tleS50b1N0cmluZygpLCBwcm9maWxlT3duZXJLZXkpIDogZmFsc2UsXG4gICAgaXNGb2xsb3dpbmdVc2VyOiAoZm9sbG93ZXJQdWJsaWNLZXk6IFB1YmxpY0tleSwgdGFyZ2V0UHVibGljS2V5OiBQdWJsaWNLZXkpID0+IHB1YmxpY0tleSA/IGlzRm9sbG93aW5nVXNlcihmb2xsb3dlclB1YmxpY0tleSwgdGFyZ2V0UHVibGljS2V5KSA6IGZhbHNlLFxuICB9XG59Il0sIm5hbWVzIjpbInVzZUNvbm5lY3Rpb24iLCJ1c2VXYWxsZXQiLCJQdWJsaWNLZXkiLCJUcmFuc2FjdGlvbiIsIlRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24iLCJTeXN0ZW1Qcm9ncmFtIiwiTEFNUE9SVFNfUEVSX1NPTCIsIktleXBhaXIiLCJzZXJpYWxpemUiLCJkZXNlcmlhbGl6ZSIsInRvYXN0IiwiY29uZmlnIiwiUFJPR1JBTV9JRCIsInNvbGFuYSIsInByb2dyYW1JZCIsIkRFQlVHX01PREUiLCJwcm9jZXNzIiwiQ29udHJhY3RJbnN0cnVjdGlvbiIsIlBvc3RSYXRpbmciLCJDcmVhdGVQcm9maWxlSW5zdHJ1Y3Rpb24iLCJjb25zdHJ1Y3RvciIsImZpZWxkcyIsInVzZXJuYW1lIiwiYmlvIiwicHJvZmlsZV9pbWFnZSIsImNvdmVyX2ltYWdlIiwiQ3JlYXRlUG9zdEluc3RydWN0aW9uIiwiY29udGVudCIsImltYWdlcyIsIkxpa2VQb3N0SW5zdHJ1Y3Rpb24iLCJwb3N0X2lkIiwiQ29tbWVudE9uUG9zdEluc3RydWN0aW9uIiwicGFyZW50X2lkIiwiQm9va21hcmtQb3N0SW5zdHJ1Y3Rpb24iLCJQcm9maWxlQWNjb3VudCIsImlzX2luaXRpYWxpemVkIiwib3duZXIiLCJjcmVhdGVkX2F0IiwiZm9sbG93ZXJzX2NvdW50IiwiZm9sbG93aW5nX2NvdW50IiwidXNlcl9jcmVkaXRfcmF0aW5nIiwicG9zdHNfY291bnQiLCJsYXN0X3Bvc3RfdGltZXN0YW1wIiwiZGFpbHlfcG9zdF9jb3VudCIsImlzX3ZlcmlmaWVkIiwiUG9zdEFjY291bnQiLCJpZCIsImF1dGhvciIsInRpbWVzdGFtcCIsImxpa2VzIiwiY29tbWVudHMiLCJtaXJyb3JzIiwicmF0aW5nIiwiaW5fa2lsbF96b25lIiwiY3JlYXRlUHJvZmlsZVNjaGVtYSIsIk1hcCIsImtpbmQiLCJjcmVhdGVQb3N0U2NoZW1hIiwibGlrZVBvc3RTY2hlbWEiLCJjb21tZW50T25Qb3N0U2NoZW1hIiwiYm9va21hcmtQb3N0U2NoZW1hIiwicHJvZmlsZUFjY291bnRTY2hlbWEiLCJwb3N0QWNjb3VudFNjaGVtYSIsIkNvbW11bml0eUFjY291bnQiLCJjcmVhdG9yIiwibmFtZSIsImRlc2NyaXB0aW9uIiwiYXZhdGFyIiwicnVsZXMiLCJtZW1iZXJfY291bnQiLCJpc19wcml2YXRlIiwiQ3JlYXRlQ29tbXVuaXR5SW5zdHJ1Y3Rpb24iLCJGb2xsb3dQcm9maWxlSW5zdHJ1Y3Rpb24iLCJwdWJsaWNLZXkiLCJwcm9maWxlX2lkIiwiRXJyb3IiLCJ0b0J1ZmZlciIsImNyZWF0ZUNvbW11bml0eVNjaGVtYSIsImZvbGxvd1Byb2ZpbGVTY2hlbWEiLCJjb21tdW5pdHlBY2NvdW50U2NoZW1hIiwicHJvZmlsZUNhY2hlIiwiQ0FDSEVfRFVSQVRJT04iLCJwb3N0c0NhY2hlIiwiUE9TVFNfQ0FDSEVfRFVSQVRJT04iLCJMT0NBTFNUT1JBR0VfQ0FDSEVfUFJFRklYIiwiTE9DQUxTVE9SQUdFX0NBQ0hFX0RVUkFUSU9OIiwic2F2ZVByb2ZpbGVUb0xvY2FsU3RvcmFnZSIsIndhbGxldEFkZHJlc3MiLCJwcm9maWxlIiwiY2FjaGVLZXkiLCJjYWNoZURhdGEiLCJEYXRlIiwibm93IiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJjb25zb2xlIiwibG9nIiwic2xpY2UiLCJlcnJvciIsIndhcm4iLCJnZXRQcm9maWxlRnJvbUxvY2FsU3RvcmFnZSIsImNhY2hlZCIsImdldEl0ZW0iLCJwYXJzZSIsInJlbW92ZUl0ZW0iLCJjbGVhclByb2ZpbGVDYWNoZSIsImRlbGV0ZSIsImNsZWFyIiwia2V5cyIsIk9iamVjdCIsImZvckVhY2giLCJrZXkiLCJzdGFydHNXaXRoIiwiY29tbWVudHNTdG9yYWdlIiwiZ2V0Q29tbWVudEFjY291bnRzS2V5IiwiZ2V0Q29tbWVudE1hcHBpbmdLZXkiLCJ0cmFja0NvbW1lbnRBY2NvdW50IiwiY29tbWVudEFjY291bnRBZGRyZXNzIiwicGFyZW50UG9zdElkIiwiY29tbWVudEFjY291bnRzS2V5IiwiZXhpc3RpbmdBY2NvdW50cyIsImNvbW1lbnRBY2NvdW50cyIsImluY2x1ZGVzIiwicHVzaCIsIm1hcHBpbmdLZXkiLCJleGlzdGluZ01hcHBpbmciLCJjb21tZW50TWFwcGluZyIsImlzQ29tbWVudEFjY291bnQiLCJhY2NvdW50QWRkcmVzcyIsImdldFBhcmVudFBvc3RJZCIsImdldFVzZXJMaWtlc0tleSIsImdldFVzZXJMaWtlZFBvc3RzIiwibGlrZXNLZXkiLCJleGlzdGluZ0xpa2VzIiwiYWRkVXNlckxpa2UiLCJwb3N0SWQiLCJyZW1vdmVVc2VyTGlrZSIsInVwZGF0ZWRMaWtlcyIsImZpbHRlciIsImhhc1VzZXJMaWtlZFBvc3QiLCJ1c2VyTGlrZXMiLCJnZXRVc2VyRm9sbG93c0tleSIsImdldFVzZXJGb2xsb3dlZFByb2ZpbGVzIiwiZm9sbG93c0tleSIsImV4aXN0aW5nRm9sbG93cyIsImFkZFVzZXJGb2xsb3ciLCJwcm9maWxlT3duZXJLZXkiLCJyZW1vdmVVc2VyRm9sbG93IiwidXBkYXRlZEZvbGxvd3MiLCJpc1VzZXJGb2xsb3dpbmdQcm9maWxlIiwidXNlckZvbGxvd3MiLCJpc0ZvbGxvd2luZyIsInVzZUJsb2Nrc1Byb2dyYW0iLCJjb25uZWN0aW9uIiwic2VuZFRyYW5zYWN0aW9uIiwiZ2V0UHJvZmlsZVBEQSIsInVzZXJQdWJsaWNLZXkiLCJwcm9maWxlUERBIiwiZmluZFByb2dyYW1BZGRyZXNzIiwiQnVmZmVyIiwiZnJvbSIsImdldFBvc3RQREEiLCJwb3N0UERBIiwidG9TdHJpbmciLCJjaGVja1Byb2dyYW1FeGlzdHMiLCJwcm9ncmFtSW5mbyIsImdldEFjY291bnRJbmZvIiwiZXhlY3V0YWJsZSIsImNoZWNrU09MQmFsYW5jZSIsImJhbGFuY2UiLCJnZXRCYWxhbmNlIiwiY29udmVydFByb2ZpbGVBY2NvdW50IiwicHJvZmlsZUFjY291bnQiLCJjYWxjdWxhdGVVQ1IiLCJwb3N0c0NvdW50IiwiTnVtYmVyIiwiZm9sbG93ZXJzQ291bnQiLCJmb2xsb3dpbmdDb3VudCIsInVjciIsInBvc3RzU2NvcmUiLCJNYXRoIiwibWluIiwiZm9sbG93ZXJzU2NvcmUiLCJyYXRpb0JvbnVzIiwicmF0aW8iLCJhY2NvdW50QWdlIiwiZGF5c09sZCIsImFnZUJvbnVzIiwidmVyaWZpY2F0aW9uQm9udXMiLCJsYXN0UG9zdEFnZSIsImRheXNTaW5jZUxhc3RQb3N0IiwiYWN0aXZpdHlCb251cyIsImlzSW5pdGlhbGl6ZWQiLCJwcm9maWxlSW1hZ2UiLCJjb3ZlckltYWdlIiwiY3JlYXRlZEF0IiwidXNlckNyZWRpdFJhdGluZyIsImxhc3RQb3N0VGltZXN0YW1wIiwiZGFpbHlQb3N0Q291bnQiLCJpc1ZlcmlmaWVkIiwiY29udmVydFBvc3RBY2NvdW50IiwicG9zdEFjY291bnQiLCJpbktpbGxab25lIiwiY3JlYXRlUHJvZmlsZSIsInByb2dyYW1FeGlzdHMiLCJuZXR3b3JrIiwiaW5zdHJ1Y3Rpb25EYXRhIiwiY3JlYXRlUHJvZmlsZVZhcmlhbnQiLCJzZXJpYWxpemVkRGF0YSIsImZ1bGxJbnN0cnVjdGlvbkRhdGEiLCJjb25jYXQiLCJpbnN0cnVjdGlvbiIsInB1YmtleSIsImlzU2lnbmVyIiwiaXNXcml0YWJsZSIsImRhdGEiLCJ0cmFuc2FjdGlvbiIsImFkZCIsImJsb2NraGFzaCIsImdldExhdGVzdEJsb2NraGFzaCIsInJlY2VudEJsb2NraGFzaCIsImZlZVBheWVyIiwic2ltdWxhdGlvbiIsInNpbXVsYXRlVHJhbnNhY3Rpb24iLCJ2YWx1ZSIsImVyciIsInNpZ25hdHVyZSIsInNraXBQcmVmbGlnaHQiLCJwcmVmbGlnaHRDb21taXRtZW50IiwibWF4UmV0cmllcyIsImNvbmZpcm1UcmFuc2FjdGlvbiIsImxhc3RWYWxpZEJsb2NrSGVpZ2h0Iiwic3VjY2VzcyIsIm1lc3NhZ2UiLCJnZXRQcm9maWxlIiwiY2FjaGVkUHJvZmlsZSIsInNldCIsInNldFRpbWVvdXQiLCJoYXMiLCJnZXQiLCJhY2NvdW50cyIsImdldFByb2dyYW1BY2NvdW50cyIsImxlbmd0aCIsInByb2ZpbGVzRm91bmQiLCJhY2NvdW50IiwibWFudWFsUGFyc2VQcm9maWxlIiwiYWNjb3VudE93bmVyIiwiZXF1YWxzIiwiZ2V0UHJvZmlsZUJ5VXNlcm5hbWUiLCJhY2NvdW50SW5mbyIsImdldFBvc3RzIiwicG9zdHMiLCJtYW51YWxQYXJzZVBvc3QiLCJwb3N0Iiwic3Vic3RyaW5nIiwic29ydCIsImEiLCJiIiwiZ2V0Q29tbWVudHNGb3JQb3N0IiwiYXV0aG9yUHVibGljS2V5IiwiYXV0aG9yUHJvZmlsZSIsImNvbW1lbnQiLCJtZW1vcnlDb21tZW50cyIsImFsbENvbW1lbnRzIiwibWVtb3J5Q29tbWVudCIsImV4aXN0cyIsInNvbWUiLCJjIiwiYWJzIiwic3RvcmVDb21tZW50IiwiY3JlYXRlUG9zdCIsInVzZXJQcm9maWxlIiwicG9zdEtleXBhaXIiLCJnZW5lcmF0ZSIsInVzZXJQcm9maWxlUERBIiwiY3JlYXRlUG9zdFZhcmlhbnQiLCJtYXAiLCJrIiwicGFydGlhbFNpZ24iLCJzaWduZXJzIiwidG9GaXhlZCIsImxpa2VQb3N0IiwicG9zdEF1dGhvciIsInBvc3RBY2NvdW50QWRkcmVzcyIsImF1dGhvclByb2ZpbGVBZGRyZXNzIiwicGFyc2VkUG9zdCIsInBhcnNlZFByb2ZpbGUiLCJCaWdJbnQiLCJsaWtlUG9zdFZhcmlhbnQiLCJ1bmxpa2VQb3N0IiwiY2hlY2tQcm9maWxlQXRQREEiLCJwZGFBZGRyZXNzIiwicGRhIiwiQXJyYXkiLCJvZmZzZXQiLCJ1c2VybmFtZUxlbmd0aCIsInJlYWRVSW50MzJMRSIsImJpb0xlbmd0aCIsInByb2ZpbGVJbWFnZUxlbmd0aCIsImNvdmVySW1hZ2VMZW5ndGgiLCJyZWFkQmlnVUludDY0TEUiLCJyZWFkQmlnSW50NjRMRSIsIlVpbnQ4QXJyYXkiLCJjb250ZW50TGVuZ3RoIiwiaW1hZ2VzTGVuZ3RoIiwiaSIsImltYWdlTGVuZ3RoIiwiaW1hZ2UiLCJjb252ZXJ0Q29tbXVuaXR5QWNjb3VudCIsImNvbW11bml0eUFjY291bnQiLCJtZW1iZXJDb3VudCIsImlzUHJpdmF0ZSIsImNyZWF0ZUNvbW11bml0eSIsImNvbW11bml0eUtleXBhaXIiLCJjcmVhdGVDb21tdW5pdHlWYXJpYW50IiwiZm9sbG93UHJvZmlsZSIsInByb2ZpbGVQdWJsaWNLZXkiLCJ0YXJnZXRPd25lcktleSIsInRhcmdldFByb2ZpbGVBZGRyZXNzIiwiZm9sbG93ZXJQcm9maWxlQWRkcmVzcyIsInByb2ZpbGVPd25lciIsImZvbGxvd1Byb2ZpbGVWYXJpYW50IiwidGFyZ2V0QWNjb3VudEluZm8iLCJmb2xsb3dlckFjY291bnRJbmZvIiwidW5mb2xsb3dQcm9maWxlIiwidGFyZ2V0UHJvZmlsZUtleSIsInVuZm9sbG93UHJvZmlsZVZhcmlhbnQiLCJ1cGRhdGVQcm9maWxlIiwidXBkYXRlUHJvZmlsZVZhcmlhbnQiLCJjb21tZW50T25Qb3N0IiwicGFyZW50UG9zdEFjY291bnRBZGRyZXNzIiwicGFyZW50UG9zdEFjY291bnQiLCJ1c2VyUHJvZmlsZUFjY291bnRBZGRyZXNzIiwiY29tbWVudEtleXBhaXIiLCJjb21tZW50T25Qb3N0VmFyaWFudCIsImJvb2ttYXJrUG9zdCIsImJvb2ttYXJrc0tleSIsImV4aXN0aW5nQm9va21hcmtzIiwiYm9va21hcmtzIiwidXBkYXRlZEJvb2ttYXJrcyIsImdldFVzZXJCb29rbWFya3MiLCJpc1Bvc3RCb29rbWFya2VkIiwicHJlbG9hZFByb2ZpbGUiLCJyZWZyZXNoRGF0YSIsInJlZnJlc2hVc2VyUHJvZmlsZSIsImZyZXNoUHJvZmlsZSIsImlzRm9sbG93aW5nVXNlciIsImZvbGxvd2VyUHVibGljS2V5IiwidGFyZ2V0UHVibGljS2V5IiwibG9jYWxTdG9yYWdlS2V5Iiwic3RvcmVkRm9sbG93cyIsImZvbGxvd3NMaXN0IiwiaXNGb2xsb3dpbmdJbkxvY2FsU3RvcmFnZSIsImZvbGxvd2VyUHJvZmlsZSIsInRhcmdldFByb2ZpbGUiLCJQcm9taXNlIiwiYWxsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useBlocksProgram.ts\n"));

/***/ })

});