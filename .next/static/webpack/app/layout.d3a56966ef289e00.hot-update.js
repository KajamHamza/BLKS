"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./hooks/useBlocksProgram.ts":
/*!***********************************!*\
  !*** ./hooks/useBlocksProgram.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PostRating: function() { return /* binding */ PostRating; },\n/* harmony export */   useBlocksProgram: function() { return /* binding */ useBlocksProgram; }\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/wallet-adapter-react */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/useConnection.js\");\n/* harmony import */ var _solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @solana/wallet-adapter-react */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/useWallet.js\");\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n/* harmony import */ var borsh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! borsh */ \"(app-pages-browser)/./node_modules/borsh/lib/index.js\");\n/* harmony import */ var borsh__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(borsh__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_hot_toast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-hot-toast */ \"(app-pages-browser)/./node_modules/react-hot-toast/dist/index.mjs\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/config */ \"(app-pages-browser)/./config/index.ts\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\n\n\n\n// Your deployed program ID - configured from environment\nconst PROGRAM_ID = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(_config__WEBPACK_IMPORTED_MODULE_3__.config.solana.programId);\n// Add debug mode for testing without actual blockchain transactions\nconst DEBUG_MODE = \"development\" === \"development\";\nvar ContractInstruction;\n// Instruction enum matching your Rust contract\n(function(ContractInstruction) {\n    ContractInstruction[ContractInstruction[\"CreateProfile\"] = 0] = \"CreateProfile\";\n    ContractInstruction[ContractInstruction[\"UpdateProfile\"] = 1] = \"UpdateProfile\";\n    ContractInstruction[ContractInstruction[\"CreatePost\"] = 2] = \"CreatePost\";\n    ContractInstruction[ContractInstruction[\"LikePost\"] = 3] = \"LikePost\";\n    ContractInstruction[ContractInstruction[\"CommentOnPost\"] = 4] = \"CommentOnPost\";\n    ContractInstruction[ContractInstruction[\"FollowProfile\"] = 5] = \"FollowProfile\";\n    ContractInstruction[ContractInstruction[\"UnfollowProfile\"] = 6] = \"UnfollowProfile\";\n    ContractInstruction[ContractInstruction[\"CreateCommunity\"] = 7] = \"CreateCommunity\";\n    ContractInstruction[ContractInstruction[\"JoinCommunity\"] = 8] = \"JoinCommunity\";\n})(ContractInstruction || (ContractInstruction = {}));\nvar PostRating;\n(function(PostRating) {\n    PostRating[PostRating[\"None\"] = 0] = \"None\";\n    PostRating[PostRating[\"Bronze\"] = 1] = \"Bronze\";\n    PostRating[PostRating[\"Silver\"] = 2] = \"Silver\";\n    PostRating[PostRating[\"Gold\"] = 3] = \"Gold\";\n    PostRating[PostRating[\"Platinum\"] = 4] = \"Platinum\";\n    PostRating[PostRating[\"Diamond\"] = 5] = \"Diamond\";\n    PostRating[PostRating[\"Ace\"] = 6] = \"Ace\";\n    PostRating[PostRating[\"Conqueror\"] = 7] = \"Conqueror\";\n})(PostRating || (PostRating = {}));\n// Create Profile instruction data class\nclass CreateProfileInstruction {\n    constructor(fields){\n        this.username = fields.username;\n        this.bio = fields.bio;\n        this.profile_image = fields.profile_image;\n        this.cover_image = fields.cover_image;\n    }\n}\n// Create Post instruction data class\nclass CreatePostInstruction {\n    constructor(fields){\n        this.content = fields.content;\n        this.images = fields.images;\n    }\n}\n// Like Post instruction data class\nclass LikePostInstruction {\n    constructor(fields){\n        this.post_id = fields.post_id;\n    }\n}\n// Comment On Post instruction data class\nclass CommentOnPostInstruction {\n    constructor(fields){\n        this.content = fields.content;\n        this.parent_id = fields.parent_id;\n    }\n}\n// Bookmark Post instruction data class\nclass BookmarkPostInstruction {\n    constructor(fields){\n        this.post_id = fields.post_id;\n    }\n}\n// Profile struct for deserialization - matching Rust exactly\nclass ProfileAccount {\n    constructor(fields){\n        this.is_initialized = fields.is_initialized;\n        this.owner = fields.owner;\n        this.username = fields.username;\n        this.bio = fields.bio;\n        this.profile_image = fields.profile_image;\n        this.cover_image = fields.cover_image;\n        this.created_at = fields.created_at;\n        this.followers_count = fields.followers_count;\n        this.following_count = fields.following_count;\n        this.user_credit_rating = fields.user_credit_rating;\n        this.posts_count = fields.posts_count;\n        this.last_post_timestamp = fields.last_post_timestamp;\n        this.daily_post_count = fields.daily_post_count;\n        this.is_verified = fields.is_verified;\n    }\n}\n// Post struct for deserialization - matching Rust exactly\nclass PostAccount {\n    constructor(fields){\n        this.is_initialized = fields.is_initialized;\n        this.id = fields.id;\n        this.author = fields.author;\n        this.content = fields.content;\n        this.timestamp = fields.timestamp;\n        this.likes = fields.likes;\n        this.comments = fields.comments;\n        this.mirrors = fields.mirrors;\n        this.images = fields.images;\n        this.rating = fields.rating;\n        this.in_kill_zone = fields.in_kill_zone;\n    }\n}\n// Borsh schemas\nconst createProfileSchema = new Map([\n    [\n        CreateProfileInstruction,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"username\",\n                    \"string\"\n                ],\n                [\n                    \"bio\",\n                    \"string\"\n                ],\n                [\n                    \"profile_image\",\n                    \"string\"\n                ],\n                [\n                    \"cover_image\",\n                    \"string\"\n                ]\n            ]\n        }\n    ]\n]);\nconst createPostSchema = new Map([\n    [\n        CreatePostInstruction,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"content\",\n                    \"string\"\n                ],\n                [\n                    \"images\",\n                    [\n                        \"string\"\n                    ]\n                ]\n            ]\n        }\n    ]\n]);\nconst likePostSchema = new Map([\n    [\n        LikePostInstruction,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"post_id\",\n                    \"u64\"\n                ]\n            ]\n        }\n    ]\n]);\nconst commentOnPostSchema = new Map([\n    [\n        CommentOnPostInstruction,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"content\",\n                    \"string\"\n                ],\n                [\n                    \"parent_id\",\n                    \"u64\"\n                ]\n            ]\n        }\n    ]\n]);\nconst bookmarkPostSchema = new Map([\n    [\n        BookmarkPostInstruction,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"post_id\",\n                    \"u64\"\n                ]\n            ]\n        }\n    ]\n]);\nconst profileAccountSchema = new Map([\n    [\n        ProfileAccount,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"is_initialized\",\n                    \"u8\"\n                ],\n                [\n                    \"owner\",\n                    [\n                        32\n                    ]\n                ],\n                [\n                    \"username\",\n                    \"string\"\n                ],\n                [\n                    \"bio\",\n                    \"string\"\n                ],\n                [\n                    \"profile_image\",\n                    \"string\"\n                ],\n                [\n                    \"cover_image\",\n                    \"string\"\n                ],\n                [\n                    \"created_at\",\n                    \"u64\"\n                ],\n                [\n                    \"followers_count\",\n                    \"u64\"\n                ],\n                [\n                    \"following_count\",\n                    \"u64\"\n                ],\n                [\n                    \"user_credit_rating\",\n                    \"i64\"\n                ],\n                [\n                    \"posts_count\",\n                    \"u64\"\n                ],\n                [\n                    \"last_post_timestamp\",\n                    \"u64\"\n                ],\n                [\n                    \"daily_post_count\",\n                    \"u64\"\n                ],\n                [\n                    \"is_verified\",\n                    \"u8\"\n                ]\n            ]\n        }\n    ]\n]);\nconst postAccountSchema = new Map([\n    [\n        PostAccount,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"is_initialized\",\n                    \"u8\"\n                ],\n                [\n                    \"id\",\n                    \"u64\"\n                ],\n                [\n                    \"author\",\n                    [\n                        32\n                    ]\n                ],\n                [\n                    \"content\",\n                    \"string\"\n                ],\n                [\n                    \"timestamp\",\n                    \"u64\"\n                ],\n                [\n                    \"likes\",\n                    \"u64\"\n                ],\n                [\n                    \"comments\",\n                    \"u64\"\n                ],\n                [\n                    \"mirrors\",\n                    \"u64\"\n                ],\n                [\n                    \"images\",\n                    [\n                        \"string\"\n                    ]\n                ],\n                [\n                    \"rating\",\n                    \"u8\"\n                ],\n                [\n                    \"in_kill_zone\",\n                    \"u8\"\n                ]\n            ]\n        }\n    ]\n]);\n// Community struct for deserialization\nclass CommunityAccount {\n    constructor(fields){\n        this.is_initialized = fields.is_initialized;\n        this.id = fields.id;\n        this.creator = fields.creator;\n        this.name = fields.name;\n        this.description = fields.description;\n        this.avatar = fields.avatar;\n        this.rules = fields.rules;\n        this.member_count = fields.member_count;\n        this.created_at = fields.created_at;\n        this.is_private = fields.is_private;\n    }\n}\n// Create Community instruction\nclass CreateCommunityInstruction {\n    constructor(fields){\n        this.name = fields.name;\n        this.description = fields.description;\n        this.avatar = fields.avatar;\n        this.rules = fields.rules;\n    }\n}\n// Follow Profile instruction\nclass FollowProfileInstruction {\n    constructor(fields){\n        this.profile_id = fields.profile_id.toBuffer();\n    }\n}\nconst createCommunitySchema = new Map([\n    [\n        CreateCommunityInstruction,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"name\",\n                    \"string\"\n                ],\n                [\n                    \"description\",\n                    \"string\"\n                ],\n                [\n                    \"avatar\",\n                    \"string\"\n                ],\n                [\n                    \"rules\",\n                    [\n                        \"string\"\n                    ]\n                ]\n            ]\n        }\n    ]\n]);\nconst followProfileSchema = new Map([\n    [\n        FollowProfileInstruction,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"profile_id\",\n                    [\n                        32\n                    ]\n                ]\n            ]\n        }\n    ]\n]);\nconst communityAccountSchema = new Map([\n    [\n        CommunityAccount,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"is_initialized\",\n                    \"u8\"\n                ],\n                [\n                    \"id\",\n                    \"u64\"\n                ],\n                [\n                    \"creator\",\n                    [\n                        32\n                    ]\n                ],\n                [\n                    \"name\",\n                    \"string\"\n                ],\n                [\n                    \"description\",\n                    \"string\"\n                ],\n                [\n                    \"avatar\",\n                    \"string\"\n                ],\n                [\n                    \"rules\",\n                    [\n                        \"string\"\n                    ]\n                ],\n                [\n                    \"member_count\",\n                    \"u64\"\n                ],\n                [\n                    \"created_at\",\n                    \"u64\"\n                ],\n                [\n                    \"is_private\",\n                    \"u8\"\n                ]\n            ]\n        }\n    ]\n]);\n// Cache for profile lookups to avoid repeated blockchain calls\nconst profileCache = new Map();\nconst CACHE_DURATION = 60000 // 1 minute for memory cache (increased from 30 seconds)\n;\n// Posts cache\nlet postsCache = null;\nconst POSTS_CACHE_DURATION = 30000 // 30 seconds for posts cache (increased from 10 seconds)\n;\n// localStorage cache configuration - Updated to support multiple profiles\nconst LOCALSTORAGE_CACHE_PREFIX = \"blocks_profile_\";\nconst LOCALSTORAGE_CACHE_DURATION = 10 * 60 * 1000 // 10 minutes for localStorage cache (increased from 5 minutes)\n;\n// localStorage cache utilities - Updated to support multiple profiles\nconst saveProfileToLocalStorage = (walletAddress, profile)=>{\n    try {\n        const cacheKey = \"\".concat(LOCALSTORAGE_CACHE_PREFIX).concat(walletAddress);\n        const cacheData = {\n            profile,\n            timestamp: Date.now(),\n            walletAddress\n        };\n        localStorage.setItem(cacheKey, JSON.stringify(cacheData));\n        console.log(\"\\uD83D\\uDCBE Profile cached to localStorage for \".concat(walletAddress.slice(0, 8)));\n    } catch (error) {\n        console.warn(\"Failed to save profile to localStorage:\", error);\n    }\n};\nconst getProfileFromLocalStorage = (walletAddress)=>{\n    try {\n        const cacheKey = \"\".concat(LOCALSTORAGE_CACHE_PREFIX).concat(walletAddress);\n        const cached = localStorage.getItem(cacheKey);\n        if (!cached) return null;\n        const cacheData = JSON.parse(cached);\n        // Check if cache is expired\n        if (Date.now() - cacheData.timestamp > LOCALSTORAGE_CACHE_DURATION) {\n            console.log(\"⏰ Cache expired for \".concat(walletAddress.slice(0, 8), \", clearing\"));\n            localStorage.removeItem(cacheKey);\n            return null;\n        }\n        console.log(\"⚡ Using cached profile from localStorage for \".concat(walletAddress.slice(0, 8)));\n        return cacheData.profile;\n    } catch (error) {\n        console.warn(\"Failed to read profile from localStorage:\", error);\n        const cacheKey = \"\".concat(LOCALSTORAGE_CACHE_PREFIX).concat(walletAddress);\n        localStorage.removeItem(cacheKey);\n        return null;\n    }\n};\nconst clearProfileCache = (walletAddress)=>{\n    // Clear memory cache\n    if (walletAddress) {\n        profileCache.delete(walletAddress);\n        // Clear localStorage cache for specific user\n        const cacheKey = \"\".concat(LOCALSTORAGE_CACHE_PREFIX).concat(walletAddress);\n        localStorage.removeItem(cacheKey);\n    } else {\n        profileCache.clear();\n        // Clear all localStorage profile caches\n        const keys = Object.keys(localStorage);\n        keys.forEach((key)=>{\n            if (key.startsWith(LOCALSTORAGE_CACHE_PREFIX)) {\n                localStorage.removeItem(key);\n            }\n        });\n    }\n    // Clear posts cache\n    postsCache = null;\n    console.log(\"\\uD83D\\uDDD1️ Profile and posts cache cleared\");\n};\nfunction useBlocksProgram() {\n    const { connection } = (0,_solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_4__.useConnection)();\n    const { publicKey, sendTransaction } = (0,_solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_5__.useWallet)();\n    // Get profile PDA\n    const getProfilePDA = async (userPublicKey, username)=>{\n        const [profilePDA] = await _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey.findProgramAddress([\n            userPublicKey.toBuffer(),\n            Buffer.from(\"profile\"),\n            Buffer.from(username)\n        ], PROGRAM_ID);\n        return profilePDA;\n    };\n    // Get post PDA\n    const getPostPDA = async (userPublicKey, postId)=>{\n        const [postPDA] = await _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey.findProgramAddress([\n            userPublicKey.toBuffer(),\n            Buffer.from(\"post\"),\n            Buffer.from(postId.toString())\n        ], PROGRAM_ID);\n        return postPDA;\n    };\n    // Helper function to check if program exists\n    const checkProgramExists = async ()=>{\n        try {\n            const programInfo = await connection.getAccountInfo(PROGRAM_ID);\n            return programInfo !== null && programInfo.executable;\n        } catch (error) {\n            console.error(\"Error checking program existence:\", error);\n            return false;\n        }\n    };\n    // Helper function to check SOL balance\n    const checkSOLBalance = async ()=>{\n        if (!publicKey) return 0;\n        try {\n            const balance = await connection.getBalance(publicKey);\n            return balance / _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.LAMPORTS_PER_SOL;\n        } catch (error) {\n            console.error(\"Error checking SOL balance:\", error);\n            return 0;\n        }\n    };\n    // Convert ProfileAccount to Profile interface\n    const convertProfileAccount = (profileAccount)=>{\n        // Calculate UCR based on activity\n        const calculateUCR = (profile)=>{\n            const postsCount = Number(profile.posts_count);\n            const followersCount = Number(profile.followers_count);\n            const followingCount = Number(profile.following_count);\n            // Base UCR calculation algorithm\n            let ucr = 1.0 // Start with base rating\n            ;\n            // Posts factor (0.1 points per post, max 2.0 points)\n            const postsScore = Math.min(postsCount * 0.1, 2.0);\n            // Followers factor (0.05 points per follower, max 1.5 points)\n            const followersScore = Math.min(followersCount * 0.05, 1.5);\n            // Following/followers ratio (healthy ratio = bonus)\n            let ratioBonus = 0;\n            if (followersCount > 0 && followingCount > 0) {\n                const ratio = followersCount / followingCount;\n                if (ratio >= 0.5 && ratio <= 2.0) {\n                    ratioBonus = 0.3;\n                }\n            }\n            // Account age factor (older accounts get bonus)\n            const accountAge = Date.now() - Number(profile.created_at) * 1000;\n            const daysOld = accountAge / (1000 * 60 * 60 * 24);\n            const ageBonus = Math.min(daysOld / 30 * 0.2, 1.0) // 0.2 points per month, max 1.0\n            ;\n            // Verification bonus\n            const verificationBonus = profile.is_verified === 1 ? 0.5 : 0;\n            // Activity factor (posting regularly)\n            const lastPostAge = Date.now() - Number(profile.last_post_timestamp) * 1000;\n            const daysSinceLastPost = lastPostAge / (1000 * 60 * 60 * 24);\n            const activityBonus = daysSinceLastPost < 7 ? 0.3 : daysSinceLastPost < 30 ? 0.1 : 0;\n            ucr = ucr + postsScore + followersScore + ratioBonus + ageBonus + verificationBonus + activityBonus;\n            // Cap at 5.0 max\n            return Math.min(ucr, 5.0);\n        };\n        return {\n            isInitialized: profileAccount.is_initialized === 1,\n            owner: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(profileAccount.owner),\n            username: profileAccount.username,\n            bio: profileAccount.bio,\n            profileImage: profileAccount.profile_image,\n            coverImage: profileAccount.cover_image,\n            createdAt: Number(profileAccount.created_at) * 1000,\n            followersCount: Number(profileAccount.followers_count),\n            followingCount: Number(profileAccount.following_count),\n            userCreditRating: calculateUCR(profileAccount),\n            postsCount: Number(profileAccount.posts_count),\n            lastPostTimestamp: Number(profileAccount.last_post_timestamp) * 1000,\n            dailyPostCount: Number(profileAccount.daily_post_count),\n            isVerified: profileAccount.is_verified === 1\n        };\n    };\n    // Convert PostAccount to Post interface\n    const convertPostAccount = (postAccount)=>{\n        return {\n            isInitialized: postAccount.is_initialized === 1,\n            id: Number(postAccount.id),\n            author: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(postAccount.author),\n            content: postAccount.content,\n            timestamp: Number(postAccount.timestamp) * 1000,\n            likes: Number(postAccount.likes),\n            comments: Number(postAccount.comments),\n            mirrors: Number(postAccount.mirrors),\n            images: postAccount.images,\n            rating: postAccount.rating,\n            inKillZone: postAccount.in_kill_zone === 1\n        };\n    };\n    // Create user profile - REAL IMPLEMENTATION\n    const createProfile = async (username, bio, profileImage, coverImage)=>{\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83D\\uDD0D Running pre-flight checks...\");\n            const balance = await checkSOLBalance();\n            console.log(\"\\uD83D\\uDCB0 SOL Balance: \".concat(balance));\n            if (balance < 0.1) {\n                throw new Error(\"Insufficient SOL balance: \".concat(balance, \". You need at least 0.1 SOL for transaction fees and account creation.\"));\n            }\n            const programExists = await checkProgramExists();\n            console.log(\"\\uD83D\\uDCCB Program exists: \".concat(programExists));\n            if (!programExists) {\n                throw new Error(\"Program not found at address: \".concat(PROGRAM_ID.toString(), \". Make sure the program is deployed on \").concat(_config__WEBPACK_IMPORTED_MODULE_3__.config.solana.network, \".\"));\n            }\n            console.log(\"✅ Pre-flight checks passed\");\n            const profilePDA = await getProfilePDA(publicKey, username);\n            console.log(\"\\uD83D\\uDCCD Profile PDA: \".concat(profilePDA.toString()));\n            const instructionData = new CreateProfileInstruction({\n                username,\n                bio,\n                profile_image: profileImage,\n                cover_image: coverImage\n            });\n            const createProfileVariant = Buffer.from([\n                0\n            ]);\n            const serializedData = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.serialize)(createProfileSchema, instructionData);\n            const fullInstructionData = Buffer.concat([\n                createProfileVariant,\n                Buffer.from(serializedData)\n            ]);\n            const instruction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: profilePDA,\n                        isSigner: false,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.SystemProgram.programId,\n                        isSigner: false,\n                        isWritable: false\n                    }\n                ],\n                programId: PROGRAM_ID,\n                data: fullInstructionData\n            });\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction().add(instruction);\n            const { blockhash } = await connection.getLatestBlockhash(\"processed\");\n            transaction.recentBlockhash = blockhash;\n            transaction.feePayer = publicKey;\n            const simulation = await connection.simulateTransaction(transaction);\n            if (simulation.value.err) {\n                throw new Error(\"Transaction simulation failed: \".concat(JSON.stringify(simulation.value.err)));\n            }\n            const signature = await sendTransaction(transaction, connection, {\n                skipPreflight: false,\n                preflightCommitment: \"processed\",\n                maxRetries: 3\n            });\n            await connection.confirmTransaction({\n                signature,\n                blockhash,\n                lastValidBlockHeight: (await connection.getLatestBlockhash()).lastValidBlockHeight\n            }, \"processed\");\n            // Invalidate cache after profile creation\n            clearProfileCache(publicKey.toString());\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.success(\"Profile created successfully!\");\n            return signature;\n        } catch (error) {\n            console.error(\"❌ Profile creation error:\", error);\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Transaction failed: \".concat(error.message || \"Unknown error\"));\n            throw error;\n        }\n    };\n    // Production-ready profile detection with localStorage caching - Improved for multiple users\n    const getProfile = async (userPublicKey)=>{\n        const cacheKey = userPublicKey.toString();\n        try {\n            // 1. Check localStorage cache first (fastest)\n            const cachedProfile = getProfileFromLocalStorage(cacheKey);\n            if (cachedProfile !== null) {\n                // Also update memory cache\n                profileCache.set(cacheKey, cachedProfile);\n                setTimeout(()=>profileCache.delete(cacheKey), CACHE_DURATION);\n                return cachedProfile;\n            }\n            // 2. Check memory cache\n            if (profileCache.has(cacheKey)) {\n                const cached = profileCache.get(cacheKey);\n                return cached !== null && cached !== void 0 ? cached : null;\n            }\n            // 3. Fetch from blockchain (slowest)\n            console.log(\"\\uD83D\\uDD0D Fetching profile from blockchain for: \".concat(userPublicKey.toString().slice(0, 8), \"...\"));\n            const accounts = await connection.getProgramAccounts(PROGRAM_ID);\n            console.log(\"\\uD83D\\uDCCA Found \".concat(accounts.length, \" program accounts to scan for profiles\"));\n            let profilesFound = 0;\n            // Scan through accounts to find user's profile\n            for (const { account, pubkey } of accounts){\n                try {\n                    if (account.data.length === 0) continue;\n                    // Try manual parsing first\n                    const profileAccount = manualParseProfile(account.data);\n                    if (!profileAccount) continue;\n                    profilesFound++;\n                    const accountOwner = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(profileAccount.owner);\n                    // Check if this profile belongs to the user we're looking for\n                    if (profileAccount.is_initialized === 1 && accountOwner.equals(userPublicKey)) {\n                        console.log('\\uD83C\\uDFAF FOUND PROFILE! Username: \"'.concat(profileAccount.username, '\" for ').concat(userPublicKey.toString().slice(0, 8)));\n                        console.log('\\uD83D\\uDCF8 Profile Image URL: \"'.concat(profileAccount.profile_image, '\"'));\n                        console.log('\\uD83D\\uDDBC️ Cover Image URL: \"'.concat(profileAccount.cover_image, '\"'));\n                        console.log(\"\\uD83D\\uDCCA Profile Data:\", {\n                            username: profileAccount.username,\n                            bio: profileAccount.bio,\n                            profileImage: profileAccount.profile_image,\n                            coverImage: profileAccount.cover_image,\n                            postsCount: Number(profileAccount.posts_count),\n                            followersCount: Number(profileAccount.followers_count),\n                            isVerified: profileAccount.is_verified === 1\n                        });\n                        const profile = convertProfileAccount(profileAccount);\n                        // Cache in both memory and localStorage\n                        profileCache.set(cacheKey, profile);\n                        setTimeout(()=>profileCache.delete(cacheKey), CACHE_DURATION);\n                        saveProfileToLocalStorage(cacheKey, profile);\n                        return profile;\n                    }\n                } catch (error) {\n                    continue;\n                }\n            }\n            console.log(\"\\uD83D\\uDCCA Scanned \".concat(profilesFound, \" profiles, no match found for user: \").concat(userPublicKey.toString().slice(0, 8)));\n            // No profile found - cache null result to avoid repeated scans\n            profileCache.set(cacheKey, null);\n            setTimeout(()=>profileCache.delete(cacheKey), CACHE_DURATION);\n            saveProfileToLocalStorage(cacheKey, null);\n            return null;\n        } catch (error) {\n            console.error(\"Error fetching profile for \".concat(userPublicKey.toString().slice(0, 8), \":\"), error);\n            return null;\n        }\n    };\n    // Get profile by username (for specific lookups)\n    const getProfileByUsername = async (userPublicKey, username)=>{\n        try {\n            const profilePDA = await getProfilePDA(userPublicKey, username);\n            const accountInfo = await connection.getAccountInfo(profilePDA);\n            if (!accountInfo || !accountInfo.data || accountInfo.data.length === 0) {\n                return null;\n            }\n            // Now try manual parsing\n            const profileAccount = manualParseProfile(accountInfo.data);\n            if (profileAccount) {\n                console.log(\"✅ Successfully manually parsed profile:\", {\n                    username: profileAccount.username,\n                    bio: profileAccount.bio,\n                    isInitialized: profileAccount.is_initialized === 1,\n                    owner: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(profileAccount.owner).toString(),\n                    profileImage: profileAccount.profile_image,\n                    coverImage: profileAccount.cover_image,\n                    postsCount: Number(profileAccount.posts_count)\n                });\n                return convertProfileAccount(profileAccount);\n            } else {\n                console.log(\"❌ Manual parsing failed\");\n                return null;\n            }\n        } catch (error) {\n            return null;\n        }\n    };\n    // Get posts - REAL IMPLEMENTATION with manual parsing and caching\n    const getPosts = async ()=>{\n        try {\n            // Check cache first\n            if (postsCache && Date.now() - postsCache.timestamp < POSTS_CACHE_DURATION) {\n                console.log(\"⚡ Using cached posts\");\n                return postsCache.posts;\n            }\n            console.log(\"\\uD83D\\uDD0D Fetching posts from blockchain...\");\n            const accounts = await connection.getProgramAccounts(PROGRAM_ID);\n            const posts = [];\n            console.log(\"\\uD83D\\uDCCA Scanning \".concat(accounts.length, \" program accounts for posts...\"));\n            for (const { account, pubkey } of accounts){\n                try {\n                    if (account.data.length === 0) continue;\n                    // Try manual post parsing first\n                    const postAccount = manualParsePost(account.data);\n                    if (postAccount && postAccount.is_initialized === 1 && postAccount.content) {\n                        const post = convertPostAccount(postAccount);\n                        posts.push(post);\n                        console.log('\\uD83D\\uDCDD Found post: \"'.concat(post.content.substring(0, 50), '...\" by ').concat(post.author.toString()));\n                    }\n                } catch (error) {\n                    continue;\n                }\n            }\n            posts.sort((a, b)=>b.timestamp - a.timestamp);\n            console.log(\"✅ Loaded \".concat(posts.length, \" posts from blockchain\"));\n            // Cache the results\n            postsCache = {\n                posts,\n                timestamp: Date.now()\n            };\n            return posts;\n        } catch (error) {\n            console.error(\"Error fetching posts:\", error);\n            return [];\n        }\n    };\n    // Create post - REAL IMPLEMENTATION\n    const createPost = async function(content) {\n        let images = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83D\\uDD0D Creating post with content:\", content);\n            // Check SOL balance\n            const balance = await checkSOLBalance();\n            if (balance < 0.05) {\n                throw new Error(\"Insufficient SOL balance: \".concat(balance, \". You need at least 0.05 SOL for transaction fees and account creation.\"));\n            }\n            // Get user's profile PDA - we need this for the instruction\n            const userProfile = await getProfile(publicKey);\n            if (!userProfile) {\n                throw new Error(\"You must create a profile before posting\");\n            }\n            // Get user's current post count to generate the correct post ID\n            // The Rust contract increments posts_count first, then uses that as the post ID\n            const postId = userProfile.postsCount + 1;\n            const postPDA = await getPostPDA(publicKey, postId);\n            console.log(\"\\uD83D\\uDCCD Post PDA: \".concat(postPDA.toString(), \" for post ID: \").concat(postId));\n            // Generate a new keypair for the post account\n            // The Rust contract uses invoke with system_instruction::create_account\n            // This means the post account MUST be a keypair that signs the transaction\n            const postKeypair = _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Keypair.generate();\n            console.log(\"\\uD83D\\uDCCD Post Account: \".concat(postKeypair.publicKey.toString()));\n            // Get profile PDA for the user (we need the actual username)\n            // Try to find the profile account among all program accounts\n            const accounts = await connection.getProgramAccounts(PROGRAM_ID);\n            let userProfilePDA = null;\n            for (const { account, pubkey } of accounts){\n                try {\n                    const profileAccount = manualParseProfile(account.data);\n                    if (profileAccount && profileAccount.is_initialized === 1 && new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(profileAccount.owner).equals(publicKey)) {\n                        userProfilePDA = pubkey;\n                        console.log(\"\\uD83D\\uDCCD User Profile PDA: \".concat(userProfilePDA.toString()));\n                        break;\n                    }\n                } catch (error) {\n                    continue;\n                }\n            }\n            if (!userProfilePDA) {\n                throw new Error(\"Could not find your profile PDA. Please refresh and try again.\");\n            }\n            const instructionData = new CreatePostInstruction({\n                content,\n                images\n            });\n            const createPostVariant = Buffer.from([\n                2\n            ]) // CreatePost enum index\n            ;\n            const serializedData = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.serialize)(createPostSchema, instructionData);\n            const fullInstructionData = Buffer.concat([\n                createPostVariant,\n                Buffer.from(serializedData)\n            ]);\n            console.log(\"\\uD83D\\uDD22 Instruction data length: \".concat(fullInstructionData.length, \" bytes\"));\n            const instruction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: postKeypair.publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: userProfilePDA,\n                        isSigner: false,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.SystemProgram.programId,\n                        isSigner: false,\n                        isWritable: false\n                    }\n                ],\n                programId: PROGRAM_ID,\n                data: fullInstructionData\n            });\n            console.log(\"\\uD83D\\uDCDD Transaction instruction created\");\n            console.log(\"\\uD83D\\uDD11 Keys:\", instruction.keys.map((k)=>({\n                    pubkey: k.pubkey.toString(),\n                    isSigner: k.isSigner,\n                    isWritable: k.isWritable\n                })));\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction().add(instruction);\n            const { blockhash } = await connection.getLatestBlockhash(\"processed\");\n            transaction.recentBlockhash = blockhash;\n            transaction.feePayer = publicKey;\n            console.log(\"\\uD83D\\uDE80 Sending transaction...\");\n            // Sign transaction before simulation\n            transaction.partialSign(postKeypair);\n            // Simulate transaction \n            const simulation = await connection.simulateTransaction(transaction);\n            console.log(\"\\uD83C\\uDFAF Transaction simulation:\", simulation);\n            if (simulation.value.err) {\n                throw new Error(\"Transaction simulation failed: \".concat(JSON.stringify(simulation.value.err)));\n            }\n            // Send transaction with post keypair as additional signer\n            const signature = await sendTransaction(transaction, connection, {\n                skipPreflight: false,\n                preflightCommitment: \"processed\",\n                maxRetries: 3,\n                signers: [\n                    postKeypair\n                ]\n            });\n            console.log(\"\\uD83D\\uDCCB Transaction signature: \".concat(signature));\n            await connection.confirmTransaction({\n                signature,\n                blockhash,\n                lastValidBlockHeight: (await connection.getLatestBlockhash()).lastValidBlockHeight\n            }, \"processed\");\n            // Invalidate cache after post creation (profile post count changed)\n            clearProfileCache(publicKey.toString());\n            postsCache = null // Also clear posts cache to show new post immediately\n            ;\n            console.log(\"✅ Post created successfully!\");\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.success(\"Post created successfully!\");\n            return signature;\n        } catch (error) {\n            var _error_message, _error_message1;\n            console.error(\"❌ Post creation error:\", error);\n            if ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"insufficient funds\")) {\n                const balance = await checkSOLBalance();\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Insufficient SOL: \".concat(balance.toFixed(4), \" SOL. Need at least 0.05 SOL for fees.\"));\n            } else if ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes(\"simulation failed\")) {\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Transaction would fail: Check account setup and balance\");\n                console.error(\"Simulation error details:\", error.message);\n            } else {\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Failed to create post: \".concat(error.message || \"Unknown error\"));\n            }\n            throw error;\n        }\n    };\n    // Like post - REAL IMPLEMENTATION - Fixed to find actual post accounts\n    const likePost = async (postId, postAuthor)=>{\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83D\\uDD0D Attempting to like post ID \".concat(postId, \" by author \").concat(postAuthor.toString().slice(0, 8), \"...\"));\n            // Check SOL balance first\n            const balance = await checkSOLBalance();\n            console.log(\"\\uD83D\\uDCB0 Current SOL balance: \".concat(balance));\n            if (balance < 0.01) {\n                throw new Error(\"Insufficient SOL balance: \".concat(balance, \". Need at least 0.01 SOL for transaction fees.\"));\n            }\n            // Find the actual post account and author's profile account by scanning all program accounts\n            console.log(\"\\uD83D\\uDD0D Searching for post ID \".concat(postId, \" by author \").concat(postAuthor.toString().slice(0, 8), \"...\"));\n            const accounts = await connection.getProgramAccounts(PROGRAM_ID);\n            let postAccountAddress = null;\n            let postAccount = null;\n            let authorProfileAddress = null;\n            // First pass: find the post account\n            for (const { account, pubkey } of accounts){\n                try {\n                    const parsedPost = manualParsePost(account.data);\n                    if (parsedPost && parsedPost.is_initialized === 1 && Number(parsedPost.id) === postId && new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(parsedPost.author).equals(postAuthor)) {\n                        postAccountAddress = pubkey;\n                        postAccount = parsedPost;\n                        console.log(\"\\uD83C\\uDFAF Found post ID \".concat(postId, \" at address: \").concat(pubkey.toString()));\n                        break;\n                    }\n                } catch (error) {\n                    continue;\n                }\n            }\n            if (!postAccountAddress || !postAccount) {\n                throw new Error(\"Post ID \".concat(postId, \" by author \").concat(postAuthor.toString().slice(0, 8), \" not found on blockchain\"));\n            }\n            // Second pass: find the author's profile account\n            console.log(\"\\uD83D\\uDD0D Searching for author's profile: \".concat(postAuthor.toString().slice(0, 8), \"...\"));\n            for (const { account, pubkey } of accounts){\n                try {\n                    const parsedProfile = manualParseProfile(account.data);\n                    if (parsedProfile && parsedProfile.is_initialized === 1 && new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(parsedProfile.owner).equals(postAuthor)) {\n                        authorProfileAddress = pubkey;\n                        console.log(\"✅ Found author profile account: \".concat(pubkey.toString()));\n                        break;\n                    }\n                } catch (error) {\n                    continue;\n                }\n            }\n            if (!authorProfileAddress) {\n                throw new Error(\"Author's profile not found for \".concat(postAuthor.toString().slice(0, 8)));\n            }\n            console.log('\\uD83D\\uDCDD Post data verified: \"'.concat(postAccount.content.slice(0, 30), '...\" with ').concat(Number(postAccount.likes), \" likes\"));\n            const instructionData = new LikePostInstruction({\n                post_id: BigInt(postId)\n            });\n            const likePostVariant = Buffer.from([\n                3\n            ]) // LikePost instruction variant\n            ;\n            const serializedData = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.serialize)(likePostSchema, instructionData);\n            const fullInstructionData = Buffer.concat([\n                likePostVariant,\n                Buffer.from(serializedData)\n            ]);\n            console.log(\"\\uD83D\\uDD22 Instruction data: variant [3], serialized length: \".concat(serializedData.length, \", total: \").concat(fullInstructionData.length, \" bytes\"));\n            const instruction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: publicKey,\n                        isSigner: true,\n                        isWritable: false\n                    },\n                    {\n                        pubkey: postAccountAddress,\n                        isSigner: false,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: authorProfileAddress,\n                        isSigner: false,\n                        isWritable: true\n                    }\n                ],\n                programId: PROGRAM_ID,\n                data: fullInstructionData\n            });\n            console.log(\"\\uD83D\\uDD11 Transaction accounts:\");\n            console.log(\"  User (liker): \".concat(publicKey.toString(), \" (signer, readonly)\"));\n            console.log(\"  Post: \".concat(postAccountAddress.toString(), \" (not signer, writable)\"));\n            console.log(\"  Author Profile: \".concat(authorProfileAddress.toString(), \" (not signer, writable)\"));\n            console.log(\"  Program: \".concat(PROGRAM_ID.toString()));\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction().add(instruction);\n            const { blockhash } = await connection.getLatestBlockhash(\"processed\");\n            transaction.recentBlockhash = blockhash;\n            transaction.feePayer = publicKey;\n            // Simulate transaction before sending\n            console.log(\"\\uD83C\\uDFAF Simulating transaction...\");\n            const simulation = await connection.simulateTransaction(transaction);\n            console.log(\"\\uD83D\\uDCCA Simulation result:\", simulation);\n            if (simulation.value.err) {\n                throw new Error(\"Transaction simulation failed: \".concat(JSON.stringify(simulation.value.err)));\n            }\n            console.log(\"✅ Transaction simulation successful\");\n            console.log(\"\\uD83D\\uDE80 Sending transaction...\");\n            const signature = await sendTransaction(transaction, connection, {\n                skipPreflight: false,\n                preflightCommitment: \"processed\",\n                maxRetries: 3\n            });\n            console.log(\"\\uD83D\\uDCCB Transaction sent with signature: \".concat(signature));\n            console.log(\"⏳ Confirming transaction...\");\n            await connection.confirmTransaction({\n                signature,\n                blockhash,\n                lastValidBlockHeight: (await connection.getLatestBlockhash()).lastValidBlockHeight\n            }, \"processed\");\n            console.log(\"✅ Transaction confirmed! Post liked successfully!\");\n            // Clear posts cache to force refresh\n            postsCache = null;\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.success(\"Post liked!\");\n            return signature;\n        } catch (error) {\n            var _error_message, _error_message1, _error_message2;\n            console.error(\"❌ Like post error:\", error);\n            // More specific error messages\n            if ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"insufficient funds\")) {\n                const balance = await checkSOLBalance();\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Insufficient SOL: \".concat(balance.toFixed(4), \" SOL. Need at least 0.01 SOL for fees.\"));\n            } else if ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes(\"simulation failed\")) {\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Transaction would fail: Check post exists and wallet has permission\");\n                console.error(\"Simulation error details:\", error.message);\n            } else if ((_error_message2 = error.message) === null || _error_message2 === void 0 ? void 0 : _error_message2.includes(\"not found on blockchain\")) {\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Post not found on blockchain\");\n            } else {\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Failed to like post: \".concat(error.message || \"Unknown error\"));\n            }\n            throw error;\n        }\n    };\n    // Check specific profile PDA - for debugging profile detection issues\n    const checkProfileAtPDA = async (pdaAddress)=>{\n        try {\n            console.log(\"\\uD83D\\uDD0D Checking specific PDA: \".concat(pdaAddress));\n            const pda = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(pdaAddress);\n            const accountInfo = await connection.getAccountInfo(pda);\n            if (!accountInfo) {\n                console.log(\"❌ No account found at PDA: \".concat(pdaAddress));\n                return;\n            }\n            console.log(\"✅ Account exists! Owner: \".concat(accountInfo.owner.toString(), \", Size: \").concat(accountInfo.data.length, \" bytes\"));\n            // Inspect raw data\n            console.log(\"\\uD83D\\uDD0D Raw data (first 100 bytes):\", Array.from(accountInfo.data.slice(0, 100)));\n            if (accountInfo.owner.equals(PROGRAM_ID)) {\n                console.log(\"✅ Account is owned by our program\");\n                try {\n                    // Try manual parsing to understand the structure\n                    let offset = 0;\n                    const is_initialized = accountInfo.data[offset];\n                    offset += 1;\n                    console.log(\"\\uD83D\\uDCCA is_initialized: \".concat(is_initialized));\n                    const owner = accountInfo.data.slice(offset, offset + 32);\n                    offset += 32;\n                    console.log(\"\\uD83D\\uDCCA owner: \".concat(new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(owner).toString()));\n                    // Try to read the username length (Borsh string format: 4 bytes length + string)\n                    const usernameLength = accountInfo.data.readUInt32LE(offset);\n                    offset += 4;\n                    console.log(\"\\uD83D\\uDCCA username length: \".concat(usernameLength));\n                    if (usernameLength > 0 && usernameLength < 100) {\n                        const username = accountInfo.data.slice(offset, offset + usernameLength).toString(\"utf8\");\n                        console.log('\\uD83D\\uDCCA username: \"'.concat(username, '\"'));\n                    }\n                    // Now try manual parsing\n                    const profileAccount = manualParseProfile(accountInfo.data);\n                    if (profileAccount) {\n                        console.log(\"✅ Successfully manually parsed profile:\", {\n                            username: profileAccount.username,\n                            bio: profileAccount.bio,\n                            isInitialized: profileAccount.is_initialized === 1,\n                            owner: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(profileAccount.owner).toString(),\n                            profileImage: profileAccount.profile_image,\n                            coverImage: profileAccount.cover_image,\n                            postsCount: Number(profileAccount.posts_count)\n                        });\n                    } else {\n                        console.log(\"❌ Manual parsing failed\");\n                    }\n                    // Also try Borsh for comparison\n                    try {\n                        const profileAccount = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.deserialize)(profileAccountSchema, ProfileAccount, accountInfo.data);\n                        console.log(\"✅ Borsh deserialization also worked:\", {\n                            username: profileAccount.username,\n                            bio: profileAccount.bio,\n                            isInitialized: profileAccount.is_initialized === 1,\n                            owner: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(profileAccount.owner).toString()\n                        });\n                    } catch (error) {\n                        console.log(\"❌ Borsh deserialization still fails:\", error);\n                    }\n                } catch (error) {\n                    console.log(\"❌ Error checking PDA:\", error);\n                }\n            } else {\n                console.log(\"❌ Account is owned by different program: \".concat(accountInfo.owner.toString()));\n            }\n        } catch (error) {\n            console.log(\"❌ Error checking PDA:\", error);\n        }\n    };\n    // Manual profile parser - bypasses Borsh deserialization issues\n    const manualParseProfile = (data)=>{\n        try {\n            // Basic validation - profiles should have a minimum size\n            if (data.length < 150) return null // Profiles need at least 150 bytes for basic structure\n            ;\n            let offset = 0;\n            // Parse each field manually\n            const is_initialized = data[offset];\n            if (is_initialized !== 1) return null // Must be initialized\n            ;\n            offset += 1;\n            const owner = data.slice(offset, offset + 32);\n            offset += 32;\n            // Validate we have enough data for username length\n            if (offset + 4 > data.length) return null;\n            // String fields (username, bio, profile_image, cover_image)\n            const usernameLength = data.readUInt32LE(offset);\n            offset += 4;\n            // Validate username length is reasonable\n            if (usernameLength > 100 || usernameLength === 0) return null;\n            if (offset + usernameLength > data.length) return null;\n            const username = data.slice(offset, offset + usernameLength).toString(\"utf8\");\n            offset += usernameLength;\n            // Validate we have enough data for bio length\n            if (offset + 4 > data.length) return null;\n            const bioLength = data.readUInt32LE(offset);\n            offset += 4;\n            // Validate bio length is reasonable\n            if (bioLength > 1000) return null;\n            if (offset + bioLength > data.length) return null;\n            const bio = data.slice(offset, offset + bioLength).toString(\"utf8\");\n            offset += bioLength;\n            // Validate we have enough data for profile image length\n            if (offset + 4 > data.length) return null;\n            const profileImageLength = data.readUInt32LE(offset);\n            offset += 4;\n            // Validate profile image length is reasonable\n            if (profileImageLength > 500) return null;\n            if (offset + profileImageLength > data.length) return null;\n            const profile_image = data.slice(offset, offset + profileImageLength).toString(\"utf8\");\n            offset += profileImageLength;\n            // Validate we have enough data for cover image length\n            if (offset + 4 > data.length) return null;\n            const coverImageLength = data.readUInt32LE(offset);\n            offset += 4;\n            // Validate cover image length is reasonable\n            if (coverImageLength > 500) return null;\n            if (offset + coverImageLength > data.length) return null;\n            const cover_image = data.slice(offset, offset + coverImageLength).toString(\"utf8\");\n            offset += coverImageLength;\n            // Validate we have enough data for all the u64 fields (8 bytes each * 6 fields = 48 bytes)\n            if (offset + 48 > data.length) return null;\n            // u64 fields\n            const created_at = data.readBigUInt64LE(offset);\n            offset += 8;\n            const followers_count = data.readBigUInt64LE(offset);\n            offset += 8;\n            const following_count = data.readBigUInt64LE(offset);\n            offset += 8;\n            // i64 field\n            const user_credit_rating = data.readBigInt64LE(offset);\n            offset += 8;\n            const posts_count = data.readBigUInt64LE(offset);\n            offset += 8;\n            const last_post_timestamp = data.readBigUInt64LE(offset);\n            offset += 8;\n            const daily_post_count = data.readBigUInt64LE(offset);\n            offset += 8;\n            // Validate we have enough data for the final u8 field\n            if (offset + 1 > data.length) return null;\n            const is_verified = data[offset];\n            offset += 1;\n            return new ProfileAccount({\n                is_initialized,\n                owner: new Uint8Array(owner),\n                username,\n                bio,\n                profile_image,\n                cover_image,\n                created_at,\n                followers_count,\n                following_count,\n                user_credit_rating,\n                posts_count,\n                last_post_timestamp,\n                daily_post_count,\n                is_verified\n            });\n        } catch (error) {\n            // Silent failure - not a profile account or invalid data\n            return null;\n        }\n    };\n    // Manual post parser - bypasses Borsh deserialization issues\n    const manualParsePost = (data)=>{\n        try {\n            // Quick validation: posts should have specific size and structure\n            if (data.length < 100) return null // Posts should be larger than profiles\n            ;\n            let offset = 0;\n            // Parse each field manually\n            const is_initialized = data[offset];\n            if (is_initialized !== 1) return null // Must be initialized\n            ;\n            offset += 1;\n            // Check if this looks like a post vs profile by examining the structure\n            // Posts start with: u8 (init), u64 (id), [32]u8 (author), string (content)\n            // Profiles start with: u8 (init), [32]u8 (owner), string (username)\n            const id = data.readBigUInt64LE(offset);\n            offset += 8;\n            const author = data.slice(offset, offset + 32);\n            offset += 32;\n            const contentLength = data.readUInt32LE(offset);\n            offset += 4;\n            // Validate content length is reasonable (not too large)\n            if (contentLength > 10000 || contentLength === 0) return null;\n            if (offset + contentLength > data.length) return null;\n            const content = data.slice(offset, offset + contentLength).toString(\"utf8\");\n            offset += contentLength;\n            // Ensure we have enough remaining data for the rest of the post structure\n            if (offset + 40 > data.length) return null // Need at least 40 more bytes for timestamps and counts\n            ;\n            const timestamp = data.readBigUInt64LE(offset);\n            offset += 8;\n            const likes = data.readBigUInt64LE(offset);\n            offset += 8;\n            const comments = data.readBigUInt64LE(offset);\n            offset += 8;\n            const mirrors = data.readBigUInt64LE(offset);\n            offset += 8;\n            // Parse images array length\n            if (offset + 4 > data.length) return null;\n            const imagesLength = data.readUInt32LE(offset);\n            offset += 4;\n            const images = [];\n            // Parse images array - each image is a length-prefixed string\n            for(let i = 0; i < imagesLength; i++){\n                if (offset + 4 > data.length) return null;\n                const imageLength = data.readUInt32LE(offset);\n                offset += 4;\n                if (offset + imageLength > data.length) return null;\n                const image = data.slice(offset, offset + imageLength).toString(\"utf8\");\n                offset += imageLength;\n                images.push(image);\n            }\n            // Ensure we have enough data for rating and kill zone\n            if (offset + 2 > data.length) return null;\n            const rating = data[offset];\n            offset += 1;\n            const in_kill_zone = data[offset];\n            offset += 1;\n            return new PostAccount({\n                is_initialized,\n                id,\n                author: new Uint8Array(author),\n                content,\n                timestamp,\n                likes,\n                comments,\n                mirrors,\n                images,\n                rating,\n                in_kill_zone\n            });\n        } catch (error) {\n            // Silent failure - not a post account\n            return null;\n        }\n    };\n    // Convert CommunityAccount to Community interface\n    const convertCommunityAccount = (communityAccount)=>{\n        return {\n            isInitialized: communityAccount.is_initialized === 1,\n            id: Number(communityAccount.id),\n            creator: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(communityAccount.creator),\n            name: communityAccount.name,\n            description: communityAccount.description,\n            avatar: communityAccount.avatar,\n            rules: communityAccount.rules,\n            memberCount: Number(communityAccount.member_count),\n            createdAt: Number(communityAccount.created_at) * 1000,\n            isPrivate: communityAccount.is_private === 1\n        };\n    };\n    // Create Community\n    const createCommunity = async function(name, description, avatar) {\n        let rules = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83C\\uDFD8️ Creating community:\", name);\n            const balance = await checkSOLBalance();\n            if (balance < 0.05) {\n                throw new Error(\"Insufficient SOL balance: \".concat(balance, \". Need at least 0.05 SOL.\"));\n            }\n            // Generate a keypair for the community account\n            const communityKeypair = _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Keypair.generate();\n            console.log(\"\\uD83D\\uDCCD Community Account: \".concat(communityKeypair.publicKey.toString()));\n            const instructionData = new CreateCommunityInstruction({\n                name,\n                description,\n                avatar,\n                rules\n            });\n            const createCommunityVariant = Buffer.from([\n                7\n            ]) // CreateCommunity enum index\n            ;\n            const serializedData = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.serialize)(createCommunitySchema, instructionData);\n            const fullInstructionData = Buffer.concat([\n                createCommunityVariant,\n                Buffer.from(serializedData)\n            ]);\n            const instruction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: communityKeypair.publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.SystemProgram.programId,\n                        isSigner: false,\n                        isWritable: false\n                    }\n                ],\n                programId: PROGRAM_ID,\n                data: fullInstructionData\n            });\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction().add(instruction);\n            const { blockhash } = await connection.getLatestBlockhash(\"processed\");\n            transaction.recentBlockhash = blockhash;\n            transaction.feePayer = publicKey;\n            // Sign with community keypair\n            transaction.partialSign(communityKeypair);\n            const signature = await sendTransaction(transaction, connection, {\n                skipPreflight: false,\n                preflightCommitment: \"processed\",\n                maxRetries: 3,\n                signers: [\n                    communityKeypair\n                ]\n            });\n            await connection.confirmTransaction({\n                signature,\n                blockhash,\n                lastValidBlockHeight: (await connection.getLatestBlockhash()).lastValidBlockHeight\n            }, \"processed\");\n            console.log(\"✅ Community created successfully!\");\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.success('Community \"'.concat(name, '\" created successfully!'));\n            return signature;\n        } catch (error) {\n            console.error(\"❌ Community creation error:\", error);\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Failed to create community: \".concat(error.message || \"Unknown error\"));\n            throw error;\n        }\n    };\n    // Follow Profile\n    const followProfile = async (profilePublicKey)=>{\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83D\\uDC65 Following profile:\", profilePublicKey.toString());\n            // Find the follower's profile account (current user's profile)\n            console.log(\"\\uD83D\\uDD0D Searching for follower profile: \".concat(publicKey.toString().slice(0, 8), \"...\"));\n            const accounts = await connection.getProgramAccounts(PROGRAM_ID);\n            let followerProfileAddress = null;\n            for (const { account, pubkey } of accounts){\n                try {\n                    const parsedProfile = manualParseProfile(account.data);\n                    if (parsedProfile && parsedProfile.is_initialized === 1 && new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(parsedProfile.owner).equals(publicKey)) {\n                        followerProfileAddress = pubkey;\n                        console.log(\"✅ Found follower profile account: \".concat(pubkey.toString()));\n                        break;\n                    }\n                } catch (error) {\n                    continue;\n                }\n            }\n            if (!followerProfileAddress) {\n                throw new Error(\"You must create a profile before following others\");\n            }\n            const instructionData = new FollowProfileInstruction({\n                profile_id: profilePublicKey\n            });\n            const followProfileVariant = Buffer.from([\n                5\n            ]) // FollowProfile enum index\n            ;\n            const serializedData = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.serialize)(followProfileSchema, instructionData);\n            const fullInstructionData = Buffer.concat([\n                followProfileVariant,\n                Buffer.from(serializedData)\n            ]);\n            const instruction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: publicKey,\n                        isSigner: true,\n                        isWritable: false\n                    },\n                    {\n                        pubkey: profilePublicKey,\n                        isSigner: false,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: followerProfileAddress,\n                        isSigner: false,\n                        isWritable: true\n                    }\n                ],\n                programId: PROGRAM_ID,\n                data: fullInstructionData\n            });\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction().add(instruction);\n            const signature = await sendTransaction(transaction, connection);\n            await connection.confirmTransaction(signature, \"processed\");\n            // Clear profile cache to force refresh of follower counts\n            clearProfileCache();\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.success(\"Profile followed!\");\n            return signature;\n        } catch (error) {\n            console.error(\"Follow error:\", error);\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Failed to follow profile\");\n            throw error;\n        }\n    };\n    // Unfollow Profile\n    const unfollowProfile = async (profilePublicKey)=>{\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83D\\uDC65 Unfollowing profile:\", profilePublicKey.toString());\n            // Find the follower's profile account (current user's profile)\n            console.log(\"\\uD83D\\uDD0D Searching for follower profile: \".concat(publicKey.toString().slice(0, 8), \"...\"));\n            const accounts = await connection.getProgramAccounts(PROGRAM_ID);\n            let followerProfileAddress = null;\n            for (const { account, pubkey } of accounts){\n                try {\n                    const parsedProfile = manualParseProfile(account.data);\n                    if (parsedProfile && parsedProfile.is_initialized === 1 && new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(parsedProfile.owner).equals(publicKey)) {\n                        followerProfileAddress = pubkey;\n                        console.log(\"✅ Found follower profile account: \".concat(pubkey.toString()));\n                        break;\n                    }\n                } catch (error) {\n                    continue;\n                }\n            }\n            if (!followerProfileAddress) {\n                throw new Error(\"You must create a profile before unfollowing others\");\n            }\n            const instructionData = new FollowProfileInstruction({\n                profile_id: profilePublicKey\n            });\n            const unfollowProfileVariant = Buffer.from([\n                6\n            ]) // UnfollowProfile enum index\n            ;\n            const serializedData = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.serialize)(followProfileSchema, instructionData);\n            const fullInstructionData = Buffer.concat([\n                unfollowProfileVariant,\n                Buffer.from(serializedData)\n            ]);\n            const instruction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: publicKey,\n                        isSigner: true,\n                        isWritable: false\n                    },\n                    {\n                        pubkey: profilePublicKey,\n                        isSigner: false,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: followerProfileAddress,\n                        isSigner: false,\n                        isWritable: true\n                    }\n                ],\n                programId: PROGRAM_ID,\n                data: fullInstructionData\n            });\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction().add(instruction);\n            const signature = await sendTransaction(transaction, connection);\n            await connection.confirmTransaction(signature, \"processed\");\n            // Clear profile cache to force refresh of follower counts\n            clearProfileCache();\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.success(\"Profile unfollowed!\");\n            return signature;\n        } catch (error) {\n            console.error(\"Unfollow error:\", error);\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Failed to unfollow profile\");\n            throw error;\n        }\n    };\n    // Update Profile\n    const updateProfile = async (username, bio, profileImage, coverImage)=>{\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83D\\uDD04 Updating profile:\", username);\n            const instructionData = new CreateProfileInstruction({\n                username,\n                bio,\n                profile_image: profileImage,\n                cover_image: coverImage\n            });\n            const updateProfileVariant = Buffer.from([\n                1\n            ]) // UpdateProfile enum index (same as CreateProfile)\n            ;\n            const serializedData = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.serialize)(createProfileSchema, instructionData);\n            const fullInstructionData = Buffer.concat([\n                updateProfileVariant,\n                Buffer.from(serializedData)\n            ]);\n            const instruction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    }\n                ],\n                programId: PROGRAM_ID,\n                data: fullInstructionData\n            });\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction().add(instruction);\n            const signature = await sendTransaction(transaction, connection);\n            await connection.confirmTransaction(signature, \"processed\");\n            console.log(\"✅ Profile updated successfully!\");\n            // Clear cache to force refresh\n            profileCache.delete(publicKey.toString());\n            return signature;\n        } catch (error) {\n            console.error(\"❌ Update profile error:\", error);\n            throw error;\n        }\n    };\n    // Comment on Post\n    const commentOnPost = async (postId, content, postAuthor)=>{\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83D\\uDCAC Commenting on post ID \".concat(postId, \"...\"));\n            // Check SOL balance first\n            const balance = await checkSOLBalance();\n            if (balance < 0.01) {\n                throw new Error(\"Insufficient SOL balance: \".concat(balance, \". Need at least 0.01 SOL for transaction fees.\"));\n            }\n            // Find the actual post account by scanning all program accounts\n            console.log(\"\\uD83D\\uDD0D Searching for post ID \".concat(postId, \" by author \").concat(postAuthor.toString().slice(0, 8), \"...\"));\n            const accounts = await connection.getProgramAccounts(PROGRAM_ID);\n            let postAddress = null;\n            let userProfileAddress = null;\n            // First pass: find the post account\n            for (const { account, pubkey } of accounts){\n                try {\n                    const parsedPost = manualParsePost(account.data);\n                    if (parsedPost && parsedPost.is_initialized === 1 && Number(parsedPost.id) === postId && new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(parsedPost.author).equals(postAuthor)) {\n                        postAddress = pubkey;\n                        console.log(\"✅ Found post account: \".concat(pubkey.toString()));\n                        break;\n                    }\n                } catch (error) {\n                    continue;\n                }\n            }\n            if (!postAddress) {\n                throw new Error(\"Post with ID \".concat(postId, \" not found\"));\n            }\n            // Second pass: find the commenter's profile account\n            console.log(\"\\uD83D\\uDD0D Searching for commenter profile: \".concat(publicKey.toString().slice(0, 8), \"...\"));\n            for (const { account, pubkey } of accounts){\n                try {\n                    const parsedProfile = manualParseProfile(account.data);\n                    if (parsedProfile && parsedProfile.is_initialized === 1 && new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(parsedProfile.owner).equals(publicKey)) {\n                        userProfileAddress = pubkey;\n                        console.log(\"✅ Found commenter profile account: \".concat(pubkey.toString()));\n                        break;\n                    }\n                } catch (error) {\n                    continue;\n                }\n            }\n            if (!userProfileAddress) {\n                throw new Error(\"You must create a profile before commenting\");\n            }\n            // Generate a new keypair for the comment account\n            const commentKeypair = _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Keypair.generate();\n            console.log(\"\\uD83D\\uDCCD Comment Account: \".concat(commentKeypair.publicKey.toString()));\n            const instructionData = new CommentOnPostInstruction({\n                content,\n                parent_id: BigInt(postId)\n            });\n            const commentVariant = Buffer.from([\n                4\n            ]) // CommentOnPost enum index\n            ;\n            const serializedData = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.serialize)(commentOnPostSchema, instructionData);\n            const fullInstructionData = Buffer.concat([\n                commentVariant,\n                Buffer.from(serializedData)\n            ]);\n            const instruction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: commentKeypair.publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: postAddress,\n                        isSigner: false,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: userProfileAddress,\n                        isSigner: false,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.SystemProgram.programId,\n                        isSigner: false,\n                        isWritable: false\n                    }\n                ],\n                programId: PROGRAM_ID,\n                data: fullInstructionData\n            });\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction().add(instruction);\n            const { blockhash } = await connection.getLatestBlockhash(\"processed\");\n            transaction.recentBlockhash = blockhash;\n            transaction.feePayer = publicKey;\n            // Sign with comment keypair\n            transaction.partialSign(commentKeypair);\n            console.log(\"\\uD83C\\uDFAF Simulating transaction...\");\n            const simulation = await connection.simulateTransaction(transaction);\n            console.log(\"\\uD83D\\uDCCA Simulation result:\", simulation);\n            if (simulation.value.err) {\n                console.error(\"❌ Simulation failed:\", simulation.value.err);\n                throw new Error(\"Transaction simulation failed: \".concat(JSON.stringify(simulation.value.err)));\n            }\n            const signature = await sendTransaction(transaction, connection, {\n                skipPreflight: false,\n                preflightCommitment: \"processed\",\n                maxRetries: 3,\n                signers: [\n                    commentKeypair\n                ]\n            });\n            await connection.confirmTransaction({\n                signature,\n                blockhash,\n                lastValidBlockHeight: (await connection.getLatestBlockhash()).lastValidBlockHeight\n            }, \"processed\");\n            console.log(\"✅ Comment posted successfully!\");\n            // Clear posts cache to force refresh\n            postsCache = null;\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.success(\"Comment posted!\");\n            return signature;\n        } catch (error) {\n            console.error(\"❌ Comment post error:\", error);\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Failed to comment: \".concat(error.message || \"Unknown error\"));\n            throw error;\n        }\n    };\n    // Bookmark Post (using localStorage since we don't have bookmark functionality)\n    const bookmarkPost = async (postId)=>{\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83D\\uDD16 Bookmarking post ID \".concat(postId, \"...\"));\n            const bookmarksKey = \"bookmarks_\".concat(publicKey.toString());\n            const existingBookmarks = localStorage.getItem(bookmarksKey);\n            const bookmarks = existingBookmarks ? JSON.parse(existingBookmarks) : [];\n            if (bookmarks.includes(postId)) {\n                // Remove bookmark\n                const updatedBookmarks = bookmarks.filter((id)=>id !== postId);\n                localStorage.setItem(bookmarksKey, JSON.stringify(updatedBookmarks));\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.success(\"Bookmark removed!\");\n            } else {\n                // Add bookmark\n                bookmarks.push(postId);\n                localStorage.setItem(bookmarksKey, JSON.stringify(bookmarks));\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.success(\"Post bookmarked!\");\n            }\n            return \"bookmarked\";\n        } catch (error) {\n            console.error(\"❌ Bookmark error:\", error);\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Failed to bookmark post\");\n            throw error;\n        }\n    };\n    // Get user bookmarks\n    const getUserBookmarks = ()=>{\n        if (!publicKey) return [];\n        try {\n            const bookmarksKey = \"bookmarks_\".concat(publicKey.toString());\n            const existingBookmarks = localStorage.getItem(bookmarksKey);\n            return existingBookmarks ? JSON.parse(existingBookmarks) : [];\n        } catch (error) {\n            console.error(\"Failed to get bookmarks:\", error);\n            return [];\n        }\n    };\n    // Check if post is bookmarked\n    const isPostBookmarked = (postId)=>{\n        const bookmarks = getUserBookmarks();\n        return bookmarks.includes(postId);\n    };\n    // Utility function to preload profile on wallet connection\n    const preloadProfile = async ()=>{\n        if (!publicKey) return;\n        console.log(\"\\uD83D\\uDE80 Preloading profile on wallet connection...\");\n        try {\n            await getProfile(publicKey);\n        } catch (error) {\n            console.warn(\"Failed to preload profile:\", error);\n        }\n    };\n    // Force refresh all data - clears all caches\n    const refreshData = ()=>{\n        console.log(\"\\uD83D\\uDD04 Force refreshing all data...\");\n        clearProfileCache();\n        postsCache = null;\n    };\n    return {\n        createProfile,\n        createPost,\n        likePost,\n        getProfile,\n        getProfileByUsername,\n        getPosts,\n        getProfilePDA,\n        getPostPDA,\n        checkProfileAtPDA,\n        preloadProfile,\n        clearProfileCache,\n        refreshData,\n        createCommunity,\n        followProfile,\n        unfollowProfile,\n        updateProfile,\n        commentOnPost,\n        bookmarkPost,\n        getUserBookmarks,\n        isPostBookmarked\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZUJsb2Nrc1Byb2dyYW0udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUF1RTtBQUNtRDtBQUM1RTtBQUNQO0FBQ047QUFFakMseURBQXlEO0FBQ3pELE1BQU1ZLGFBQWEsSUFBSVYsc0RBQVNBLENBQUNTLDJDQUFNQSxDQUFDRSxNQUFNLENBQUNDLFNBQVM7QUFFeEQsb0VBQW9FO0FBQ3BFLE1BQU1DLGFBQWFDLGtCQUF5Qjs7QUFFNUMsK0NBQStDO1VBQzFDQzs7Ozs7Ozs7OztHQUFBQSx3QkFBQUE7O1VBYU9DOzs7Ozs7Ozs7R0FBQUEsZUFBQUE7QUFXWix3Q0FBd0M7QUFDeEMsTUFBTUM7SUFNSkMsWUFBWUMsTUFLWCxDQUFFO1FBQ0QsSUFBSSxDQUFDQyxRQUFRLEdBQUdELE9BQU9DLFFBQVE7UUFDL0IsSUFBSSxDQUFDQyxHQUFHLEdBQUdGLE9BQU9FLEdBQUc7UUFDckIsSUFBSSxDQUFDQyxhQUFhLEdBQUdILE9BQU9HLGFBQWE7UUFDekMsSUFBSSxDQUFDQyxXQUFXLEdBQUdKLE9BQU9JLFdBQVc7SUFDdkM7QUFDRjtBQUVBLHFDQUFxQztBQUNyQyxNQUFNQztJQUlKTixZQUFZQyxNQUdYLENBQUU7UUFDRCxJQUFJLENBQUNNLE9BQU8sR0FBR04sT0FBT00sT0FBTztRQUM3QixJQUFJLENBQUNDLE1BQU0sR0FBR1AsT0FBT08sTUFBTTtJQUM3QjtBQUNGO0FBRUEsbUNBQW1DO0FBQ25DLE1BQU1DO0lBR0pULFlBQVlDLE1BRVgsQ0FBRTtRQUNELElBQUksQ0FBQ1MsT0FBTyxHQUFHVCxPQUFPUyxPQUFPO0lBQy9CO0FBQ0Y7QUFFQSx5Q0FBeUM7QUFDekMsTUFBTUM7SUFJSlgsWUFBWUMsTUFHWCxDQUFFO1FBQ0QsSUFBSSxDQUFDTSxPQUFPLEdBQUdOLE9BQU9NLE9BQU87UUFDN0IsSUFBSSxDQUFDSyxTQUFTLEdBQUdYLE9BQU9XLFNBQVM7SUFDbkM7QUFDRjtBQUVBLHVDQUF1QztBQUN2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UUFDQUM7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2hvb2tzL3VzZUJsb2Nrc1Byb2dyYW0udHM/NWU4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VDb25uZWN0aW9uLCB1c2VXYWxsZXQgfSBmcm9tICdAc29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0J1xyXG5pbXBvcnQgeyBQdWJsaWNLZXksIFRyYW5zYWN0aW9uLCBUcmFuc2FjdGlvbkluc3RydWN0aW9uLCBTeXN0ZW1Qcm9ncmFtLCBMQU1QT1JUU19QRVJfU09MLCBLZXlwYWlyIH0gZnJvbSAnQHNvbGFuYS93ZWIzLmpzJ1xyXG5pbXBvcnQgeyBzZXJpYWxpemUsIGRlc2VyaWFsaXplIH0gZnJvbSAnYm9yc2gnXHJcbmltcG9ydCB7IHRvYXN0IH0gZnJvbSAncmVhY3QtaG90LXRvYXN0J1xyXG5pbXBvcnQgeyBjb25maWcgfSBmcm9tICdAL2NvbmZpZydcclxuXHJcbi8vIFlvdXIgZGVwbG95ZWQgcHJvZ3JhbSBJRCAtIGNvbmZpZ3VyZWQgZnJvbSBlbnZpcm9ubWVudFxyXG5jb25zdCBQUk9HUkFNX0lEID0gbmV3IFB1YmxpY0tleShjb25maWcuc29sYW5hLnByb2dyYW1JZClcclxuXHJcbi8vIEFkZCBkZWJ1ZyBtb2RlIGZvciB0ZXN0aW5nIHdpdGhvdXQgYWN0dWFsIGJsb2NrY2hhaW4gdHJhbnNhY3Rpb25zXHJcbmNvbnN0IERFQlVHX01PREUgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50J1xyXG5cclxuLy8gSW5zdHJ1Y3Rpb24gZW51bSBtYXRjaGluZyB5b3VyIFJ1c3QgY29udHJhY3RcclxuZW51bSBDb250cmFjdEluc3RydWN0aW9uIHtcclxuICBDcmVhdGVQcm9maWxlID0gMCxcclxuICBVcGRhdGVQcm9maWxlID0gMSxcclxuICBDcmVhdGVQb3N0ID0gMixcclxuICBMaWtlUG9zdCA9IDMsXHJcbiAgQ29tbWVudE9uUG9zdCA9IDQsXHJcbiAgRm9sbG93UHJvZmlsZSA9IDUsXHJcbiAgVW5mb2xsb3dQcm9maWxlID0gNixcclxuICBDcmVhdGVDb21tdW5pdHkgPSA3LFxyXG4gIEpvaW5Db21tdW5pdHkgPSA4LFxyXG59XHJcblxyXG4vLyBQb3N0UmF0aW5nIGVudW0gbWF0Y2hpbmcgUnVzdCBjb250cmFjdFxyXG5leHBvcnQgZW51bSBQb3N0UmF0aW5nIHtcclxuICBOb25lID0gMCxcclxuICBCcm9uemUgPSAxLFxyXG4gIFNpbHZlciA9IDIsXHJcbiAgR29sZCA9IDMsXHJcbiAgUGxhdGludW0gPSA0LFxyXG4gIERpYW1vbmQgPSA1LFxyXG4gIEFjZSA9IDYsXHJcbiAgQ29ucXVlcm9yID0gNyxcclxufVxyXG5cclxuLy8gQ3JlYXRlIFByb2ZpbGUgaW5zdHJ1Y3Rpb24gZGF0YSBjbGFzc1xyXG5jbGFzcyBDcmVhdGVQcm9maWxlSW5zdHJ1Y3Rpb24ge1xyXG4gIHVzZXJuYW1lOiBzdHJpbmdcclxuICBiaW86IHN0cmluZ1xyXG4gIHByb2ZpbGVfaW1hZ2U6IHN0cmluZ1xyXG4gIGNvdmVyX2ltYWdlOiBzdHJpbmdcclxuXHJcbiAgY29uc3RydWN0b3IoZmllbGRzOiB7XHJcbiAgICB1c2VybmFtZTogc3RyaW5nXHJcbiAgICBiaW86IHN0cmluZ1xyXG4gICAgcHJvZmlsZV9pbWFnZTogc3RyaW5nXHJcbiAgICBjb3Zlcl9pbWFnZTogc3RyaW5nXHJcbiAgfSkge1xyXG4gICAgdGhpcy51c2VybmFtZSA9IGZpZWxkcy51c2VybmFtZVxyXG4gICAgdGhpcy5iaW8gPSBmaWVsZHMuYmlvXHJcbiAgICB0aGlzLnByb2ZpbGVfaW1hZ2UgPSBmaWVsZHMucHJvZmlsZV9pbWFnZVxyXG4gICAgdGhpcy5jb3Zlcl9pbWFnZSA9IGZpZWxkcy5jb3Zlcl9pbWFnZVxyXG4gIH1cclxufVxyXG5cclxuLy8gQ3JlYXRlIFBvc3QgaW5zdHJ1Y3Rpb24gZGF0YSBjbGFzc1xyXG5jbGFzcyBDcmVhdGVQb3N0SW5zdHJ1Y3Rpb24ge1xyXG4gIGNvbnRlbnQ6IHN0cmluZ1xyXG4gIGltYWdlczogc3RyaW5nW11cclxuXHJcbiAgY29uc3RydWN0b3IoZmllbGRzOiB7XHJcbiAgICBjb250ZW50OiBzdHJpbmdcclxuICAgIGltYWdlczogc3RyaW5nW11cclxuICB9KSB7XHJcbiAgICB0aGlzLmNvbnRlbnQgPSBmaWVsZHMuY29udGVudFxyXG4gICAgdGhpcy5pbWFnZXMgPSBmaWVsZHMuaW1hZ2VzXHJcbiAgfVxyXG59XHJcblxyXG4vLyBMaWtlIFBvc3QgaW5zdHJ1Y3Rpb24gZGF0YSBjbGFzc1xyXG5jbGFzcyBMaWtlUG9zdEluc3RydWN0aW9uIHtcclxuICBwb3N0X2lkOiBiaWdpbnRcclxuXHJcbiAgY29uc3RydWN0b3IoZmllbGRzOiB7XHJcbiAgICBwb3N0X2lkOiBiaWdpbnRcclxuICB9KSB7XHJcbiAgICB0aGlzLnBvc3RfaWQgPSBmaWVsZHMucG9zdF9pZFxyXG4gIH1cclxufVxyXG5cclxuLy8gQ29tbWVudCBPbiBQb3N0IGluc3RydWN0aW9uIGRhdGEgY2xhc3NcclxuY2xhc3MgQ29tbWVudE9uUG9zdEluc3RydWN0aW9uIHtcclxuICBjb250ZW50OiBzdHJpbmdcclxuICBwYXJlbnRfaWQ6IGJpZ2ludFxyXG5cclxuICBjb25zdHJ1Y3RvcihmaWVsZHM6IHtcclxuICAgIGNvbnRlbnQ6IHN0cmluZ1xyXG4gICAgcGFyZW50X2lkOiBiaWdpbnRcclxuICB9KSB7XHJcbiAgICB0aGlzLmNvbnRlbnQgPSBmaWVsZHMuY29udGVudFxyXG4gICAgdGhpcy5wYXJlbnRfaWQgPSBmaWVsZHMucGFyZW50X2lkXHJcbiAgfVxyXG59XHJcblxyXG4vLyBCb29rbWFyayBQb3N0IGluc3RydWN0aW9uIGRhdGEgY2xhc3NcclxuY2xhc3MgQm9va21hcmtQb3N0SW5zdHJ1Y3Rpb24ge1xyXG4gIHBvc3RfaWQ6IGJpZ2ludFxyXG5cclxuICBjb25zdHJ1Y3RvcihmaWVsZHM6IHtcclxuICAgIHBvc3RfaWQ6IGJpZ2ludFxyXG4gIH0pIHtcclxuICAgIHRoaXMucG9zdF9pZCA9IGZpZWxkcy5wb3N0X2lkXHJcbiAgfVxyXG59XHJcblxyXG4vLyBQcm9maWxlIHN0cnVjdCBmb3IgZGVzZXJpYWxpemF0aW9uIC0gbWF0Y2hpbmcgUnVzdCBleGFjdGx5XHJcbmNsYXNzIFByb2ZpbGVBY2NvdW50IHtcclxuICBpc19pbml0aWFsaXplZDogbnVtYmVyICAvLyB1OCBmcm9tIFJ1c3QgYm9vbFxyXG4gIG93bmVyOiBVaW50OEFycmF5XHJcbiAgdXNlcm5hbWU6IHN0cmluZ1xyXG4gIGJpbzogc3RyaW5nXHJcbiAgcHJvZmlsZV9pbWFnZTogc3RyaW5nXHJcbiAgY292ZXJfaW1hZ2U6IHN0cmluZ1xyXG4gIGNyZWF0ZWRfYXQ6IGJpZ2ludFxyXG4gIGZvbGxvd2Vyc19jb3VudDogYmlnaW50XHJcbiAgZm9sbG93aW5nX2NvdW50OiBiaWdpbnRcclxuICB1c2VyX2NyZWRpdF9yYXRpbmc6IGJpZ2ludFxyXG4gIHBvc3RzX2NvdW50OiBiaWdpbnRcclxuICBsYXN0X3Bvc3RfdGltZXN0YW1wOiBiaWdpbnRcclxuICBkYWlseV9wb3N0X2NvdW50OiBiaWdpbnRcclxuICBpc192ZXJpZmllZDogbnVtYmVyICAvLyB1OCBmcm9tIFJ1c3QgYm9vbFxyXG5cclxuICBjb25zdHJ1Y3RvcihmaWVsZHM6IGFueSkge1xyXG4gICAgdGhpcy5pc19pbml0aWFsaXplZCA9IGZpZWxkcy5pc19pbml0aWFsaXplZFxyXG4gICAgdGhpcy5vd25lciA9IGZpZWxkcy5vd25lclxyXG4gICAgdGhpcy51c2VybmFtZSA9IGZpZWxkcy51c2VybmFtZVxyXG4gICAgdGhpcy5iaW8gPSBmaWVsZHMuYmlvXHJcbiAgICB0aGlzLnByb2ZpbGVfaW1hZ2UgPSBmaWVsZHMucHJvZmlsZV9pbWFnZVxyXG4gICAgdGhpcy5jb3Zlcl9pbWFnZSA9IGZpZWxkcy5jb3Zlcl9pbWFnZVxyXG4gICAgdGhpcy5jcmVhdGVkX2F0ID0gZmllbGRzLmNyZWF0ZWRfYXRcclxuICAgIHRoaXMuZm9sbG93ZXJzX2NvdW50ID0gZmllbGRzLmZvbGxvd2Vyc19jb3VudFxyXG4gICAgdGhpcy5mb2xsb3dpbmdfY291bnQgPSBmaWVsZHMuZm9sbG93aW5nX2NvdW50XHJcbiAgICB0aGlzLnVzZXJfY3JlZGl0X3JhdGluZyA9IGZpZWxkcy51c2VyX2NyZWRpdF9yYXRpbmdcclxuICAgIHRoaXMucG9zdHNfY291bnQgPSBmaWVsZHMucG9zdHNfY291bnRcclxuICAgIHRoaXMubGFzdF9wb3N0X3RpbWVzdGFtcCA9IGZpZWxkcy5sYXN0X3Bvc3RfdGltZXN0YW1wXHJcbiAgICB0aGlzLmRhaWx5X3Bvc3RfY291bnQgPSBmaWVsZHMuZGFpbHlfcG9zdF9jb3VudFxyXG4gICAgdGhpcy5pc192ZXJpZmllZCA9IGZpZWxkcy5pc192ZXJpZmllZFxyXG4gIH1cclxufVxyXG5cclxuLy8gUG9zdCBzdHJ1Y3QgZm9yIGRlc2VyaWFsaXphdGlvbiAtIG1hdGNoaW5nIFJ1c3QgZXhhY3RseVxyXG5jbGFzcyBQb3N0QWNjb3VudCB7XHJcbiAgaXNfaW5pdGlhbGl6ZWQ6IG51bWJlciAgLy8gdTggZnJvbSBSdXN0IGJvb2xcclxuICBpZDogYmlnaW50XHJcbiAgYXV0aG9yOiBVaW50OEFycmF5XHJcbiAgY29udGVudDogc3RyaW5nXHJcbiAgdGltZXN0YW1wOiBiaWdpbnRcclxuICBsaWtlczogYmlnaW50XHJcbiAgY29tbWVudHM6IGJpZ2ludFxyXG4gIG1pcnJvcnM6IGJpZ2ludFxyXG4gIGltYWdlczogc3RyaW5nW11cclxuICByYXRpbmc6IG51bWJlclxyXG4gIGluX2tpbGxfem9uZTogbnVtYmVyICAvLyB1OCBmcm9tIFJ1c3QgYm9vbFxyXG5cclxuICBjb25zdHJ1Y3RvcihmaWVsZHM6IGFueSkge1xyXG4gICAgdGhpcy5pc19pbml0aWFsaXplZCA9IGZpZWxkcy5pc19pbml0aWFsaXplZFxyXG4gICAgdGhpcy5pZCA9IGZpZWxkcy5pZFxyXG4gICAgdGhpcy5hdXRob3IgPSBmaWVsZHMuYXV0aG9yXHJcbiAgICB0aGlzLmNvbnRlbnQgPSBmaWVsZHMuY29udGVudFxyXG4gICAgdGhpcy50aW1lc3RhbXAgPSBmaWVsZHMudGltZXN0YW1wXHJcbiAgICB0aGlzLmxpa2VzID0gZmllbGRzLmxpa2VzXHJcbiAgICB0aGlzLmNvbW1lbnRzID0gZmllbGRzLmNvbW1lbnRzXHJcbiAgICB0aGlzLm1pcnJvcnMgPSBmaWVsZHMubWlycm9yc1xyXG4gICAgdGhpcy5pbWFnZXMgPSBmaWVsZHMuaW1hZ2VzXHJcbiAgICB0aGlzLnJhdGluZyA9IGZpZWxkcy5yYXRpbmdcclxuICAgIHRoaXMuaW5fa2lsbF96b25lID0gZmllbGRzLmluX2tpbGxfem9uZVxyXG4gIH1cclxufVxyXG5cclxuLy8gQm9yc2ggc2NoZW1hc1xyXG5jb25zdCBjcmVhdGVQcm9maWxlU2NoZW1hID0gbmV3IE1hcChbXHJcbiAgW0NyZWF0ZVByb2ZpbGVJbnN0cnVjdGlvbiwge1xyXG4gICAga2luZDogJ3N0cnVjdCcsXHJcbiAgICBmaWVsZHM6IFtcclxuICAgICAgWyd1c2VybmFtZScsICdzdHJpbmcnXSxcclxuICAgICAgWydiaW8nLCAnc3RyaW5nJ10sXHJcbiAgICAgIFsncHJvZmlsZV9pbWFnZScsICdzdHJpbmcnXSxcclxuICAgICAgWydjb3Zlcl9pbWFnZScsICdzdHJpbmcnXSxcclxuICAgIF0sXHJcbiAgfV0sXHJcbl0pXHJcblxyXG5jb25zdCBjcmVhdGVQb3N0U2NoZW1hID0gbmV3IE1hcChbXHJcbiAgW0NyZWF0ZVBvc3RJbnN0cnVjdGlvbiwge1xyXG4gICAga2luZDogJ3N0cnVjdCcsXHJcbiAgICBmaWVsZHM6IFtcclxuICAgICAgWydjb250ZW50JywgJ3N0cmluZyddLFxyXG4gICAgICBbJ2ltYWdlcycsIFsnc3RyaW5nJ11dLFxyXG4gICAgXSxcclxuICB9XSxcclxuXSlcclxuXHJcbmNvbnN0IGxpa2VQb3N0U2NoZW1hID0gbmV3IE1hcChbXHJcbiAgW0xpa2VQb3N0SW5zdHJ1Y3Rpb24sIHtcclxuICAgIGtpbmQ6ICdzdHJ1Y3QnLFxyXG4gICAgZmllbGRzOiBbXHJcbiAgICAgIFsncG9zdF9pZCcsICd1NjQnXSxcclxuICAgIF0sXHJcbiAgfV0sXHJcbl0pXHJcblxyXG5jb25zdCBjb21tZW50T25Qb3N0U2NoZW1hID0gbmV3IE1hcChbXHJcbiAgW0NvbW1lbnRPblBvc3RJbnN0cnVjdGlvbiwge1xyXG4gICAga2luZDogJ3N0cnVjdCcsXHJcbiAgICBmaWVsZHM6IFtcclxuICAgICAgWydjb250ZW50JywgJ3N0cmluZyddLFxyXG4gICAgICBbJ3BhcmVudF9pZCcsICd1NjQnXSxcclxuICAgIF0sXHJcbiAgfV0sXHJcbl0pXHJcblxyXG5jb25zdCBib29rbWFya1Bvc3RTY2hlbWEgPSBuZXcgTWFwKFtcclxuICBbQm9va21hcmtQb3N0SW5zdHJ1Y3Rpb24sIHtcclxuICAgIGtpbmQ6ICdzdHJ1Y3QnLFxyXG4gICAgZmllbGRzOiBbXHJcbiAgICAgIFsncG9zdF9pZCcsICd1NjQnXSxcclxuICAgIF0sXHJcbiAgfV0sXHJcbl0pXHJcblxyXG5jb25zdCBwcm9maWxlQWNjb3VudFNjaGVtYSA9IG5ldyBNYXAoW1xyXG4gIFtQcm9maWxlQWNjb3VudCwge1xyXG4gICAga2luZDogJ3N0cnVjdCcsXHJcbiAgICBmaWVsZHM6IFtcclxuICAgICAgWydpc19pbml0aWFsaXplZCcsICd1OCddLCAgLy8gUnVzdCBib29sIGlzIHNlcmlhbGl6ZWQgYXMgdThcclxuICAgICAgWydvd25lcicsIFszMl1dLFxyXG4gICAgICBbJ3VzZXJuYW1lJywgJ3N0cmluZyddLFxyXG4gICAgICBbJ2JpbycsICdzdHJpbmcnXSxcclxuICAgICAgWydwcm9maWxlX2ltYWdlJywgJ3N0cmluZyddLFxyXG4gICAgICBbJ2NvdmVyX2ltYWdlJywgJ3N0cmluZyddLFxyXG4gICAgICBbJ2NyZWF0ZWRfYXQnLCAndTY0J10sXHJcbiAgICAgIFsnZm9sbG93ZXJzX2NvdW50JywgJ3U2NCddLFxyXG4gICAgICBbJ2ZvbGxvd2luZ19jb3VudCcsICd1NjQnXSxcclxuICAgICAgWyd1c2VyX2NyZWRpdF9yYXRpbmcnLCAnaTY0J10sXHJcbiAgICAgIFsncG9zdHNfY291bnQnLCAndTY0J10sXHJcbiAgICAgIFsnbGFzdF9wb3N0X3RpbWVzdGFtcCcsICd1NjQnXSxcclxuICAgICAgWydkYWlseV9wb3N0X2NvdW50JywgJ3U2NCddLFxyXG4gICAgICBbJ2lzX3ZlcmlmaWVkJywgJ3U4J10sICAvLyBSdXN0IGJvb2wgaXMgc2VyaWFsaXplZCBhcyB1OFxyXG4gICAgXSxcclxuICB9XSxcclxuXSlcclxuXHJcbmNvbnN0IHBvc3RBY2NvdW50U2NoZW1hID0gbmV3IE1hcChbXHJcbiAgW1Bvc3RBY2NvdW50LCB7XHJcbiAgICBraW5kOiAnc3RydWN0JyxcclxuICAgIGZpZWxkczogW1xyXG4gICAgICBbJ2lzX2luaXRpYWxpemVkJywgJ3U4J10sICAvLyBSdXN0IGJvb2wgaXMgc2VyaWFsaXplZCBhcyB1OFxyXG4gICAgICBbJ2lkJywgJ3U2NCddLFxyXG4gICAgICBbJ2F1dGhvcicsIFszMl1dLFxyXG4gICAgICBbJ2NvbnRlbnQnLCAnc3RyaW5nJ10sXHJcbiAgICAgIFsndGltZXN0YW1wJywgJ3U2NCddLFxyXG4gICAgICBbJ2xpa2VzJywgJ3U2NCddLFxyXG4gICAgICBbJ2NvbW1lbnRzJywgJ3U2NCddLFxyXG4gICAgICBbJ21pcnJvcnMnLCAndTY0J10sXHJcbiAgICAgIFsnaW1hZ2VzJywgWydzdHJpbmcnXV0sXHJcbiAgICAgIFsncmF0aW5nJywgJ3U4J10sXHJcbiAgICAgIFsnaW5fa2lsbF96b25lJywgJ3U4J10sICAvLyBSdXN0IGJvb2wgaXMgc2VyaWFsaXplZCBhcyB1OFxyXG4gICAgXSxcclxuICB9XSxcclxuXSlcclxuXHJcbi8vIENvbW11bml0eS9TdWJCbG9jayBpbnRlcmZhY2VcclxuZXhwb3J0IGludGVyZmFjZSBDb21tdW5pdHkge1xyXG4gIGlzSW5pdGlhbGl6ZWQ6IGJvb2xlYW5cclxuICBpZDogbnVtYmVyXHJcbiAgY3JlYXRvcjogUHVibGljS2V5XHJcbiAgbmFtZTogc3RyaW5nXHJcbiAgZGVzY3JpcHRpb246IHN0cmluZ1xyXG4gIGF2YXRhcjogc3RyaW5nXHJcbiAgcnVsZXM6IHN0cmluZ1tdXHJcbiAgbWVtYmVyQ291bnQ6IG51bWJlclxyXG4gIGNyZWF0ZWRBdDogbnVtYmVyXHJcbiAgaXNQcml2YXRlOiBib29sZWFuXHJcbn1cclxuXHJcbi8vIENvbW11bml0eSBzdHJ1Y3QgZm9yIGRlc2VyaWFsaXphdGlvblxyXG5jbGFzcyBDb21tdW5pdHlBY2NvdW50IHtcclxuICBpc19pbml0aWFsaXplZDogbnVtYmVyXHJcbiAgaWQ6IGJpZ2ludFxyXG4gIGNyZWF0b3I6IFVpbnQ4QXJyYXlcclxuICBuYW1lOiBzdHJpbmdcclxuICBkZXNjcmlwdGlvbjogc3RyaW5nXHJcbiAgYXZhdGFyOiBzdHJpbmdcclxuICBydWxlczogc3RyaW5nW11cclxuICBtZW1iZXJfY291bnQ6IGJpZ2ludFxyXG4gIGNyZWF0ZWRfYXQ6IGJpZ2ludFxyXG4gIGlzX3ByaXZhdGU6IG51bWJlclxyXG5cclxuICBjb25zdHJ1Y3RvcihmaWVsZHM6IGFueSkge1xyXG4gICAgdGhpcy5pc19pbml0aWFsaXplZCA9IGZpZWxkcy5pc19pbml0aWFsaXplZFxyXG4gICAgdGhpcy5pZCA9IGZpZWxkcy5pZFxyXG4gICAgdGhpcy5jcmVhdG9yID0gZmllbGRzLmNyZWF0b3JcclxuICAgIHRoaXMubmFtZSA9IGZpZWxkcy5uYW1lXHJcbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gZmllbGRzLmRlc2NyaXB0aW9uXHJcbiAgICB0aGlzLmF2YXRhciA9IGZpZWxkcy5hdmF0YXJcclxuICAgIHRoaXMucnVsZXMgPSBmaWVsZHMucnVsZXNcclxuICAgIHRoaXMubWVtYmVyX2NvdW50ID0gZmllbGRzLm1lbWJlcl9jb3VudFxyXG4gICAgdGhpcy5jcmVhdGVkX2F0ID0gZmllbGRzLmNyZWF0ZWRfYXRcclxuICAgIHRoaXMuaXNfcHJpdmF0ZSA9IGZpZWxkcy5pc19wcml2YXRlXHJcbiAgfVxyXG59XHJcblxyXG4vLyBDcmVhdGUgQ29tbXVuaXR5IGluc3RydWN0aW9uXHJcbmNsYXNzIENyZWF0ZUNvbW11bml0eUluc3RydWN0aW9uIHtcclxuICBuYW1lOiBzdHJpbmdcclxuICBkZXNjcmlwdGlvbjogc3RyaW5nXHJcbiAgYXZhdGFyOiBzdHJpbmdcclxuICBydWxlczogc3RyaW5nW11cclxuXHJcbiAgY29uc3RydWN0b3IoZmllbGRzOiB7XHJcbiAgICBuYW1lOiBzdHJpbmdcclxuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmdcclxuICAgIGF2YXRhcjogc3RyaW5nXHJcbiAgICBydWxlczogc3RyaW5nW11cclxuICB9KSB7XHJcbiAgICB0aGlzLm5hbWUgPSBmaWVsZHMubmFtZVxyXG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IGZpZWxkcy5kZXNjcmlwdGlvblxyXG4gICAgdGhpcy5hdmF0YXIgPSBmaWVsZHMuYXZhdGFyXHJcbiAgICB0aGlzLnJ1bGVzID0gZmllbGRzLnJ1bGVzXHJcbiAgfVxyXG59XHJcblxyXG4vLyBGb2xsb3cgUHJvZmlsZSBpbnN0cnVjdGlvblxyXG5jbGFzcyBGb2xsb3dQcm9maWxlSW5zdHJ1Y3Rpb24ge1xyXG4gIHByb2ZpbGVfaWQ6IFVpbnQ4QXJyYXlcclxuXHJcbiAgY29uc3RydWN0b3IoZmllbGRzOiB7XHJcbiAgICBwcm9maWxlX2lkOiBQdWJsaWNLZXlcclxuICB9KSB7XHJcbiAgICB0aGlzLnByb2ZpbGVfaWQgPSBmaWVsZHMucHJvZmlsZV9pZC50b0J1ZmZlcigpXHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBjcmVhdGVDb21tdW5pdHlTY2hlbWEgPSBuZXcgTWFwKFtcclxuICBbQ3JlYXRlQ29tbXVuaXR5SW5zdHJ1Y3Rpb24sIHtcclxuICAgIGtpbmQ6ICdzdHJ1Y3QnLFxyXG4gICAgZmllbGRzOiBbXHJcbiAgICAgIFsnbmFtZScsICdzdHJpbmcnXSxcclxuICAgICAgWydkZXNjcmlwdGlvbicsICdzdHJpbmcnXSxcclxuICAgICAgWydhdmF0YXInLCAnc3RyaW5nJ10sXHJcbiAgICAgIFsncnVsZXMnLCBbJ3N0cmluZyddXSxcclxuICAgIF0sXHJcbiAgfV0sXHJcbl0pXHJcblxyXG5jb25zdCBmb2xsb3dQcm9maWxlU2NoZW1hID0gbmV3IE1hcChbXHJcbiAgW0ZvbGxvd1Byb2ZpbGVJbnN0cnVjdGlvbiwge1xyXG4gICAga2luZDogJ3N0cnVjdCcsXHJcbiAgICBmaWVsZHM6IFtcclxuICAgICAgWydwcm9maWxlX2lkJywgWzMyXV0sXHJcbiAgICBdLFxyXG4gIH1dLFxyXG5dKVxyXG5cclxuY29uc3QgY29tbXVuaXR5QWNjb3VudFNjaGVtYSA9IG5ldyBNYXAoW1xyXG4gIFtDb21tdW5pdHlBY2NvdW50LCB7XHJcbiAgICBraW5kOiAnc3RydWN0JyxcclxuICAgIGZpZWxkczogW1xyXG4gICAgICBbJ2lzX2luaXRpYWxpemVkJywgJ3U4J10sXHJcbiAgICAgIFsnaWQnLCAndTY0J10sXHJcbiAgICAgIFsnY3JlYXRvcicsIFszMl1dLFxyXG4gICAgICBbJ25hbWUnLCAnc3RyaW5nJ10sXHJcbiAgICAgIFsnZGVzY3JpcHRpb24nLCAnc3RyaW5nJ10sXHJcbiAgICAgIFsnYXZhdGFyJywgJ3N0cmluZyddLFxyXG4gICAgICBbJ3J1bGVzJywgWydzdHJpbmcnXV0sXHJcbiAgICAgIFsnbWVtYmVyX2NvdW50JywgJ3U2NCddLFxyXG4gICAgICBbJ2NyZWF0ZWRfYXQnLCAndTY0J10sXHJcbiAgICAgIFsnaXNfcHJpdmF0ZScsICd1OCddLFxyXG4gICAgXSxcclxuICB9XSxcclxuXSlcclxuXHJcbi8vIFByb2ZpbGUgaW50ZXJmYWNlXHJcbmV4cG9ydCBpbnRlcmZhY2UgUHJvZmlsZSB7XHJcbiAgaXNJbml0aWFsaXplZDogYm9vbGVhblxyXG4gIG93bmVyOiBQdWJsaWNLZXlcclxuICB1c2VybmFtZTogc3RyaW5nXHJcbiAgYmlvOiBzdHJpbmdcclxuICBwcm9maWxlSW1hZ2U6IHN0cmluZ1xyXG4gIGNvdmVySW1hZ2U6IHN0cmluZ1xyXG4gIGNyZWF0ZWRBdDogbnVtYmVyXHJcbiAgZm9sbG93ZXJzQ291bnQ6IG51bWJlclxyXG4gIGZvbGxvd2luZ0NvdW50OiBudW1iZXJcclxuICB1c2VyQ3JlZGl0UmF0aW5nOiBudW1iZXJcclxuICBwb3N0c0NvdW50OiBudW1iZXJcclxuICBsYXN0UG9zdFRpbWVzdGFtcDogbnVtYmVyXHJcbiAgZGFpbHlQb3N0Q291bnQ6IG51bWJlclxyXG4gIGlzVmVyaWZpZWQ6IGJvb2xlYW5cclxufVxyXG5cclxuLy8gUG9zdCBpbnRlcmZhY2VcclxuZXhwb3J0IGludGVyZmFjZSBQb3N0IHtcclxuICBpc0luaXRpYWxpemVkOiBib29sZWFuXHJcbiAgaWQ6IG51bWJlclxyXG4gIGF1dGhvcjogUHVibGljS2V5XHJcbiAgY29udGVudDogc3RyaW5nXHJcbiAgdGltZXN0YW1wOiBudW1iZXJcclxuICBsaWtlczogbnVtYmVyXHJcbiAgY29tbWVudHM6IG51bWJlclxyXG4gIG1pcnJvcnM6IG51bWJlclxyXG4gIGltYWdlczogc3RyaW5nW11cclxuICByYXRpbmc6IFBvc3RSYXRpbmdcclxuICBpbktpbGxab25lOiBib29sZWFuXHJcbn1cclxuXHJcbi8vIENhY2hlIGZvciBwcm9maWxlIGxvb2t1cHMgdG8gYXZvaWQgcmVwZWF0ZWQgYmxvY2tjaGFpbiBjYWxsc1xyXG5jb25zdCBwcm9maWxlQ2FjaGUgPSBuZXcgTWFwPHN0cmluZywgUHJvZmlsZSB8IG51bGw+KClcclxuY29uc3QgQ0FDSEVfRFVSQVRJT04gPSA2MDAwMCAvLyAxIG1pbnV0ZSBmb3IgbWVtb3J5IGNhY2hlIChpbmNyZWFzZWQgZnJvbSAzMCBzZWNvbmRzKVxyXG5cclxuLy8gUG9zdHMgY2FjaGVcclxubGV0IHBvc3RzQ2FjaGU6IHsgcG9zdHM6IFBvc3RbXSwgdGltZXN0YW1wOiBudW1iZXIgfSB8IG51bGwgPSBudWxsXHJcbmNvbnN0IFBPU1RTX0NBQ0hFX0RVUkFUSU9OID0gMzAwMDAgLy8gMzAgc2Vjb25kcyBmb3IgcG9zdHMgY2FjaGUgKGluY3JlYXNlZCBmcm9tIDEwIHNlY29uZHMpXHJcblxyXG4vLyBsb2NhbFN0b3JhZ2UgY2FjaGUgY29uZmlndXJhdGlvbiAtIFVwZGF0ZWQgdG8gc3VwcG9ydCBtdWx0aXBsZSBwcm9maWxlc1xyXG5jb25zdCBMT0NBTFNUT1JBR0VfQ0FDSEVfUFJFRklYID0gJ2Jsb2Nrc19wcm9maWxlXydcclxuY29uc3QgTE9DQUxTVE9SQUdFX0NBQ0hFX0RVUkFUSU9OID0gMTAgKiA2MCAqIDEwMDAgLy8gMTAgbWludXRlcyBmb3IgbG9jYWxTdG9yYWdlIGNhY2hlIChpbmNyZWFzZWQgZnJvbSA1IG1pbnV0ZXMpXHJcblxyXG5pbnRlcmZhY2UgQ2FjaGVkUHJvZmlsZSB7XHJcbiAgcHJvZmlsZTogUHJvZmlsZSB8IG51bGxcclxuICB0aW1lc3RhbXA6IG51bWJlclxyXG4gIHdhbGxldEFkZHJlc3M6IHN0cmluZ1xyXG59XHJcblxyXG4vLyBsb2NhbFN0b3JhZ2UgY2FjaGUgdXRpbGl0aWVzIC0gVXBkYXRlZCB0byBzdXBwb3J0IG11bHRpcGxlIHByb2ZpbGVzXHJcbmNvbnN0IHNhdmVQcm9maWxlVG9Mb2NhbFN0b3JhZ2UgPSAod2FsbGV0QWRkcmVzczogc3RyaW5nLCBwcm9maWxlOiBQcm9maWxlIHwgbnVsbCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBjYWNoZUtleSA9IGAke0xPQ0FMU1RPUkFHRV9DQUNIRV9QUkVGSVh9JHt3YWxsZXRBZGRyZXNzfWBcclxuICAgIGNvbnN0IGNhY2hlRGF0YTogQ2FjaGVkUHJvZmlsZSA9IHtcclxuICAgICAgcHJvZmlsZSxcclxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICB3YWxsZXRBZGRyZXNzXHJcbiAgICB9XHJcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShjYWNoZUtleSwgSlNPTi5zdHJpbmdpZnkoY2FjaGVEYXRhKSlcclxuICAgIGNvbnNvbGUubG9nKGDwn5K+IFByb2ZpbGUgY2FjaGVkIHRvIGxvY2FsU3RvcmFnZSBmb3IgJHt3YWxsZXRBZGRyZXNzLnNsaWNlKDAsIDgpfWApXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHNhdmUgcHJvZmlsZSB0byBsb2NhbFN0b3JhZ2U6JywgZXJyb3IpXHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBnZXRQcm9maWxlRnJvbUxvY2FsU3RvcmFnZSA9ICh3YWxsZXRBZGRyZXNzOiBzdHJpbmcpOiBQcm9maWxlIHwgbnVsbCA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGNhY2hlS2V5ID0gYCR7TE9DQUxTVE9SQUdFX0NBQ0hFX1BSRUZJWH0ke3dhbGxldEFkZHJlc3N9YFxyXG4gICAgY29uc3QgY2FjaGVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oY2FjaGVLZXkpXHJcbiAgICBpZiAoIWNhY2hlZCkgcmV0dXJuIG51bGxcclxuXHJcbiAgICBjb25zdCBjYWNoZURhdGE6IENhY2hlZFByb2ZpbGUgPSBKU09OLnBhcnNlKGNhY2hlZClcclxuICAgIFxyXG4gICAgLy8gQ2hlY2sgaWYgY2FjaGUgaXMgZXhwaXJlZFxyXG4gICAgaWYgKERhdGUubm93KCkgLSBjYWNoZURhdGEudGltZXN0YW1wID4gTE9DQUxTVE9SQUdFX0NBQ0hFX0RVUkFUSU9OKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDij7AgQ2FjaGUgZXhwaXJlZCBmb3IgJHt3YWxsZXRBZGRyZXNzLnNsaWNlKDAsIDgpfSwgY2xlYXJpbmdgKVxyXG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShjYWNoZUtleSlcclxuICAgICAgcmV0dXJuIG51bGxcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coYOKaoSBVc2luZyBjYWNoZWQgcHJvZmlsZSBmcm9tIGxvY2FsU3RvcmFnZSBmb3IgJHt3YWxsZXRBZGRyZXNzLnNsaWNlKDAsIDgpfWApXHJcbiAgICByZXR1cm4gY2FjaGVEYXRhLnByb2ZpbGVcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gcmVhZCBwcm9maWxlIGZyb20gbG9jYWxTdG9yYWdlOicsIGVycm9yKVxyXG4gICAgY29uc3QgY2FjaGVLZXkgPSBgJHtMT0NBTFNUT1JBR0VfQ0FDSEVfUFJFRklYfSR7d2FsbGV0QWRkcmVzc31gXHJcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShjYWNoZUtleSlcclxuICAgIHJldHVybiBudWxsXHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBjbGVhclByb2ZpbGVDYWNoZSA9ICh3YWxsZXRBZGRyZXNzPzogc3RyaW5nKSA9PiB7XHJcbiAgLy8gQ2xlYXIgbWVtb3J5IGNhY2hlXHJcbiAgaWYgKHdhbGxldEFkZHJlc3MpIHtcclxuICAgIHByb2ZpbGVDYWNoZS5kZWxldGUod2FsbGV0QWRkcmVzcylcclxuICAgIC8vIENsZWFyIGxvY2FsU3RvcmFnZSBjYWNoZSBmb3Igc3BlY2lmaWMgdXNlclxyXG4gICAgY29uc3QgY2FjaGVLZXkgPSBgJHtMT0NBTFNUT1JBR0VfQ0FDSEVfUFJFRklYfSR7d2FsbGV0QWRkcmVzc31gXHJcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShjYWNoZUtleSlcclxuICB9IGVsc2Uge1xyXG4gICAgcHJvZmlsZUNhY2hlLmNsZWFyKClcclxuICAgIC8vIENsZWFyIGFsbCBsb2NhbFN0b3JhZ2UgcHJvZmlsZSBjYWNoZXNcclxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhsb2NhbFN0b3JhZ2UpXHJcbiAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgaWYgKGtleS5zdGFydHNXaXRoKExPQ0FMU1RPUkFHRV9DQUNIRV9QUkVGSVgpKSB7XHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KVxyXG4gICAgICB9XHJcbiAgICB9KVxyXG4gIH1cclxuICBcclxuICAvLyBDbGVhciBwb3N0cyBjYWNoZVxyXG4gIHBvc3RzQ2FjaGUgPSBudWxsXHJcbiAgXHJcbiAgY29uc29sZS5sb2coJ/Cfl5HvuI8gUHJvZmlsZSBhbmQgcG9zdHMgY2FjaGUgY2xlYXJlZCcpXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VCbG9ja3NQcm9ncmFtKCkge1xyXG4gIGNvbnN0IHsgY29ubmVjdGlvbiB9ID0gdXNlQ29ubmVjdGlvbigpXHJcbiAgY29uc3QgeyBwdWJsaWNLZXksIHNlbmRUcmFuc2FjdGlvbiB9ID0gdXNlV2FsbGV0KClcclxuXHJcbiAgLy8gR2V0IHByb2ZpbGUgUERBXHJcbiAgY29uc3QgZ2V0UHJvZmlsZVBEQSA9IGFzeW5jICh1c2VyUHVibGljS2V5OiBQdWJsaWNLZXksIHVzZXJuYW1lOiBzdHJpbmcpOiBQcm9taXNlPFB1YmxpY0tleT4gPT4ge1xyXG4gICAgY29uc3QgW3Byb2ZpbGVQREFdID0gYXdhaXQgUHVibGljS2V5LmZpbmRQcm9ncmFtQWRkcmVzcyhcclxuICAgICAgW3VzZXJQdWJsaWNLZXkudG9CdWZmZXIoKSwgQnVmZmVyLmZyb20oJ3Byb2ZpbGUnKSwgQnVmZmVyLmZyb20odXNlcm5hbWUpXSxcclxuICAgICAgUFJPR1JBTV9JRFxyXG4gICAgKVxyXG4gICAgcmV0dXJuIHByb2ZpbGVQREFcclxuICB9XHJcblxyXG4gIC8vIEdldCBwb3N0IFBEQVxyXG4gIGNvbnN0IGdldFBvc3RQREEgPSBhc3luYyAodXNlclB1YmxpY0tleTogUHVibGljS2V5LCBwb3N0SWQ6IG51bWJlcik6IFByb21pc2U8UHVibGljS2V5PiA9PiB7XHJcbiAgICBjb25zdCBbcG9zdFBEQV0gPSBhd2FpdCBQdWJsaWNLZXkuZmluZFByb2dyYW1BZGRyZXNzKFxyXG4gICAgICBbdXNlclB1YmxpY0tleS50b0J1ZmZlcigpLCBCdWZmZXIuZnJvbSgncG9zdCcpLCBCdWZmZXIuZnJvbShwb3N0SWQudG9TdHJpbmcoKSldLFxyXG4gICAgICBQUk9HUkFNX0lEXHJcbiAgICApXHJcbiAgICByZXR1cm4gcG9zdFBEQVxyXG4gIH1cclxuXHJcbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNoZWNrIGlmIHByb2dyYW0gZXhpc3RzXHJcbiAgY29uc3QgY2hlY2tQcm9ncmFtRXhpc3RzID0gYXN5bmMgKCk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcHJvZ3JhbUluZm8gPSBhd2FpdCBjb25uZWN0aW9uLmdldEFjY291bnRJbmZvKFBST0dSQU1fSUQpXHJcbiAgICAgIHJldHVybiBwcm9ncmFtSW5mbyAhPT0gbnVsbCAmJiBwcm9ncmFtSW5mby5leGVjdXRhYmxlXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBwcm9ncmFtIGV4aXN0ZW5jZTonLCBlcnJvcilcclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY2hlY2sgU09MIGJhbGFuY2VcclxuICBjb25zdCBjaGVja1NPTEJhbGFuY2UgPSBhc3luYyAoKTogUHJvbWlzZTxudW1iZXI+ID0+IHtcclxuICAgIGlmICghcHVibGljS2V5KSByZXR1cm4gMFxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0QmFsYW5jZShwdWJsaWNLZXkpXHJcbiAgICAgIHJldHVybiBiYWxhbmNlIC8gTEFNUE9SVFNfUEVSX1NPTFxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgU09MIGJhbGFuY2U6JywgZXJyb3IpXHJcbiAgICAgIHJldHVybiAwXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBDb252ZXJ0IFByb2ZpbGVBY2NvdW50IHRvIFByb2ZpbGUgaW50ZXJmYWNlXHJcbiAgY29uc3QgY29udmVydFByb2ZpbGVBY2NvdW50ID0gKHByb2ZpbGVBY2NvdW50OiBQcm9maWxlQWNjb3VudCk6IFByb2ZpbGUgPT4ge1xyXG4gICAgLy8gQ2FsY3VsYXRlIFVDUiBiYXNlZCBvbiBhY3Rpdml0eVxyXG4gICAgY29uc3QgY2FsY3VsYXRlVUNSID0gKHByb2ZpbGU6IFByb2ZpbGVBY2NvdW50KSA9PiB7XHJcbiAgICAgIGNvbnN0IHBvc3RzQ291bnQgPSBOdW1iZXIocHJvZmlsZS5wb3N0c19jb3VudClcclxuICAgICAgY29uc3QgZm9sbG93ZXJzQ291bnQgPSBOdW1iZXIocHJvZmlsZS5mb2xsb3dlcnNfY291bnQpXHJcbiAgICAgIGNvbnN0IGZvbGxvd2luZ0NvdW50ID0gTnVtYmVyKHByb2ZpbGUuZm9sbG93aW5nX2NvdW50KVxyXG4gICAgICBcclxuICAgICAgLy8gQmFzZSBVQ1IgY2FsY3VsYXRpb24gYWxnb3JpdGhtXHJcbiAgICAgIGxldCB1Y3IgPSAxLjAgLy8gU3RhcnQgd2l0aCBiYXNlIHJhdGluZ1xyXG4gICAgICBcclxuICAgICAgLy8gUG9zdHMgZmFjdG9yICgwLjEgcG9pbnRzIHBlciBwb3N0LCBtYXggMi4wIHBvaW50cylcclxuICAgICAgY29uc3QgcG9zdHNTY29yZSA9IE1hdGgubWluKHBvc3RzQ291bnQgKiAwLjEsIDIuMClcclxuICAgICAgXHJcbiAgICAgIC8vIEZvbGxvd2VycyBmYWN0b3IgKDAuMDUgcG9pbnRzIHBlciBmb2xsb3dlciwgbWF4IDEuNSBwb2ludHMpXHJcbiAgICAgIGNvbnN0IGZvbGxvd2Vyc1Njb3JlID0gTWF0aC5taW4oZm9sbG93ZXJzQ291bnQgKiAwLjA1LCAxLjUpXHJcbiAgICAgIFxyXG4gICAgICAvLyBGb2xsb3dpbmcvZm9sbG93ZXJzIHJhdGlvIChoZWFsdGh5IHJhdGlvID0gYm9udXMpXHJcbiAgICAgIGxldCByYXRpb0JvbnVzID0gMFxyXG4gICAgICBpZiAoZm9sbG93ZXJzQ291bnQgPiAwICYmIGZvbGxvd2luZ0NvdW50ID4gMCkge1xyXG4gICAgICAgIGNvbnN0IHJhdGlvID0gZm9sbG93ZXJzQ291bnQgLyBmb2xsb3dpbmdDb3VudFxyXG4gICAgICAgIGlmIChyYXRpbyA+PSAwLjUgJiYgcmF0aW8gPD0gMi4wKSB7IC8vIEhlYWx0aHkgcmF0aW9cclxuICAgICAgICAgIHJhdGlvQm9udXMgPSAwLjNcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIEFjY291bnQgYWdlIGZhY3RvciAob2xkZXIgYWNjb3VudHMgZ2V0IGJvbnVzKVxyXG4gICAgICBjb25zdCBhY2NvdW50QWdlID0gRGF0ZS5ub3coKSAtIE51bWJlcihwcm9maWxlLmNyZWF0ZWRfYXQpICogMTAwMFxyXG4gICAgICBjb25zdCBkYXlzT2xkID0gYWNjb3VudEFnZSAvICgxMDAwICogNjAgKiA2MCAqIDI0KVxyXG4gICAgICBjb25zdCBhZ2VCb251cyA9IE1hdGgubWluKGRheXNPbGQgLyAzMCAqIDAuMiwgMS4wKSAvLyAwLjIgcG9pbnRzIHBlciBtb250aCwgbWF4IDEuMFxyXG4gICAgICBcclxuICAgICAgLy8gVmVyaWZpY2F0aW9uIGJvbnVzXHJcbiAgICAgIGNvbnN0IHZlcmlmaWNhdGlvbkJvbnVzID0gcHJvZmlsZS5pc192ZXJpZmllZCA9PT0gMSA/IDAuNSA6IDBcclxuICAgICAgXHJcbiAgICAgIC8vIEFjdGl2aXR5IGZhY3RvciAocG9zdGluZyByZWd1bGFybHkpXHJcbiAgICAgIGNvbnN0IGxhc3RQb3N0QWdlID0gRGF0ZS5ub3coKSAtIE51bWJlcihwcm9maWxlLmxhc3RfcG9zdF90aW1lc3RhbXApICogMTAwMFxyXG4gICAgICBjb25zdCBkYXlzU2luY2VMYXN0UG9zdCA9IGxhc3RQb3N0QWdlIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpXHJcbiAgICAgIGNvbnN0IGFjdGl2aXR5Qm9udXMgPSBkYXlzU2luY2VMYXN0UG9zdCA8IDcgPyAwLjMgOiBkYXlzU2luY2VMYXN0UG9zdCA8IDMwID8gMC4xIDogMFxyXG4gICAgICBcclxuICAgICAgdWNyID0gdWNyICsgcG9zdHNTY29yZSArIGZvbGxvd2Vyc1Njb3JlICsgcmF0aW9Cb251cyArIGFnZUJvbnVzICsgdmVyaWZpY2F0aW9uQm9udXMgKyBhY3Rpdml0eUJvbnVzXHJcbiAgICAgIFxyXG4gICAgICAvLyBDYXAgYXQgNS4wIG1heFxyXG4gICAgICByZXR1cm4gTWF0aC5taW4odWNyLCA1LjApXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgaXNJbml0aWFsaXplZDogcHJvZmlsZUFjY291bnQuaXNfaW5pdGlhbGl6ZWQgPT09IDEsXHJcbiAgICAgIG93bmVyOiBuZXcgUHVibGljS2V5KHByb2ZpbGVBY2NvdW50Lm93bmVyKSxcclxuICAgICAgdXNlcm5hbWU6IHByb2ZpbGVBY2NvdW50LnVzZXJuYW1lLFxyXG4gICAgICBiaW86IHByb2ZpbGVBY2NvdW50LmJpbyxcclxuICAgICAgcHJvZmlsZUltYWdlOiBwcm9maWxlQWNjb3VudC5wcm9maWxlX2ltYWdlLFxyXG4gICAgICBjb3ZlckltYWdlOiBwcm9maWxlQWNjb3VudC5jb3Zlcl9pbWFnZSxcclxuICAgICAgY3JlYXRlZEF0OiBOdW1iZXIocHJvZmlsZUFjY291bnQuY3JlYXRlZF9hdCkgKiAxMDAwLCAvLyBDb252ZXJ0IHNlY29uZHMgdG8gbWlsbGlzZWNvbmRzXHJcbiAgICAgIGZvbGxvd2Vyc0NvdW50OiBOdW1iZXIocHJvZmlsZUFjY291bnQuZm9sbG93ZXJzX2NvdW50KSxcclxuICAgICAgZm9sbG93aW5nQ291bnQ6IE51bWJlcihwcm9maWxlQWNjb3VudC5mb2xsb3dpbmdfY291bnQpLFxyXG4gICAgICB1c2VyQ3JlZGl0UmF0aW5nOiBjYWxjdWxhdGVVQ1IocHJvZmlsZUFjY291bnQpLCAvLyBVc2UgY2FsY3VsYXRlZCBVQ1IgaW5zdGVhZCBvZiBzdG9yZWQgdmFsdWVcclxuICAgICAgcG9zdHNDb3VudDogTnVtYmVyKHByb2ZpbGVBY2NvdW50LnBvc3RzX2NvdW50KSxcclxuICAgICAgbGFzdFBvc3RUaW1lc3RhbXA6IE51bWJlcihwcm9maWxlQWNjb3VudC5sYXN0X3Bvc3RfdGltZXN0YW1wKSAqIDEwMDAsIC8vIENvbnZlcnQgc2Vjb25kcyB0byBtaWxsaXNlY29uZHNcclxuICAgICAgZGFpbHlQb3N0Q291bnQ6IE51bWJlcihwcm9maWxlQWNjb3VudC5kYWlseV9wb3N0X2NvdW50KSxcclxuICAgICAgaXNWZXJpZmllZDogcHJvZmlsZUFjY291bnQuaXNfdmVyaWZpZWQgPT09IDEsXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBDb252ZXJ0IFBvc3RBY2NvdW50IHRvIFBvc3QgaW50ZXJmYWNlXHJcbiAgY29uc3QgY29udmVydFBvc3RBY2NvdW50ID0gKHBvc3RBY2NvdW50OiBQb3N0QWNjb3VudCk6IFBvc3QgPT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgaXNJbml0aWFsaXplZDogcG9zdEFjY291bnQuaXNfaW5pdGlhbGl6ZWQgPT09IDEsXHJcbiAgICAgIGlkOiBOdW1iZXIocG9zdEFjY291bnQuaWQpLFxyXG4gICAgICBhdXRob3I6IG5ldyBQdWJsaWNLZXkocG9zdEFjY291bnQuYXV0aG9yKSxcclxuICAgICAgY29udGVudDogcG9zdEFjY291bnQuY29udGVudCxcclxuICAgICAgdGltZXN0YW1wOiBOdW1iZXIocG9zdEFjY291bnQudGltZXN0YW1wKSAqIDEwMDAsIC8vIENvbnZlcnQgc2Vjb25kcyB0byBtaWxsaXNlY29uZHNcclxuICAgICAgbGlrZXM6IE51bWJlcihwb3N0QWNjb3VudC5saWtlcyksXHJcbiAgICAgIGNvbW1lbnRzOiBOdW1iZXIocG9zdEFjY291bnQuY29tbWVudHMpLFxyXG4gICAgICBtaXJyb3JzOiBOdW1iZXIocG9zdEFjY291bnQubWlycm9ycyksXHJcbiAgICAgIGltYWdlczogcG9zdEFjY291bnQuaW1hZ2VzLFxyXG4gICAgICByYXRpbmc6IHBvc3RBY2NvdW50LnJhdGluZyBhcyBQb3N0UmF0aW5nLFxyXG4gICAgICBpbktpbGxab25lOiBwb3N0QWNjb3VudC5pbl9raWxsX3pvbmUgPT09IDEsXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBDcmVhdGUgdXNlciBwcm9maWxlIC0gUkVBTCBJTVBMRU1FTlRBVElPTlxyXG4gIGNvbnN0IGNyZWF0ZVByb2ZpbGUgPSBhc3luYyAoXHJcbiAgICB1c2VybmFtZTogc3RyaW5nLFxyXG4gICAgYmlvOiBzdHJpbmcsXHJcbiAgICBwcm9maWxlSW1hZ2U6IHN0cmluZyxcclxuICAgIGNvdmVySW1hZ2U6IHN0cmluZ1xyXG4gICkgPT4ge1xyXG4gICAgaWYgKCFwdWJsaWNLZXkpIHRocm93IG5ldyBFcnJvcignV2FsbGV0IG5vdCBjb25uZWN0ZWQnKVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SNIFJ1bm5pbmcgcHJlLWZsaWdodCBjaGVja3MuLi4nKVxyXG4gICAgICBcclxuICAgICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IGNoZWNrU09MQmFsYW5jZSgpXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5KwIFNPTCBCYWxhbmNlOiAke2JhbGFuY2V9YClcclxuICAgICAgaWYgKGJhbGFuY2UgPCAwLjEpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluc3VmZmljaWVudCBTT0wgYmFsYW5jZTogJHtiYWxhbmNlfS4gWW91IG5lZWQgYXQgbGVhc3QgMC4xIFNPTCBmb3IgdHJhbnNhY3Rpb24gZmVlcyBhbmQgYWNjb3VudCBjcmVhdGlvbi5gKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBwcm9ncmFtRXhpc3RzID0gYXdhaXQgY2hlY2tQcm9ncmFtRXhpc3RzKClcclxuICAgICAgY29uc29sZS5sb2coYPCfk4sgUHJvZ3JhbSBleGlzdHM6ICR7cHJvZ3JhbUV4aXN0c31gKVxyXG4gICAgICBpZiAoIXByb2dyYW1FeGlzdHMpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb2dyYW0gbm90IGZvdW5kIGF0IGFkZHJlc3M6ICR7UFJPR1JBTV9JRC50b1N0cmluZygpfS4gTWFrZSBzdXJlIHRoZSBwcm9ncmFtIGlzIGRlcGxveWVkIG9uICR7Y29uZmlnLnNvbGFuYS5uZXR3b3JrfS5gKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFByZS1mbGlnaHQgY2hlY2tzIHBhc3NlZCcpXHJcblxyXG4gICAgICBjb25zdCBwcm9maWxlUERBID0gYXdhaXQgZ2V0UHJvZmlsZVBEQShwdWJsaWNLZXksIHVzZXJuYW1lKVxyXG4gICAgICBjb25zb2xlLmxvZyhg8J+TjSBQcm9maWxlIFBEQTogJHtwcm9maWxlUERBLnRvU3RyaW5nKCl9YClcclxuXHJcbiAgICAgIGNvbnN0IGluc3RydWN0aW9uRGF0YSA9IG5ldyBDcmVhdGVQcm9maWxlSW5zdHJ1Y3Rpb24oe1xyXG4gICAgICAgIHVzZXJuYW1lLFxyXG4gICAgICAgIGJpbyxcclxuICAgICAgICBwcm9maWxlX2ltYWdlOiBwcm9maWxlSW1hZ2UsXHJcbiAgICAgICAgY292ZXJfaW1hZ2U6IGNvdmVySW1hZ2UsXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBjb25zdCBjcmVhdGVQcm9maWxlVmFyaWFudCA9IEJ1ZmZlci5mcm9tKFswXSlcclxuICAgICAgY29uc3Qgc2VyaWFsaXplZERhdGEgPSBzZXJpYWxpemUoY3JlYXRlUHJvZmlsZVNjaGVtYSwgaW5zdHJ1Y3Rpb25EYXRhKVxyXG4gICAgICBjb25zdCBmdWxsSW5zdHJ1Y3Rpb25EYXRhID0gQnVmZmVyLmNvbmNhdChbY3JlYXRlUHJvZmlsZVZhcmlhbnQsIEJ1ZmZlci5mcm9tKHNlcmlhbGl6ZWREYXRhKV0pXHJcblxyXG4gICAgICBjb25zdCBpbnN0cnVjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcclxuICAgICAgICBrZXlzOiBbXHJcbiAgICAgICAgICB7IHB1YmtleTogcHVibGljS2V5LCBpc1NpZ25lcjogdHJ1ZSwgaXNXcml0YWJsZTogdHJ1ZSB9LFxyXG4gICAgICAgICAgeyBwdWJrZXk6IHByb2ZpbGVQREEsIGlzU2lnbmVyOiBmYWxzZSwgaXNXcml0YWJsZTogdHJ1ZSB9LFxyXG4gICAgICAgICAgeyBwdWJrZXk6IFN5c3RlbVByb2dyYW0ucHJvZ3JhbUlkLCBpc1NpZ25lcjogZmFsc2UsIGlzV3JpdGFibGU6IGZhbHNlIH0sXHJcbiAgICAgICAgXSxcclxuICAgICAgICBwcm9ncmFtSWQ6IFBST0dSQU1fSUQsXHJcbiAgICAgICAgZGF0YTogZnVsbEluc3RydWN0aW9uRGF0YSxcclxuICAgICAgfSlcclxuXHJcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKGluc3RydWN0aW9uKVxyXG4gICAgICBjb25zdCB7IGJsb2NraGFzaCB9ID0gYXdhaXQgY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goJ3Byb2Nlc3NlZCcpXHJcbiAgICAgIHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCA9IGJsb2NraGFzaFxyXG4gICAgICB0cmFuc2FjdGlvbi5mZWVQYXllciA9IHB1YmxpY0tleVxyXG5cclxuICAgICAgY29uc3Qgc2ltdWxhdGlvbiA9IGF3YWl0IGNvbm5lY3Rpb24uc2ltdWxhdGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbilcclxuICAgICAgaWYgKHNpbXVsYXRpb24udmFsdWUuZXJyKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiBzaW11bGF0aW9uIGZhaWxlZDogJHtKU09OLnN0cmluZ2lmeShzaW11bGF0aW9uLnZhbHVlLmVycil9YClcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBjb25uZWN0aW9uLCB7XHJcbiAgICAgICAgc2tpcFByZWZsaWdodDogZmFsc2UsXHJcbiAgICAgICAgcHJlZmxpZ2h0Q29tbWl0bWVudDogJ3Byb2Nlc3NlZCcsXHJcbiAgICAgICAgbWF4UmV0cmllczogMyxcclxuICAgICAgfSlcclxuXHJcbiAgICAgIGF3YWl0IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHtcclxuICAgICAgICBzaWduYXR1cmUsXHJcbiAgICAgICAgYmxvY2toYXNoLFxyXG4gICAgICAgIGxhc3RWYWxpZEJsb2NrSGVpZ2h0OiAoYXdhaXQgY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goKSkubGFzdFZhbGlkQmxvY2tIZWlnaHQsXHJcbiAgICAgIH0sICdwcm9jZXNzZWQnKVxyXG4gICAgICBcclxuICAgICAgLy8gSW52YWxpZGF0ZSBjYWNoZSBhZnRlciBwcm9maWxlIGNyZWF0aW9uXHJcbiAgICAgIGNsZWFyUHJvZmlsZUNhY2hlKHB1YmxpY0tleS50b1N0cmluZygpKVxyXG4gICAgICBcclxuICAgICAgdG9hc3Quc3VjY2VzcygnUHJvZmlsZSBjcmVhdGVkIHN1Y2Nlc3NmdWxseSEnKVxyXG4gICAgICByZXR1cm4gc2lnbmF0dXJlXHJcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBQcm9maWxlIGNyZWF0aW9uIGVycm9yOicsIGVycm9yKVxyXG4gICAgICB0b2FzdC5lcnJvcihgVHJhbnNhY3Rpb24gZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InfWApXHJcbiAgICAgIHRocm93IGVycm9yXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBQcm9kdWN0aW9uLXJlYWR5IHByb2ZpbGUgZGV0ZWN0aW9uIHdpdGggbG9jYWxTdG9yYWdlIGNhY2hpbmcgLSBJbXByb3ZlZCBmb3IgbXVsdGlwbGUgdXNlcnNcclxuICBjb25zdCBnZXRQcm9maWxlID0gYXN5bmMgKHVzZXJQdWJsaWNLZXk6IFB1YmxpY0tleSk6IFByb21pc2U8UHJvZmlsZSB8IG51bGw+ID0+IHtcclxuICAgIGNvbnN0IGNhY2hlS2V5ID0gdXNlclB1YmxpY0tleS50b1N0cmluZygpXHJcbiAgICBcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIDEuIENoZWNrIGxvY2FsU3RvcmFnZSBjYWNoZSBmaXJzdCAoZmFzdGVzdClcclxuICAgICAgY29uc3QgY2FjaGVkUHJvZmlsZSA9IGdldFByb2ZpbGVGcm9tTG9jYWxTdG9yYWdlKGNhY2hlS2V5KVxyXG4gICAgICBpZiAoY2FjaGVkUHJvZmlsZSAhPT0gbnVsbCkge1xyXG4gICAgICAgIC8vIEFsc28gdXBkYXRlIG1lbW9yeSBjYWNoZVxyXG4gICAgICAgIHByb2ZpbGVDYWNoZS5zZXQoY2FjaGVLZXksIGNhY2hlZFByb2ZpbGUpXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBwcm9maWxlQ2FjaGUuZGVsZXRlKGNhY2hlS2V5KSwgQ0FDSEVfRFVSQVRJT04pXHJcbiAgICAgICAgcmV0dXJuIGNhY2hlZFByb2ZpbGVcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gMi4gQ2hlY2sgbWVtb3J5IGNhY2hlXHJcbiAgICAgIGlmIChwcm9maWxlQ2FjaGUuaGFzKGNhY2hlS2V5KSkge1xyXG4gICAgICAgIGNvbnN0IGNhY2hlZCA9IHByb2ZpbGVDYWNoZS5nZXQoY2FjaGVLZXkpXHJcbiAgICAgICAgcmV0dXJuIGNhY2hlZCA/PyBudWxsXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIDMuIEZldGNoIGZyb20gYmxvY2tjaGFpbiAoc2xvd2VzdClcclxuICAgICAgY29uc29sZS5sb2coYPCflI0gRmV0Y2hpbmcgcHJvZmlsZSBmcm9tIGJsb2NrY2hhaW4gZm9yOiAke3VzZXJQdWJsaWNLZXkudG9TdHJpbmcoKS5zbGljZSgwLCA4KX0uLi5gKVxyXG4gICAgICBcclxuICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBjb25uZWN0aW9uLmdldFByb2dyYW1BY2NvdW50cyhQUk9HUkFNX0lEKVxyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coYPCfk4ogRm91bmQgJHthY2NvdW50cy5sZW5ndGh9IHByb2dyYW0gYWNjb3VudHMgdG8gc2NhbiBmb3IgcHJvZmlsZXNgKVxyXG5cclxuICAgICAgbGV0IHByb2ZpbGVzRm91bmQgPSAwXHJcbiAgICAgIFxyXG4gICAgICAvLyBTY2FuIHRocm91Z2ggYWNjb3VudHMgdG8gZmluZCB1c2VyJ3MgcHJvZmlsZVxyXG4gICAgICBmb3IgKGNvbnN0IHsgYWNjb3VudCwgcHVia2V5IH0gb2YgYWNjb3VudHMpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgaWYgKGFjY291bnQuZGF0YS5sZW5ndGggPT09IDApIGNvbnRpbnVlXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIFRyeSBtYW51YWwgcGFyc2luZyBmaXJzdFxyXG4gICAgICAgICAgY29uc3QgcHJvZmlsZUFjY291bnQgPSBtYW51YWxQYXJzZVByb2ZpbGUoYWNjb3VudC5kYXRhKVxyXG4gICAgICAgICAgaWYgKCFwcm9maWxlQWNjb3VudCkgY29udGludWVcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgcHJvZmlsZXNGb3VuZCsrXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGNvbnN0IGFjY291bnRPd25lciA9IG5ldyBQdWJsaWNLZXkocHJvZmlsZUFjY291bnQub3duZXIpXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgcHJvZmlsZSBiZWxvbmdzIHRvIHRoZSB1c2VyIHdlJ3JlIGxvb2tpbmcgZm9yXHJcbiAgICAgICAgICBpZiAocHJvZmlsZUFjY291bnQuaXNfaW5pdGlhbGl6ZWQgPT09IDEgJiYgYWNjb3VudE93bmVyLmVxdWFscyh1c2VyUHVibGljS2V5KSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+OryBGT1VORCBQUk9GSUxFISBVc2VybmFtZTogXCIke3Byb2ZpbGVBY2NvdW50LnVzZXJuYW1lfVwiIGZvciAke3VzZXJQdWJsaWNLZXkudG9TdHJpbmcoKS5zbGljZSgwLCA4KX1gKVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TuCBQcm9maWxlIEltYWdlIFVSTDogXCIke3Byb2ZpbGVBY2NvdW50LnByb2ZpbGVfaW1hZ2V9XCJgKVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+WvO+4jyBDb3ZlciBJbWFnZSBVUkw6IFwiJHtwcm9maWxlQWNjb3VudC5jb3Zlcl9pbWFnZX1cImApXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OKIFByb2ZpbGUgRGF0YTpgLCB7XHJcbiAgICAgICAgICAgICAgdXNlcm5hbWU6IHByb2ZpbGVBY2NvdW50LnVzZXJuYW1lLFxyXG4gICAgICAgICAgICAgIGJpbzogcHJvZmlsZUFjY291bnQuYmlvLFxyXG4gICAgICAgICAgICAgIHByb2ZpbGVJbWFnZTogcHJvZmlsZUFjY291bnQucHJvZmlsZV9pbWFnZSxcclxuICAgICAgICAgICAgICBjb3ZlckltYWdlOiBwcm9maWxlQWNjb3VudC5jb3Zlcl9pbWFnZSxcclxuICAgICAgICAgICAgICBwb3N0c0NvdW50OiBOdW1iZXIocHJvZmlsZUFjY291bnQucG9zdHNfY291bnQpLFxyXG4gICAgICAgICAgICAgIGZvbGxvd2Vyc0NvdW50OiBOdW1iZXIocHJvZmlsZUFjY291bnQuZm9sbG93ZXJzX2NvdW50KSxcclxuICAgICAgICAgICAgICBpc1ZlcmlmaWVkOiBwcm9maWxlQWNjb3VudC5pc192ZXJpZmllZCA9PT0gMVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICBjb25zdCBwcm9maWxlID0gY29udmVydFByb2ZpbGVBY2NvdW50KHByb2ZpbGVBY2NvdW50KVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gQ2FjaGUgaW4gYm90aCBtZW1vcnkgYW5kIGxvY2FsU3RvcmFnZVxyXG4gICAgICAgICAgICBwcm9maWxlQ2FjaGUuc2V0KGNhY2hlS2V5LCBwcm9maWxlKVxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHByb2ZpbGVDYWNoZS5kZWxldGUoY2FjaGVLZXkpLCBDQUNIRV9EVVJBVElPTilcclxuICAgICAgICAgICAgc2F2ZVByb2ZpbGVUb0xvY2FsU3RvcmFnZShjYWNoZUtleSwgcHJvZmlsZSlcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHJldHVybiBwcm9maWxlXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIC8vIE5vdCBhIHByb2ZpbGUgYWNjb3VudCBvciBwYXJzaW5nIGZhaWxlZCwgY29udGludWVcclxuICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhg8J+TiiBTY2FubmVkICR7cHJvZmlsZXNGb3VuZH0gcHJvZmlsZXMsIG5vIG1hdGNoIGZvdW5kIGZvciB1c2VyOiAke3VzZXJQdWJsaWNLZXkudG9TdHJpbmcoKS5zbGljZSgwLCA4KX1gKVxyXG5cclxuICAgICAgLy8gTm8gcHJvZmlsZSBmb3VuZCAtIGNhY2hlIG51bGwgcmVzdWx0IHRvIGF2b2lkIHJlcGVhdGVkIHNjYW5zXHJcbiAgICAgIHByb2ZpbGVDYWNoZS5zZXQoY2FjaGVLZXksIG51bGwpXHJcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gcHJvZmlsZUNhY2hlLmRlbGV0ZShjYWNoZUtleSksIENBQ0hFX0RVUkFUSU9OKVxyXG4gICAgICBzYXZlUHJvZmlsZVRvTG9jYWxTdG9yYWdlKGNhY2hlS2V5LCBudWxsKVxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIG51bGxcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIHByb2ZpbGUgZm9yICR7dXNlclB1YmxpY0tleS50b1N0cmluZygpLnNsaWNlKDAsIDgpfTpgLCBlcnJvcilcclxuICAgICAgcmV0dXJuIG51bGxcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEdldCBwcm9maWxlIGJ5IHVzZXJuYW1lIChmb3Igc3BlY2lmaWMgbG9va3VwcylcclxuICBjb25zdCBnZXRQcm9maWxlQnlVc2VybmFtZSA9IGFzeW5jICh1c2VyUHVibGljS2V5OiBQdWJsaWNLZXksIHVzZXJuYW1lOiBzdHJpbmcpOiBQcm9taXNlPFByb2ZpbGUgfCBudWxsPiA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBwcm9maWxlUERBID0gYXdhaXQgZ2V0UHJvZmlsZVBEQSh1c2VyUHVibGljS2V5LCB1c2VybmFtZSlcclxuICAgICAgY29uc3QgYWNjb3VudEluZm8gPSBhd2FpdCBjb25uZWN0aW9uLmdldEFjY291bnRJbmZvKHByb2ZpbGVQREEpXHJcbiAgICAgIFxyXG4gICAgICBpZiAoIWFjY291bnRJbmZvIHx8ICFhY2NvdW50SW5mby5kYXRhIHx8IGFjY291bnRJbmZvLmRhdGEubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGxcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTm93IHRyeSBtYW51YWwgcGFyc2luZ1xyXG4gICAgICBjb25zdCBwcm9maWxlQWNjb3VudCA9IG1hbnVhbFBhcnNlUHJvZmlsZShhY2NvdW50SW5mby5kYXRhKVxyXG4gICAgICBpZiAocHJvZmlsZUFjY291bnQpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhg4pyFIFN1Y2Nlc3NmdWxseSBtYW51YWxseSBwYXJzZWQgcHJvZmlsZTpgLCB7XHJcbiAgICAgICAgICB1c2VybmFtZTogcHJvZmlsZUFjY291bnQudXNlcm5hbWUsXHJcbiAgICAgICAgICBiaW86IHByb2ZpbGVBY2NvdW50LmJpbyxcclxuICAgICAgICAgIGlzSW5pdGlhbGl6ZWQ6IHByb2ZpbGVBY2NvdW50LmlzX2luaXRpYWxpemVkID09PSAxLFxyXG4gICAgICAgICAgb3duZXI6IG5ldyBQdWJsaWNLZXkocHJvZmlsZUFjY291bnQub3duZXIpLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICBwcm9maWxlSW1hZ2U6IHByb2ZpbGVBY2NvdW50LnByb2ZpbGVfaW1hZ2UsXHJcbiAgICAgICAgICBjb3ZlckltYWdlOiBwcm9maWxlQWNjb3VudC5jb3Zlcl9pbWFnZSxcclxuICAgICAgICAgIHBvc3RzQ291bnQ6IE51bWJlcihwcm9maWxlQWNjb3VudC5wb3N0c19jb3VudClcclxuICAgICAgICB9KVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBjb252ZXJ0UHJvZmlsZUFjY291bnQocHJvZmlsZUFjY291bnQpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYOKdjCBNYW51YWwgcGFyc2luZyBmYWlsZWRgKVxyXG4gICAgICAgIHJldHVybiBudWxsXHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHJldHVybiBudWxsXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBHZXQgcG9zdHMgLSBSRUFMIElNUExFTUVOVEFUSU9OIHdpdGggbWFudWFsIHBhcnNpbmcgYW5kIGNhY2hpbmdcclxuICBjb25zdCBnZXRQb3N0cyA9IGFzeW5jICgpOiBQcm9taXNlPFBvc3RbXT4gPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gQ2hlY2sgY2FjaGUgZmlyc3RcclxuICAgICAgaWYgKHBvc3RzQ2FjaGUgJiYgRGF0ZS5ub3coKSAtIHBvc3RzQ2FjaGUudGltZXN0YW1wIDwgUE9TVFNfQ0FDSEVfRFVSQVRJT04pIHtcclxuICAgICAgICBjb25zb2xlLmxvZygn4pqhIFVzaW5nIGNhY2hlZCBwb3N0cycpXHJcbiAgICAgICAgcmV0dXJuIHBvc3RzQ2FjaGUucG9zdHNcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc29sZS5sb2coJ/CflI0gRmV0Y2hpbmcgcG9zdHMgZnJvbSBibG9ja2NoYWluLi4uJylcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgY29ubmVjdGlvbi5nZXRQcm9ncmFtQWNjb3VudHMoUFJPR1JBTV9JRClcclxuICAgICAgY29uc3QgcG9zdHM6IFBvc3RbXSA9IFtdXHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhg8J+TiiBTY2FubmluZyAke2FjY291bnRzLmxlbmd0aH0gcHJvZ3JhbSBhY2NvdW50cyBmb3IgcG9zdHMuLi5gKVxyXG5cclxuICAgICAgZm9yIChjb25zdCB7IGFjY291bnQsIHB1YmtleSB9IG9mIGFjY291bnRzKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGlmIChhY2NvdW50LmRhdGEubGVuZ3RoID09PSAwKSBjb250aW51ZVxyXG5cclxuICAgICAgICAgIC8vIFRyeSBtYW51YWwgcG9zdCBwYXJzaW5nIGZpcnN0XHJcbiAgICAgICAgICBjb25zdCBwb3N0QWNjb3VudCA9IG1hbnVhbFBhcnNlUG9zdChhY2NvdW50LmRhdGEpXHJcbiAgICAgICAgICBpZiAocG9zdEFjY291bnQgJiYgcG9zdEFjY291bnQuaXNfaW5pdGlhbGl6ZWQgPT09IDEgJiYgcG9zdEFjY291bnQuY29udGVudCkge1xyXG4gICAgICAgICAgICBjb25zdCBwb3N0ID0gY29udmVydFBvc3RBY2NvdW50KHBvc3RBY2NvdW50KVxyXG4gICAgICAgICAgICBwb3N0cy5wdXNoKHBvc3QpXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OdIEZvdW5kIHBvc3Q6IFwiJHtwb3N0LmNvbnRlbnQuc3Vic3RyaW5nKDAsIDUwKX0uLi5cIiBieSAke3Bvc3QuYXV0aG9yLnRvU3RyaW5nKCl9YClcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgLy8gTm90IGEgcG9zdCBhY2NvdW50IG9yIHBhcnNpbmcgZmFpbGVkLCBjb250aW51ZVxyXG4gICAgICAgICAgY29udGludWVcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHBvc3RzLnNvcnQoKGEsIGIpID0+IGIudGltZXN0YW1wIC0gYS50aW1lc3RhbXApXHJcbiAgICAgIGNvbnNvbGUubG9nKGDinIUgTG9hZGVkICR7cG9zdHMubGVuZ3RofSBwb3N0cyBmcm9tIGJsb2NrY2hhaW5gKVxyXG4gICAgICBcclxuICAgICAgLy8gQ2FjaGUgdGhlIHJlc3VsdHNcclxuICAgICAgcG9zdHNDYWNoZSA9IHsgcG9zdHMsIHRpbWVzdGFtcDogRGF0ZS5ub3coKSB9XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gcG9zdHNcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHBvc3RzOicsIGVycm9yKVxyXG4gICAgICByZXR1cm4gW11cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIENyZWF0ZSBwb3N0IC0gUkVBTCBJTVBMRU1FTlRBVElPTlxyXG4gIGNvbnN0IGNyZWF0ZVBvc3QgPSBhc3luYyAoY29udGVudDogc3RyaW5nLCBpbWFnZXM6IHN0cmluZ1tdID0gW10pID0+IHtcclxuICAgIGlmICghcHVibGljS2V5KSB0aHJvdyBuZXcgRXJyb3IoJ1dhbGxldCBub3QgY29ubmVjdGVkJylcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+UjSBDcmVhdGluZyBwb3N0IHdpdGggY29udGVudDonLCBjb250ZW50KVxyXG4gICAgICBcclxuICAgICAgLy8gQ2hlY2sgU09MIGJhbGFuY2VcclxuICAgICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IGNoZWNrU09MQmFsYW5jZSgpXHJcbiAgICAgIGlmIChiYWxhbmNlIDwgMC4wNSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdWZmaWNpZW50IFNPTCBiYWxhbmNlOiAke2JhbGFuY2V9LiBZb3UgbmVlZCBhdCBsZWFzdCAwLjA1IFNPTCBmb3IgdHJhbnNhY3Rpb24gZmVlcyBhbmQgYWNjb3VudCBjcmVhdGlvbi5gKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBHZXQgdXNlcidzIHByb2ZpbGUgUERBIC0gd2UgbmVlZCB0aGlzIGZvciB0aGUgaW5zdHJ1Y3Rpb25cclxuICAgICAgY29uc3QgdXNlclByb2ZpbGUgPSBhd2FpdCBnZXRQcm9maWxlKHB1YmxpY0tleSlcclxuICAgICAgaWYgKCF1c2VyUHJvZmlsZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgY3JlYXRlIGEgcHJvZmlsZSBiZWZvcmUgcG9zdGluZycpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEdldCB1c2VyJ3MgY3VycmVudCBwb3N0IGNvdW50IHRvIGdlbmVyYXRlIHRoZSBjb3JyZWN0IHBvc3QgSURcclxuICAgICAgLy8gVGhlIFJ1c3QgY29udHJhY3QgaW5jcmVtZW50cyBwb3N0c19jb3VudCBmaXJzdCwgdGhlbiB1c2VzIHRoYXQgYXMgdGhlIHBvc3QgSURcclxuICAgICAgY29uc3QgcG9zdElkID0gdXNlclByb2ZpbGUucG9zdHNDb3VudCArIDFcclxuICAgICAgY29uc3QgcG9zdFBEQSA9IGF3YWl0IGdldFBvc3RQREEocHVibGljS2V5LCBwb3N0SWQpXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5ONIFBvc3QgUERBOiAke3Bvc3RQREEudG9TdHJpbmcoKX0gZm9yIHBvc3QgSUQ6ICR7cG9zdElkfWApXHJcblxyXG4gICAgICAvLyBHZW5lcmF0ZSBhIG5ldyBrZXlwYWlyIGZvciB0aGUgcG9zdCBhY2NvdW50XHJcbiAgICAgIC8vIFRoZSBSdXN0IGNvbnRyYWN0IHVzZXMgaW52b2tlIHdpdGggc3lzdGVtX2luc3RydWN0aW9uOjpjcmVhdGVfYWNjb3VudFxyXG4gICAgICAvLyBUaGlzIG1lYW5zIHRoZSBwb3N0IGFjY291bnQgTVVTVCBiZSBhIGtleXBhaXIgdGhhdCBzaWducyB0aGUgdHJhbnNhY3Rpb25cclxuICAgICAgY29uc3QgcG9zdEtleXBhaXIgPSBLZXlwYWlyLmdlbmVyYXRlKClcclxuICAgICAgY29uc29sZS5sb2coYPCfk40gUG9zdCBBY2NvdW50OiAke3Bvc3RLZXlwYWlyLnB1YmxpY0tleS50b1N0cmluZygpfWApXHJcblxyXG4gICAgICAvLyBHZXQgcHJvZmlsZSBQREEgZm9yIHRoZSB1c2VyICh3ZSBuZWVkIHRoZSBhY3R1YWwgdXNlcm5hbWUpXHJcbiAgICAgIC8vIFRyeSB0byBmaW5kIHRoZSBwcm9maWxlIGFjY291bnQgYW1vbmcgYWxsIHByb2dyYW0gYWNjb3VudHNcclxuICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBjb25uZWN0aW9uLmdldFByb2dyYW1BY2NvdW50cyhQUk9HUkFNX0lEKVxyXG4gICAgICBsZXQgdXNlclByb2ZpbGVQREE6IFB1YmxpY0tleSB8IG51bGwgPSBudWxsXHJcbiAgICAgIFxyXG4gICAgICBmb3IgKGNvbnN0IHsgYWNjb3VudCwgcHVia2V5IH0gb2YgYWNjb3VudHMpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgcHJvZmlsZUFjY291bnQgPSBtYW51YWxQYXJzZVByb2ZpbGUoYWNjb3VudC5kYXRhKVxyXG4gICAgICAgICAgaWYgKHByb2ZpbGVBY2NvdW50ICYmIFxyXG4gICAgICAgICAgICAgIHByb2ZpbGVBY2NvdW50LmlzX2luaXRpYWxpemVkID09PSAxICYmIFxyXG4gICAgICAgICAgICAgIG5ldyBQdWJsaWNLZXkocHJvZmlsZUFjY291bnQub3duZXIpLmVxdWFscyhwdWJsaWNLZXkpKSB7XHJcbiAgICAgICAgICAgIHVzZXJQcm9maWxlUERBID0gcHVia2V5XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5ONIFVzZXIgUHJvZmlsZSBQREE6ICR7dXNlclByb2ZpbGVQREEudG9TdHJpbmcoKX1gKVxyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCF1c2VyUHJvZmlsZVBEQSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgeW91ciBwcm9maWxlIFBEQS4gUGxlYXNlIHJlZnJlc2ggYW5kIHRyeSBhZ2Fpbi4nKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSBuZXcgQ3JlYXRlUG9zdEluc3RydWN0aW9uKHtcclxuICAgICAgICBjb250ZW50LFxyXG4gICAgICAgIGltYWdlcyxcclxuICAgICAgfSlcclxuXHJcbiAgICAgIGNvbnN0IGNyZWF0ZVBvc3RWYXJpYW50ID0gQnVmZmVyLmZyb20oWzJdKSAvLyBDcmVhdGVQb3N0IGVudW0gaW5kZXhcclxuICAgICAgY29uc3Qgc2VyaWFsaXplZERhdGEgPSBzZXJpYWxpemUoY3JlYXRlUG9zdFNjaGVtYSwgaW5zdHJ1Y3Rpb25EYXRhKVxyXG4gICAgICBjb25zdCBmdWxsSW5zdHJ1Y3Rpb25EYXRhID0gQnVmZmVyLmNvbmNhdChbY3JlYXRlUG9zdFZhcmlhbnQsIEJ1ZmZlci5mcm9tKHNlcmlhbGl6ZWREYXRhKV0pXHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhg8J+UoiBJbnN0cnVjdGlvbiBkYXRhIGxlbmd0aDogJHtmdWxsSW5zdHJ1Y3Rpb25EYXRhLmxlbmd0aH0gYnl0ZXNgKVxyXG5cclxuICAgICAgY29uc3QgaW5zdHJ1Y3Rpb24gPSBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XHJcbiAgICAgICAga2V5czogW1xyXG4gICAgICAgICAgeyBwdWJrZXk6IHB1YmxpY0tleSwgaXNTaWduZXI6IHRydWUsIGlzV3JpdGFibGU6IHRydWUgfSwgLy8gVXNlciBhY2NvdW50IChwYXllcilcclxuICAgICAgICAgIHsgcHVia2V5OiBwb3N0S2V5cGFpci5wdWJsaWNLZXksIGlzU2lnbmVyOiB0cnVlLCBpc1dyaXRhYmxlOiB0cnVlIH0sIC8vIFBvc3QgYWNjb3VudCAobXVzdCBiZSBzaWduZXIpXHJcbiAgICAgICAgICB7IHB1YmtleTogdXNlclByb2ZpbGVQREEsIGlzU2lnbmVyOiBmYWxzZSwgaXNXcml0YWJsZTogdHJ1ZSB9LCAvLyBVc2VyIHByb2ZpbGUgKGZvciBwb3N0IGNvdW50KVxyXG4gICAgICAgICAgeyBwdWJrZXk6IFN5c3RlbVByb2dyYW0ucHJvZ3JhbUlkLCBpc1NpZ25lcjogZmFsc2UsIGlzV3JpdGFibGU6IGZhbHNlIH0sIC8vIFN5c3RlbSBwcm9ncmFtXHJcbiAgICAgICAgXSxcclxuICAgICAgICBwcm9ncmFtSWQ6IFBST0dSQU1fSUQsXHJcbiAgICAgICAgZGF0YTogZnVsbEluc3RydWN0aW9uRGF0YSxcclxuICAgICAgfSlcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OdIFRyYW5zYWN0aW9uIGluc3RydWN0aW9uIGNyZWF0ZWQnKVxyXG4gICAgICBjb25zb2xlLmxvZygn8J+UkSBLZXlzOicsIGluc3RydWN0aW9uLmtleXMubWFwKGsgPT4gKHtcclxuICAgICAgICBwdWJrZXk6IGsucHVia2V5LnRvU3RyaW5nKCksXHJcbiAgICAgICAgaXNTaWduZXI6IGsuaXNTaWduZXIsXHJcbiAgICAgICAgaXNXcml0YWJsZTogay5pc1dyaXRhYmxlXHJcbiAgICAgIH0pKSlcclxuXHJcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKGluc3RydWN0aW9uKVxyXG4gICAgICBjb25zdCB7IGJsb2NraGFzaCB9ID0gYXdhaXQgY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goJ3Byb2Nlc3NlZCcpXHJcbiAgICAgIHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCA9IGJsb2NraGFzaFxyXG4gICAgICB0cmFuc2FjdGlvbi5mZWVQYXllciA9IHB1YmxpY0tleVxyXG5cclxuICAgICAgY29uc29sZS5sb2coJ/CfmoAgU2VuZGluZyB0cmFuc2FjdGlvbi4uLicpXHJcbiAgICAgIFxyXG4gICAgICAvLyBTaWduIHRyYW5zYWN0aW9uIGJlZm9yZSBzaW11bGF0aW9uXHJcbiAgICAgIHRyYW5zYWN0aW9uLnBhcnRpYWxTaWduKHBvc3RLZXlwYWlyKVxyXG4gICAgICBcclxuICAgICAgLy8gU2ltdWxhdGUgdHJhbnNhY3Rpb24gXHJcbiAgICAgIGNvbnN0IHNpbXVsYXRpb24gPSBhd2FpdCBjb25uZWN0aW9uLnNpbXVsYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pXHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn46vIFRyYW5zYWN0aW9uIHNpbXVsYXRpb246Jywgc2ltdWxhdGlvbilcclxuICAgICAgXHJcbiAgICAgIGlmIChzaW11bGF0aW9uLnZhbHVlLmVycikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gc2ltdWxhdGlvbiBmYWlsZWQ6ICR7SlNPTi5zdHJpbmdpZnkoc2ltdWxhdGlvbi52YWx1ZS5lcnIpfWApXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFNlbmQgdHJhbnNhY3Rpb24gd2l0aCBwb3N0IGtleXBhaXIgYXMgYWRkaXRpb25hbCBzaWduZXJcclxuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBjb25uZWN0aW9uLCB7XHJcbiAgICAgICAgc2tpcFByZWZsaWdodDogZmFsc2UsXHJcbiAgICAgICAgcHJlZmxpZ2h0Q29tbWl0bWVudDogJ3Byb2Nlc3NlZCcsXHJcbiAgICAgICAgbWF4UmV0cmllczogMyxcclxuICAgICAgICBzaWduZXJzOiBbcG9zdEtleXBhaXJdLCAvLyBQb3N0IGtleXBhaXIgbXVzdCBzaWduIHRoZSB0cmFuc2FjdGlvblxyXG4gICAgICB9KVxyXG5cclxuICAgICAgY29uc29sZS5sb2coYPCfk4sgVHJhbnNhY3Rpb24gc2lnbmF0dXJlOiAke3NpZ25hdHVyZX1gKVxyXG4gICAgICBcclxuICAgICAgYXdhaXQgY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oe1xyXG4gICAgICAgIHNpZ25hdHVyZSxcclxuICAgICAgICBibG9ja2hhc2gsXHJcbiAgICAgICAgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IChhd2FpdCBjb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCgpKS5sYXN0VmFsaWRCbG9ja0hlaWdodCxcclxuICAgICAgfSwgJ3Byb2Nlc3NlZCcpXHJcblxyXG4gICAgICAvLyBJbnZhbGlkYXRlIGNhY2hlIGFmdGVyIHBvc3QgY3JlYXRpb24gKHByb2ZpbGUgcG9zdCBjb3VudCBjaGFuZ2VkKVxyXG4gICAgICBjbGVhclByb2ZpbGVDYWNoZShwdWJsaWNLZXkudG9TdHJpbmcoKSlcclxuICAgICAgcG9zdHNDYWNoZSA9IG51bGwgLy8gQWxzbyBjbGVhciBwb3N0cyBjYWNoZSB0byBzaG93IG5ldyBwb3N0IGltbWVkaWF0ZWx5XHJcblxyXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFBvc3QgY3JlYXRlZCBzdWNjZXNzZnVsbHkhJylcclxuICAgICAgdG9hc3Quc3VjY2VzcygnUG9zdCBjcmVhdGVkIHN1Y2Nlc3NmdWxseSEnKVxyXG4gICAgICByZXR1cm4gc2lnbmF0dXJlXHJcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBQb3N0IGNyZWF0aW9uIGVycm9yOicsIGVycm9yKVxyXG4gICAgICBcclxuICAgICAgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdpbnN1ZmZpY2llbnQgZnVuZHMnKSkge1xyXG4gICAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBjaGVja1NPTEJhbGFuY2UoKVxyXG4gICAgICAgIHRvYXN0LmVycm9yKGBJbnN1ZmZpY2llbnQgU09MOiAke2JhbGFuY2UudG9GaXhlZCg0KX0gU09MLiBOZWVkIGF0IGxlYXN0IDAuMDUgU09MIGZvciBmZWVzLmApXHJcbiAgICAgIH0gZWxzZSBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ3NpbXVsYXRpb24gZmFpbGVkJykpIHtcclxuICAgICAgICB0b2FzdC5lcnJvcignVHJhbnNhY3Rpb24gd291bGQgZmFpbDogQ2hlY2sgYWNjb3VudCBzZXR1cCBhbmQgYmFsYW5jZScpXHJcbiAgICAgICAgY29uc29sZS5lcnJvcignU2ltdWxhdGlvbiBlcnJvciBkZXRhaWxzOicsIGVycm9yLm1lc3NhZ2UpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdG9hc3QuZXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgcG9zdDogJHtlcnJvci5tZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJ31gKVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICB0aHJvdyBlcnJvclxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gTGlrZSBwb3N0IC0gUkVBTCBJTVBMRU1FTlRBVElPTiAtIEZpeGVkIHRvIGZpbmQgYWN0dWFsIHBvc3QgYWNjb3VudHNcclxuICBjb25zdCBsaWtlUG9zdCA9IGFzeW5jIChwb3N0SWQ6IG51bWJlciwgcG9zdEF1dGhvcjogUHVibGljS2V5KSA9PiB7XHJcbiAgICBpZiAoIXB1YmxpY0tleSkgdGhyb3cgbmV3IEVycm9yKCdXYWxsZXQgbm90IGNvbm5lY3RlZCcpXHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coYPCflI0gQXR0ZW1wdGluZyB0byBsaWtlIHBvc3QgSUQgJHtwb3N0SWR9IGJ5IGF1dGhvciAke3Bvc3RBdXRob3IudG9TdHJpbmcoKS5zbGljZSgwLCA4KX0uLi5gKVxyXG4gICAgICBcclxuICAgICAgLy8gQ2hlY2sgU09MIGJhbGFuY2UgZmlyc3RcclxuICAgICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IGNoZWNrU09MQmFsYW5jZSgpXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5KwIEN1cnJlbnQgU09MIGJhbGFuY2U6ICR7YmFsYW5jZX1gKVxyXG4gICAgICBpZiAoYmFsYW5jZSA8IDAuMDEpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluc3VmZmljaWVudCBTT0wgYmFsYW5jZTogJHtiYWxhbmNlfS4gTmVlZCBhdCBsZWFzdCAwLjAxIFNPTCBmb3IgdHJhbnNhY3Rpb24gZmVlcy5gKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBGaW5kIHRoZSBhY3R1YWwgcG9zdCBhY2NvdW50IGFuZCBhdXRob3IncyBwcm9maWxlIGFjY291bnQgYnkgc2Nhbm5pbmcgYWxsIHByb2dyYW0gYWNjb3VudHNcclxuICAgICAgY29uc29sZS5sb2coYPCflI0gU2VhcmNoaW5nIGZvciBwb3N0IElEICR7cG9zdElkfSBieSBhdXRob3IgJHtwb3N0QXV0aG9yLnRvU3RyaW5nKCkuc2xpY2UoMCwgOCl9Li4uYClcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgY29ubmVjdGlvbi5nZXRQcm9ncmFtQWNjb3VudHMoUFJPR1JBTV9JRClcclxuICAgICAgbGV0IHBvc3RBY2NvdW50QWRkcmVzczogUHVibGljS2V5IHwgbnVsbCA9IG51bGxcclxuICAgICAgbGV0IHBvc3RBY2NvdW50OiBQb3N0QWNjb3VudCB8IG51bGwgPSBudWxsXHJcbiAgICAgIGxldCBhdXRob3JQcm9maWxlQWRkcmVzczogUHVibGljS2V5IHwgbnVsbCA9IG51bGxcclxuICAgICAgXHJcbiAgICAgIC8vIEZpcnN0IHBhc3M6IGZpbmQgdGhlIHBvc3QgYWNjb3VudFxyXG4gICAgICBmb3IgKGNvbnN0IHsgYWNjb3VudCwgcHVia2V5IH0gb2YgYWNjb3VudHMpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgcGFyc2VkUG9zdCA9IG1hbnVhbFBhcnNlUG9zdChhY2NvdW50LmRhdGEpXHJcbiAgICAgICAgICBpZiAocGFyc2VkUG9zdCAmJiBcclxuICAgICAgICAgICAgICBwYXJzZWRQb3N0LmlzX2luaXRpYWxpemVkID09PSAxICYmIFxyXG4gICAgICAgICAgICAgIE51bWJlcihwYXJzZWRQb3N0LmlkKSA9PT0gcG9zdElkICYmXHJcbiAgICAgICAgICAgICAgbmV3IFB1YmxpY0tleShwYXJzZWRQb3N0LmF1dGhvcikuZXF1YWxzKHBvc3RBdXRob3IpKSB7XHJcbiAgICAgICAgICAgIHBvc3RBY2NvdW50QWRkcmVzcyA9IHB1YmtleVxyXG4gICAgICAgICAgICBwb3N0QWNjb3VudCA9IHBhcnNlZFBvc3RcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYPCfjq8gRm91bmQgcG9zdCBJRCAke3Bvc3RJZH0gYXQgYWRkcmVzczogJHtwdWJrZXkudG9TdHJpbmcoKX1gKVxyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAvLyBOb3QgYSBwb3N0IGFjY291bnQsIGNvbnRpbnVlXHJcbiAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFwb3N0QWNjb3VudEFkZHJlc3MgfHwgIXBvc3RBY2NvdW50KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb3N0IElEICR7cG9zdElkfSBieSBhdXRob3IgJHtwb3N0QXV0aG9yLnRvU3RyaW5nKCkuc2xpY2UoMCwgOCl9IG5vdCBmb3VuZCBvbiBibG9ja2NoYWluYClcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU2Vjb25kIHBhc3M6IGZpbmQgdGhlIGF1dGhvcidzIHByb2ZpbGUgYWNjb3VudFxyXG4gICAgICBjb25zb2xlLmxvZyhg8J+UjSBTZWFyY2hpbmcgZm9yIGF1dGhvcidzIHByb2ZpbGU6ICR7cG9zdEF1dGhvci50b1N0cmluZygpLnNsaWNlKDAsIDgpfS4uLmApXHJcbiAgICAgIGZvciAoY29uc3QgeyBhY2NvdW50LCBwdWJrZXkgfSBvZiBhY2NvdW50cykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCBwYXJzZWRQcm9maWxlID0gbWFudWFsUGFyc2VQcm9maWxlKGFjY291bnQuZGF0YSlcclxuICAgICAgICAgIGlmIChwYXJzZWRQcm9maWxlICYmIFxyXG4gICAgICAgICAgICAgIHBhcnNlZFByb2ZpbGUuaXNfaW5pdGlhbGl6ZWQgPT09IDEgJiYgXHJcbiAgICAgICAgICAgICAgbmV3IFB1YmxpY0tleShwYXJzZWRQcm9maWxlLm93bmVyKS5lcXVhbHMocG9zdEF1dGhvcikpIHtcclxuICAgICAgICAgICAgYXV0aG9yUHJvZmlsZUFkZHJlc3MgPSBwdWJrZXlcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBGb3VuZCBhdXRob3IgcHJvZmlsZSBhY2NvdW50OiAke3B1YmtleS50b1N0cmluZygpfWApXHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIC8vIE5vdCBhIHByb2ZpbGUgYWNjb3VudCwgY29udGludWVcclxuICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIWF1dGhvclByb2ZpbGVBZGRyZXNzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdXRob3IncyBwcm9maWxlIG5vdCBmb3VuZCBmb3IgJHtwb3N0QXV0aG9yLnRvU3RyaW5nKCkuc2xpY2UoMCwgOCl9YClcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc29sZS5sb2coYPCfk50gUG9zdCBkYXRhIHZlcmlmaWVkOiBcIiR7cG9zdEFjY291bnQuY29udGVudC5zbGljZSgwLCAzMCl9Li4uXCIgd2l0aCAke051bWJlcihwb3N0QWNjb3VudC5saWtlcyl9IGxpa2VzYClcclxuXHJcbiAgICAgIGNvbnN0IGluc3RydWN0aW9uRGF0YSA9IG5ldyBMaWtlUG9zdEluc3RydWN0aW9uKHtcclxuICAgICAgICBwb3N0X2lkOiBCaWdJbnQocG9zdElkKSxcclxuICAgICAgfSlcclxuXHJcbiAgICAgIGNvbnN0IGxpa2VQb3N0VmFyaWFudCA9IEJ1ZmZlci5mcm9tKFszXSkgLy8gTGlrZVBvc3QgaW5zdHJ1Y3Rpb24gdmFyaWFudFxyXG4gICAgICBjb25zdCBzZXJpYWxpemVkRGF0YSA9IHNlcmlhbGl6ZShsaWtlUG9zdFNjaGVtYSwgaW5zdHJ1Y3Rpb25EYXRhKVxyXG4gICAgICBjb25zdCBmdWxsSW5zdHJ1Y3Rpb25EYXRhID0gQnVmZmVyLmNvbmNhdChbbGlrZVBvc3RWYXJpYW50LCBCdWZmZXIuZnJvbShzZXJpYWxpemVkRGF0YSldKVxyXG5cclxuICAgICAgY29uc29sZS5sb2coYPCflKIgSW5zdHJ1Y3Rpb24gZGF0YTogdmFyaWFudCBbM10sIHNlcmlhbGl6ZWQgbGVuZ3RoOiAke3NlcmlhbGl6ZWREYXRhLmxlbmd0aH0sIHRvdGFsOiAke2Z1bGxJbnN0cnVjdGlvbkRhdGEubGVuZ3RofSBieXRlc2ApXHJcblxyXG4gICAgICBjb25zdCBpbnN0cnVjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcclxuICAgICAgICBrZXlzOiBbXHJcbiAgICAgICAgICB7IHB1YmtleTogcHVibGljS2V5LCBpc1NpZ25lcjogdHJ1ZSwgaXNXcml0YWJsZTogZmFsc2UgfSwgLy8gVXNlciBhY2NvdW50IChsaWtlcilcclxuICAgICAgICAgIHsgcHVia2V5OiBwb3N0QWNjb3VudEFkZHJlc3MsIGlzU2lnbmVyOiBmYWxzZSwgaXNXcml0YWJsZTogdHJ1ZSB9LCAvLyBQb3N0IGFjY291bnQgKHRvIHVwZGF0ZSBsaWtlcylcclxuICAgICAgICAgIHsgcHVia2V5OiBhdXRob3JQcm9maWxlQWRkcmVzcywgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiB0cnVlIH0sIC8vIEF1dGhvciBwcm9maWxlIGFjY291bnQgKHRvIHVwZGF0ZSBVQ1IpXHJcbiAgICAgICAgXSxcclxuICAgICAgICBwcm9ncmFtSWQ6IFBST0dSQU1fSUQsXHJcbiAgICAgICAgZGF0YTogZnVsbEluc3RydWN0aW9uRGF0YSxcclxuICAgICAgfSlcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SRIFRyYW5zYWN0aW9uIGFjY291bnRzOicpXHJcbiAgICAgIGNvbnNvbGUubG9nKGAgIFVzZXIgKGxpa2VyKTogJHtwdWJsaWNLZXkudG9TdHJpbmcoKX0gKHNpZ25lciwgcmVhZG9ubHkpYClcclxuICAgICAgY29uc29sZS5sb2coYCAgUG9zdDogJHtwb3N0QWNjb3VudEFkZHJlc3MudG9TdHJpbmcoKX0gKG5vdCBzaWduZXIsIHdyaXRhYmxlKWApXHJcbiAgICAgIGNvbnNvbGUubG9nKGAgIEF1dGhvciBQcm9maWxlOiAke2F1dGhvclByb2ZpbGVBZGRyZXNzLnRvU3RyaW5nKCl9IChub3Qgc2lnbmVyLCB3cml0YWJsZSlgKVxyXG4gICAgICBjb25zb2xlLmxvZyhgICBQcm9ncmFtOiAke1BST0dSQU1fSUQudG9TdHJpbmcoKX1gKVxyXG5cclxuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoaW5zdHJ1Y3Rpb24pXHJcbiAgICAgIGNvbnN0IHsgYmxvY2toYXNoIH0gPSBhd2FpdCBjb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCgncHJvY2Vzc2VkJylcclxuICAgICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoXHJcbiAgICAgIHRyYW5zYWN0aW9uLmZlZVBheWVyID0gcHVibGljS2V5XHJcblxyXG4gICAgICAvLyBTaW11bGF0ZSB0cmFuc2FjdGlvbiBiZWZvcmUgc2VuZGluZ1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+OryBTaW11bGF0aW5nIHRyYW5zYWN0aW9uLi4uJylcclxuICAgICAgY29uc3Qgc2ltdWxhdGlvbiA9IGF3YWl0IGNvbm5lY3Rpb24uc2ltdWxhdGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbilcclxuICAgICAgY29uc29sZS5sb2coJ/Cfk4ogU2ltdWxhdGlvbiByZXN1bHQ6Jywgc2ltdWxhdGlvbilcclxuICAgICAgXHJcbiAgICAgIGlmIChzaW11bGF0aW9uLnZhbHVlLmVycikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gc2ltdWxhdGlvbiBmYWlsZWQ6ICR7SlNPTi5zdHJpbmdpZnkoc2ltdWxhdGlvbi52YWx1ZS5lcnIpfWApXHJcbiAgICAgIH1cclxuICAgICAgY29uc29sZS5sb2coJ+KchSBUcmFuc2FjdGlvbiBzaW11bGF0aW9uIHN1Y2Nlc3NmdWwnKVxyXG5cclxuICAgICAgY29uc29sZS5sb2coJ/CfmoAgU2VuZGluZyB0cmFuc2FjdGlvbi4uLicpXHJcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgY29ubmVjdGlvbiwge1xyXG4gICAgICAgIHNraXBQcmVmbGlnaHQ6IGZhbHNlLFxyXG4gICAgICAgIHByZWZsaWdodENvbW1pdG1lbnQ6ICdwcm9jZXNzZWQnLFxyXG4gICAgICAgIG1heFJldHJpZXM6IDMsXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhg8J+TiyBUcmFuc2FjdGlvbiBzZW50IHdpdGggc2lnbmF0dXJlOiAke3NpZ25hdHVyZX1gKVxyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coJ+KPsyBDb25maXJtaW5nIHRyYW5zYWN0aW9uLi4uJylcclxuICAgICAgYXdhaXQgY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oe1xyXG4gICAgICAgIHNpZ25hdHVyZSxcclxuICAgICAgICBibG9ja2hhc2gsXHJcbiAgICAgICAgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IChhd2FpdCBjb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCgpKS5sYXN0VmFsaWRCbG9ja0hlaWdodCxcclxuICAgICAgfSwgJ3Byb2Nlc3NlZCcpXHJcblxyXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFRyYW5zYWN0aW9uIGNvbmZpcm1lZCEgUG9zdCBsaWtlZCBzdWNjZXNzZnVsbHkhJylcclxuICAgICAgXHJcbiAgICAgIC8vIENsZWFyIHBvc3RzIGNhY2hlIHRvIGZvcmNlIHJlZnJlc2hcclxuICAgICAgcG9zdHNDYWNoZSA9IG51bGxcclxuICAgICAgXHJcbiAgICAgIHRvYXN0LnN1Y2Nlc3MoJ1Bvc3QgbGlrZWQhJylcclxuICAgICAgcmV0dXJuIHNpZ25hdHVyZVxyXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgTGlrZSBwb3N0IGVycm9yOicsIGVycm9yKVxyXG4gICAgICBcclxuICAgICAgLy8gTW9yZSBzcGVjaWZpYyBlcnJvciBtZXNzYWdlc1xyXG4gICAgICBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ2luc3VmZmljaWVudCBmdW5kcycpKSB7XHJcbiAgICAgICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IGNoZWNrU09MQmFsYW5jZSgpXHJcbiAgICAgICAgdG9hc3QuZXJyb3IoYEluc3VmZmljaWVudCBTT0w6ICR7YmFsYW5jZS50b0ZpeGVkKDQpfSBTT0wuIE5lZWQgYXQgbGVhc3QgMC4wMSBTT0wgZm9yIGZlZXMuYClcclxuICAgICAgfSBlbHNlIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnc2ltdWxhdGlvbiBmYWlsZWQnKSkge1xyXG4gICAgICAgIHRvYXN0LmVycm9yKCdUcmFuc2FjdGlvbiB3b3VsZCBmYWlsOiBDaGVjayBwb3N0IGV4aXN0cyBhbmQgd2FsbGV0IGhhcyBwZXJtaXNzaW9uJylcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdTaW11bGF0aW9uIGVycm9yIGRldGFpbHM6JywgZXJyb3IubWVzc2FnZSlcclxuICAgICAgfSBlbHNlIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnbm90IGZvdW5kIG9uIGJsb2NrY2hhaW4nKSkge1xyXG4gICAgICAgIHRvYXN0LmVycm9yKCdQb3N0IG5vdCBmb3VuZCBvbiBibG9ja2NoYWluJylcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0b2FzdC5lcnJvcihgRmFpbGVkIHRvIGxpa2UgcG9zdDogJHtlcnJvci5tZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJ31gKVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICB0aHJvdyBlcnJvclxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQ2hlY2sgc3BlY2lmaWMgcHJvZmlsZSBQREEgLSBmb3IgZGVidWdnaW5nIHByb2ZpbGUgZGV0ZWN0aW9uIGlzc3Vlc1xyXG4gIGNvbnN0IGNoZWNrUHJvZmlsZUF0UERBID0gYXN5bmMgKHBkYUFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coYPCflI0gQ2hlY2tpbmcgc3BlY2lmaWMgUERBOiAke3BkYUFkZHJlc3N9YClcclxuICAgICAgY29uc3QgcGRhID0gbmV3IFB1YmxpY0tleShwZGFBZGRyZXNzKVxyXG4gICAgICBjb25zdCBhY2NvdW50SW5mbyA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0QWNjb3VudEluZm8ocGRhKVxyXG4gICAgICBcclxuICAgICAgaWYgKCFhY2NvdW50SW5mbykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGDinYwgTm8gYWNjb3VudCBmb3VuZCBhdCBQREE6ICR7cGRhQWRkcmVzc31gKVxyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIEFjY291bnQgZXhpc3RzISBPd25lcjogJHthY2NvdW50SW5mby5vd25lci50b1N0cmluZygpfSwgU2l6ZTogJHthY2NvdW50SW5mby5kYXRhLmxlbmd0aH0gYnl0ZXNgKVxyXG4gICAgICBcclxuICAgICAgLy8gSW5zcGVjdCByYXcgZGF0YVxyXG4gICAgICBjb25zb2xlLmxvZyhg8J+UjSBSYXcgZGF0YSAoZmlyc3QgMTAwIGJ5dGVzKTpgLCBBcnJheS5mcm9tKGFjY291bnRJbmZvLmRhdGEuc2xpY2UoMCwgMTAwKSkpXHJcbiAgICAgIFxyXG4gICAgICBpZiAoYWNjb3VudEluZm8ub3duZXIuZXF1YWxzKFBST0dSQU1fSUQpKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYOKchSBBY2NvdW50IGlzIG93bmVkIGJ5IG91ciBwcm9ncmFtYClcclxuICAgICAgICBcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgLy8gVHJ5IG1hbnVhbCBwYXJzaW5nIHRvIHVuZGVyc3RhbmQgdGhlIHN0cnVjdHVyZVxyXG4gICAgICAgICAgbGV0IG9mZnNldCA9IDBcclxuICAgICAgICAgIGNvbnN0IGlzX2luaXRpYWxpemVkID0gYWNjb3VudEluZm8uZGF0YVtvZmZzZXRdXHJcbiAgICAgICAgICBvZmZzZXQgKz0gMVxyXG4gICAgICAgICAgY29uc29sZS5sb2coYPCfk4ogaXNfaW5pdGlhbGl6ZWQ6ICR7aXNfaW5pdGlhbGl6ZWR9YClcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY29uc3Qgb3duZXIgPSBhY2NvdW50SW5mby5kYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgMzIpXHJcbiAgICAgICAgICBvZmZzZXQgKz0gMzJcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OKIG93bmVyOiAke25ldyBQdWJsaWNLZXkob3duZXIpLnRvU3RyaW5nKCl9YClcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gVHJ5IHRvIHJlYWQgdGhlIHVzZXJuYW1lIGxlbmd0aCAoQm9yc2ggc3RyaW5nIGZvcm1hdDogNCBieXRlcyBsZW5ndGggKyBzdHJpbmcpXHJcbiAgICAgICAgICBjb25zdCB1c2VybmFtZUxlbmd0aCA9IGFjY291bnRJbmZvLmRhdGEucmVhZFVJbnQzMkxFKG9mZnNldClcclxuICAgICAgICAgIG9mZnNldCArPSA0XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TiiB1c2VybmFtZSBsZW5ndGg6ICR7dXNlcm5hbWVMZW5ndGh9YClcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgaWYgKHVzZXJuYW1lTGVuZ3RoID4gMCAmJiB1c2VybmFtZUxlbmd0aCA8IDEwMCkge1xyXG4gICAgICAgICAgICBjb25zdCB1c2VybmFtZSA9IGFjY291bnRJbmZvLmRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB1c2VybmFtZUxlbmd0aCkudG9TdHJpbmcoJ3V0ZjgnKVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TiiB1c2VybmFtZTogXCIke3VzZXJuYW1lfVwiYClcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gTm93IHRyeSBtYW51YWwgcGFyc2luZ1xyXG4gICAgICAgICAgY29uc3QgcHJvZmlsZUFjY291bnQgPSBtYW51YWxQYXJzZVByb2ZpbGUoYWNjb3VudEluZm8uZGF0YSlcclxuICAgICAgICAgIGlmIChwcm9maWxlQWNjb3VudCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIFN1Y2Nlc3NmdWxseSBtYW51YWxseSBwYXJzZWQgcHJvZmlsZTpgLCB7XHJcbiAgICAgICAgICAgICAgdXNlcm5hbWU6IHByb2ZpbGVBY2NvdW50LnVzZXJuYW1lLFxyXG4gICAgICAgICAgICAgIGJpbzogcHJvZmlsZUFjY291bnQuYmlvLFxyXG4gICAgICAgICAgICAgIGlzSW5pdGlhbGl6ZWQ6IHByb2ZpbGVBY2NvdW50LmlzX2luaXRpYWxpemVkID09PSAxLFxyXG4gICAgICAgICAgICAgIG93bmVyOiBuZXcgUHVibGljS2V5KHByb2ZpbGVBY2NvdW50Lm93bmVyKS50b1N0cmluZygpLFxyXG4gICAgICAgICAgICAgIHByb2ZpbGVJbWFnZTogcHJvZmlsZUFjY291bnQucHJvZmlsZV9pbWFnZSxcclxuICAgICAgICAgICAgICBjb3ZlckltYWdlOiBwcm9maWxlQWNjb3VudC5jb3Zlcl9pbWFnZSxcclxuICAgICAgICAgICAgICBwb3N0c0NvdW50OiBOdW1iZXIocHJvZmlsZUFjY291bnQucG9zdHNfY291bnQpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4p2MIE1hbnVhbCBwYXJzaW5nIGZhaWxlZGApXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIEFsc28gdHJ5IEJvcnNoIGZvciBjb21wYXJpc29uXHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9maWxlQWNjb3VudCA9IGRlc2VyaWFsaXplKHByb2ZpbGVBY2NvdW50U2NoZW1hLCBQcm9maWxlQWNjb3VudCwgYWNjb3VudEluZm8uZGF0YSkgYXMgUHJvZmlsZUFjY291bnRcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBCb3JzaCBkZXNlcmlhbGl6YXRpb24gYWxzbyB3b3JrZWQ6YCwge1xyXG4gICAgICAgICAgICAgIHVzZXJuYW1lOiBwcm9maWxlQWNjb3VudC51c2VybmFtZSxcclxuICAgICAgICAgICAgICBiaW86IHByb2ZpbGVBY2NvdW50LmJpbyxcclxuICAgICAgICAgICAgICBpc0luaXRpYWxpemVkOiBwcm9maWxlQWNjb3VudC5pc19pbml0aWFsaXplZCA9PT0gMSxcclxuICAgICAgICAgICAgICBvd25lcjogbmV3IFB1YmxpY0tleShwcm9maWxlQWNjb3VudC5vd25lcikudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYOKdjCBCb3JzaCBkZXNlcmlhbGl6YXRpb24gc3RpbGwgZmFpbHM6YCwgZXJyb3IpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGDinYwgRXJyb3IgY2hlY2tpbmcgUERBOmAsIGVycm9yKVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhg4p2MIEFjY291bnQgaXMgb3duZWQgYnkgZGlmZmVyZW50IHByb2dyYW06ICR7YWNjb3VudEluZm8ub3duZXIudG9TdHJpbmcoKX1gKVxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmxvZyhg4p2MIEVycm9yIGNoZWNraW5nIFBEQTpgLCBlcnJvcilcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIE1hbnVhbCBwcm9maWxlIHBhcnNlciAtIGJ5cGFzc2VzIEJvcnNoIGRlc2VyaWFsaXphdGlvbiBpc3N1ZXNcclxuICBjb25zdCBtYW51YWxQYXJzZVByb2ZpbGUgPSAoZGF0YTogQnVmZmVyKTogUHJvZmlsZUFjY291bnQgfCBudWxsID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIEJhc2ljIHZhbGlkYXRpb24gLSBwcm9maWxlcyBzaG91bGQgaGF2ZSBhIG1pbmltdW0gc2l6ZVxyXG4gICAgICBpZiAoZGF0YS5sZW5ndGggPCAxNTApIHJldHVybiBudWxsIC8vIFByb2ZpbGVzIG5lZWQgYXQgbGVhc3QgMTUwIGJ5dGVzIGZvciBiYXNpYyBzdHJ1Y3R1cmVcclxuICAgICAgXHJcbiAgICAgIGxldCBvZmZzZXQgPSAwXHJcbiAgICAgIFxyXG4gICAgICAvLyBQYXJzZSBlYWNoIGZpZWxkIG1hbnVhbGx5XHJcbiAgICAgIGNvbnN0IGlzX2luaXRpYWxpemVkID0gZGF0YVtvZmZzZXRdXHJcbiAgICAgIGlmIChpc19pbml0aWFsaXplZCAhPT0gMSkgcmV0dXJuIG51bGwgLy8gTXVzdCBiZSBpbml0aWFsaXplZFxyXG4gICAgICBvZmZzZXQgKz0gMVxyXG4gICAgICBcclxuICAgICAgY29uc3Qgb3duZXIgPSBkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgMzIpXHJcbiAgICAgIG9mZnNldCArPSAzMlxyXG4gICAgICBcclxuICAgICAgLy8gVmFsaWRhdGUgd2UgaGF2ZSBlbm91Z2ggZGF0YSBmb3IgdXNlcm5hbWUgbGVuZ3RoXHJcbiAgICAgIGlmIChvZmZzZXQgKyA0ID4gZGF0YS5sZW5ndGgpIHJldHVybiBudWxsXHJcbiAgICAgIFxyXG4gICAgICAvLyBTdHJpbmcgZmllbGRzICh1c2VybmFtZSwgYmlvLCBwcm9maWxlX2ltYWdlLCBjb3Zlcl9pbWFnZSlcclxuICAgICAgY29uc3QgdXNlcm5hbWVMZW5ndGggPSBkYXRhLnJlYWRVSW50MzJMRShvZmZzZXQpXHJcbiAgICAgIG9mZnNldCArPSA0XHJcbiAgICAgIFxyXG4gICAgICAvLyBWYWxpZGF0ZSB1c2VybmFtZSBsZW5ndGggaXMgcmVhc29uYWJsZVxyXG4gICAgICBpZiAodXNlcm5hbWVMZW5ndGggPiAxMDAgfHwgdXNlcm5hbWVMZW5ndGggPT09IDApIHJldHVybiBudWxsXHJcbiAgICAgIGlmIChvZmZzZXQgKyB1c2VybmFtZUxlbmd0aCA+IGRhdGEubGVuZ3RoKSByZXR1cm4gbnVsbFxyXG4gICAgICBcclxuICAgICAgY29uc3QgdXNlcm5hbWUgPSBkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgdXNlcm5hbWVMZW5ndGgpLnRvU3RyaW5nKCd1dGY4JylcclxuICAgICAgb2Zmc2V0ICs9IHVzZXJuYW1lTGVuZ3RoXHJcbiAgICAgIFxyXG4gICAgICAvLyBWYWxpZGF0ZSB3ZSBoYXZlIGVub3VnaCBkYXRhIGZvciBiaW8gbGVuZ3RoXHJcbiAgICAgIGlmIChvZmZzZXQgKyA0ID4gZGF0YS5sZW5ndGgpIHJldHVybiBudWxsXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBiaW9MZW5ndGggPSBkYXRhLnJlYWRVSW50MzJMRShvZmZzZXQpXHJcbiAgICAgIG9mZnNldCArPSA0XHJcbiAgICAgIFxyXG4gICAgICAvLyBWYWxpZGF0ZSBiaW8gbGVuZ3RoIGlzIHJlYXNvbmFibGVcclxuICAgICAgaWYgKGJpb0xlbmd0aCA+IDEwMDApIHJldHVybiBudWxsXHJcbiAgICAgIGlmIChvZmZzZXQgKyBiaW9MZW5ndGggPiBkYXRhLmxlbmd0aCkgcmV0dXJuIG51bGxcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGJpbyA9IGRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBiaW9MZW5ndGgpLnRvU3RyaW5nKCd1dGY4JylcclxuICAgICAgb2Zmc2V0ICs9IGJpb0xlbmd0aFxyXG4gICAgICBcclxuICAgICAgLy8gVmFsaWRhdGUgd2UgaGF2ZSBlbm91Z2ggZGF0YSBmb3IgcHJvZmlsZSBpbWFnZSBsZW5ndGhcclxuICAgICAgaWYgKG9mZnNldCArIDQgPiBkYXRhLmxlbmd0aCkgcmV0dXJuIG51bGxcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHByb2ZpbGVJbWFnZUxlbmd0aCA9IGRhdGEucmVhZFVJbnQzMkxFKG9mZnNldClcclxuICAgICAgb2Zmc2V0ICs9IDRcclxuICAgICAgXHJcbiAgICAgIC8vIFZhbGlkYXRlIHByb2ZpbGUgaW1hZ2UgbGVuZ3RoIGlzIHJlYXNvbmFibGVcclxuICAgICAgaWYgKHByb2ZpbGVJbWFnZUxlbmd0aCA+IDUwMCkgcmV0dXJuIG51bGxcclxuICAgICAgaWYgKG9mZnNldCArIHByb2ZpbGVJbWFnZUxlbmd0aCA+IGRhdGEubGVuZ3RoKSByZXR1cm4gbnVsbFxyXG4gICAgICBcclxuICAgICAgY29uc3QgcHJvZmlsZV9pbWFnZSA9IGRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBwcm9maWxlSW1hZ2VMZW5ndGgpLnRvU3RyaW5nKCd1dGY4JylcclxuICAgICAgb2Zmc2V0ICs9IHByb2ZpbGVJbWFnZUxlbmd0aFxyXG4gICAgICBcclxuICAgICAgLy8gVmFsaWRhdGUgd2UgaGF2ZSBlbm91Z2ggZGF0YSBmb3IgY292ZXIgaW1hZ2UgbGVuZ3RoXHJcbiAgICAgIGlmIChvZmZzZXQgKyA0ID4gZGF0YS5sZW5ndGgpIHJldHVybiBudWxsXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBjb3ZlckltYWdlTGVuZ3RoID0gZGF0YS5yZWFkVUludDMyTEUob2Zmc2V0KVxyXG4gICAgICBvZmZzZXQgKz0gNFxyXG4gICAgICBcclxuICAgICAgLy8gVmFsaWRhdGUgY292ZXIgaW1hZ2UgbGVuZ3RoIGlzIHJlYXNvbmFibGVcclxuICAgICAgaWYgKGNvdmVySW1hZ2VMZW5ndGggPiA1MDApIHJldHVybiBudWxsXHJcbiAgICAgIGlmIChvZmZzZXQgKyBjb3ZlckltYWdlTGVuZ3RoID4gZGF0YS5sZW5ndGgpIHJldHVybiBudWxsXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBjb3Zlcl9pbWFnZSA9IGRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBjb3ZlckltYWdlTGVuZ3RoKS50b1N0cmluZygndXRmOCcpXHJcbiAgICAgIG9mZnNldCArPSBjb3ZlckltYWdlTGVuZ3RoXHJcbiAgICAgIFxyXG4gICAgICAvLyBWYWxpZGF0ZSB3ZSBoYXZlIGVub3VnaCBkYXRhIGZvciBhbGwgdGhlIHU2NCBmaWVsZHMgKDggYnl0ZXMgZWFjaCAqIDYgZmllbGRzID0gNDggYnl0ZXMpXHJcbiAgICAgIGlmIChvZmZzZXQgKyA0OCA+IGRhdGEubGVuZ3RoKSByZXR1cm4gbnVsbFxyXG4gICAgICBcclxuICAgICAgLy8gdTY0IGZpZWxkc1xyXG4gICAgICBjb25zdCBjcmVhdGVkX2F0ID0gZGF0YS5yZWFkQmlnVUludDY0TEUob2Zmc2V0KVxyXG4gICAgICBvZmZzZXQgKz0gOFxyXG4gICAgICBcclxuICAgICAgY29uc3QgZm9sbG93ZXJzX2NvdW50ID0gZGF0YS5yZWFkQmlnVUludDY0TEUob2Zmc2V0KVxyXG4gICAgICBvZmZzZXQgKz0gOFxyXG4gICAgICBcclxuICAgICAgY29uc3QgZm9sbG93aW5nX2NvdW50ID0gZGF0YS5yZWFkQmlnVUludDY0TEUob2Zmc2V0KVxyXG4gICAgICBvZmZzZXQgKz0gOFxyXG4gICAgICBcclxuICAgICAgLy8gaTY0IGZpZWxkXHJcbiAgICAgIGNvbnN0IHVzZXJfY3JlZGl0X3JhdGluZyA9IGRhdGEucmVhZEJpZ0ludDY0TEUob2Zmc2V0KVxyXG4gICAgICBvZmZzZXQgKz0gOFxyXG4gICAgICBcclxuICAgICAgY29uc3QgcG9zdHNfY291bnQgPSBkYXRhLnJlYWRCaWdVSW50NjRMRShvZmZzZXQpXHJcbiAgICAgIG9mZnNldCArPSA4XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBsYXN0X3Bvc3RfdGltZXN0YW1wID0gZGF0YS5yZWFkQmlnVUludDY0TEUob2Zmc2V0KVxyXG4gICAgICBvZmZzZXQgKz0gOFxyXG4gICAgICBcclxuICAgICAgY29uc3QgZGFpbHlfcG9zdF9jb3VudCA9IGRhdGEucmVhZEJpZ1VJbnQ2NExFKG9mZnNldClcclxuICAgICAgb2Zmc2V0ICs9IDhcclxuICAgICAgXHJcbiAgICAgIC8vIFZhbGlkYXRlIHdlIGhhdmUgZW5vdWdoIGRhdGEgZm9yIHRoZSBmaW5hbCB1OCBmaWVsZFxyXG4gICAgICBpZiAob2Zmc2V0ICsgMSA+IGRhdGEubGVuZ3RoKSByZXR1cm4gbnVsbFxyXG4gICAgICBcclxuICAgICAgY29uc3QgaXNfdmVyaWZpZWQgPSBkYXRhW29mZnNldF1cclxuICAgICAgb2Zmc2V0ICs9IDFcclxuICAgICAgXHJcbiAgICAgIHJldHVybiBuZXcgUHJvZmlsZUFjY291bnQoe1xyXG4gICAgICAgIGlzX2luaXRpYWxpemVkLFxyXG4gICAgICAgIG93bmVyOiBuZXcgVWludDhBcnJheShvd25lciksXHJcbiAgICAgICAgdXNlcm5hbWUsXHJcbiAgICAgICAgYmlvLFxyXG4gICAgICAgIHByb2ZpbGVfaW1hZ2UsXHJcbiAgICAgICAgY292ZXJfaW1hZ2UsXHJcbiAgICAgICAgY3JlYXRlZF9hdCxcclxuICAgICAgICBmb2xsb3dlcnNfY291bnQsXHJcbiAgICAgICAgZm9sbG93aW5nX2NvdW50LFxyXG4gICAgICAgIHVzZXJfY3JlZGl0X3JhdGluZyxcclxuICAgICAgICBwb3N0c19jb3VudCxcclxuICAgICAgICBsYXN0X3Bvc3RfdGltZXN0YW1wLFxyXG4gICAgICAgIGRhaWx5X3Bvc3RfY291bnQsXHJcbiAgICAgICAgaXNfdmVyaWZpZWRcclxuICAgICAgfSlcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIC8vIFNpbGVudCBmYWlsdXJlIC0gbm90IGEgcHJvZmlsZSBhY2NvdW50IG9yIGludmFsaWQgZGF0YVxyXG4gICAgICByZXR1cm4gbnVsbFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gTWFudWFsIHBvc3QgcGFyc2VyIC0gYnlwYXNzZXMgQm9yc2ggZGVzZXJpYWxpemF0aW9uIGlzc3Vlc1xyXG4gIGNvbnN0IG1hbnVhbFBhcnNlUG9zdCA9IChkYXRhOiBCdWZmZXIpOiBQb3N0QWNjb3VudCB8IG51bGwgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gUXVpY2sgdmFsaWRhdGlvbjogcG9zdHMgc2hvdWxkIGhhdmUgc3BlY2lmaWMgc2l6ZSBhbmQgc3RydWN0dXJlXHJcbiAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDEwMCkgcmV0dXJuIG51bGwgLy8gUG9zdHMgc2hvdWxkIGJlIGxhcmdlciB0aGFuIHByb2ZpbGVzXHJcbiAgICAgIFxyXG4gICAgICBsZXQgb2Zmc2V0ID0gMFxyXG4gICAgICBcclxuICAgICAgLy8gUGFyc2UgZWFjaCBmaWVsZCBtYW51YWxseVxyXG4gICAgICBjb25zdCBpc19pbml0aWFsaXplZCA9IGRhdGFbb2Zmc2V0XVxyXG4gICAgICBpZiAoaXNfaW5pdGlhbGl6ZWQgIT09IDEpIHJldHVybiBudWxsIC8vIE11c3QgYmUgaW5pdGlhbGl6ZWRcclxuICAgICAgb2Zmc2V0ICs9IDFcclxuICAgICAgXHJcbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgbG9va3MgbGlrZSBhIHBvc3QgdnMgcHJvZmlsZSBieSBleGFtaW5pbmcgdGhlIHN0cnVjdHVyZVxyXG4gICAgICAvLyBQb3N0cyBzdGFydCB3aXRoOiB1OCAoaW5pdCksIHU2NCAoaWQpLCBbMzJddTggKGF1dGhvciksIHN0cmluZyAoY29udGVudClcclxuICAgICAgLy8gUHJvZmlsZXMgc3RhcnQgd2l0aDogdTggKGluaXQpLCBbMzJddTggKG93bmVyKSwgc3RyaW5nICh1c2VybmFtZSlcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGlkID0gZGF0YS5yZWFkQmlnVUludDY0TEUob2Zmc2V0KVxyXG4gICAgICBvZmZzZXQgKz0gOFxyXG4gICAgICBcclxuICAgICAgY29uc3QgYXV0aG9yID0gZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIDMyKVxyXG4gICAgICBvZmZzZXQgKz0gMzJcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBkYXRhLnJlYWRVSW50MzJMRShvZmZzZXQpXHJcbiAgICAgIG9mZnNldCArPSA0XHJcbiAgICAgIFxyXG4gICAgICAvLyBWYWxpZGF0ZSBjb250ZW50IGxlbmd0aCBpcyByZWFzb25hYmxlIChub3QgdG9vIGxhcmdlKVxyXG4gICAgICBpZiAoY29udGVudExlbmd0aCA+IDEwMDAwIHx8IGNvbnRlbnRMZW5ndGggPT09IDApIHJldHVybiBudWxsXHJcbiAgICAgIGlmIChvZmZzZXQgKyBjb250ZW50TGVuZ3RoID4gZGF0YS5sZW5ndGgpIHJldHVybiBudWxsXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBjb250ZW50ID0gZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIGNvbnRlbnRMZW5ndGgpLnRvU3RyaW5nKCd1dGY4JylcclxuICAgICAgb2Zmc2V0ICs9IGNvbnRlbnRMZW5ndGhcclxuICAgICAgXHJcbiAgICAgIC8vIEVuc3VyZSB3ZSBoYXZlIGVub3VnaCByZW1haW5pbmcgZGF0YSBmb3IgdGhlIHJlc3Qgb2YgdGhlIHBvc3Qgc3RydWN0dXJlXHJcbiAgICAgIGlmIChvZmZzZXQgKyA0MCA+IGRhdGEubGVuZ3RoKSByZXR1cm4gbnVsbCAvLyBOZWVkIGF0IGxlYXN0IDQwIG1vcmUgYnl0ZXMgZm9yIHRpbWVzdGFtcHMgYW5kIGNvdW50c1xyXG4gICAgICBcclxuICAgICAgY29uc3QgdGltZXN0YW1wID0gZGF0YS5yZWFkQmlnVUludDY0TEUob2Zmc2V0KVxyXG4gICAgICBvZmZzZXQgKz0gOFxyXG4gICAgICBcclxuICAgICAgY29uc3QgbGlrZXMgPSBkYXRhLnJlYWRCaWdVSW50NjRMRShvZmZzZXQpXHJcbiAgICAgIG9mZnNldCArPSA4XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBjb21tZW50cyA9IGRhdGEucmVhZEJpZ1VJbnQ2NExFKG9mZnNldClcclxuICAgICAgb2Zmc2V0ICs9IDhcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IG1pcnJvcnMgPSBkYXRhLnJlYWRCaWdVSW50NjRMRShvZmZzZXQpXHJcbiAgICAgIG9mZnNldCArPSA4XHJcbiAgICAgIFxyXG4gICAgICAvLyBQYXJzZSBpbWFnZXMgYXJyYXkgbGVuZ3RoXHJcbiAgICAgIGlmIChvZmZzZXQgKyA0ID4gZGF0YS5sZW5ndGgpIHJldHVybiBudWxsXHJcbiAgICAgIGNvbnN0IGltYWdlc0xlbmd0aCA9IGRhdGEucmVhZFVJbnQzMkxFKG9mZnNldClcclxuICAgICAgb2Zmc2V0ICs9IDRcclxuICAgICAgY29uc3QgaW1hZ2VzOiBzdHJpbmdbXSA9IFtdXHJcbiAgICAgIFxyXG4gICAgICAvLyBQYXJzZSBpbWFnZXMgYXJyYXkgLSBlYWNoIGltYWdlIGlzIGEgbGVuZ3RoLXByZWZpeGVkIHN0cmluZ1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGltYWdlc0xlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKG9mZnNldCArIDQgPiBkYXRhLmxlbmd0aCkgcmV0dXJuIG51bGxcclxuICAgICAgICBjb25zdCBpbWFnZUxlbmd0aCA9IGRhdGEucmVhZFVJbnQzMkxFKG9mZnNldClcclxuICAgICAgICBvZmZzZXQgKz0gNFxyXG4gICAgICAgIGlmIChvZmZzZXQgKyBpbWFnZUxlbmd0aCA+IGRhdGEubGVuZ3RoKSByZXR1cm4gbnVsbFxyXG4gICAgICAgIGNvbnN0IGltYWdlID0gZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIGltYWdlTGVuZ3RoKS50b1N0cmluZygndXRmOCcpXHJcbiAgICAgICAgb2Zmc2V0ICs9IGltYWdlTGVuZ3RoXHJcbiAgICAgICAgaW1hZ2VzLnB1c2goaW1hZ2UpXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIEVuc3VyZSB3ZSBoYXZlIGVub3VnaCBkYXRhIGZvciByYXRpbmcgYW5kIGtpbGwgem9uZVxyXG4gICAgICBpZiAob2Zmc2V0ICsgMiA+IGRhdGEubGVuZ3RoKSByZXR1cm4gbnVsbFxyXG4gICAgICBcclxuICAgICAgY29uc3QgcmF0aW5nID0gZGF0YVtvZmZzZXRdXHJcbiAgICAgIG9mZnNldCArPSAxXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBpbl9raWxsX3pvbmUgPSBkYXRhW29mZnNldF1cclxuICAgICAgb2Zmc2V0ICs9IDFcclxuICAgICAgXHJcbiAgICAgIHJldHVybiBuZXcgUG9zdEFjY291bnQoe1xyXG4gICAgICAgIGlzX2luaXRpYWxpemVkLFxyXG4gICAgICAgIGlkLFxyXG4gICAgICAgIGF1dGhvcjogbmV3IFVpbnQ4QXJyYXkoYXV0aG9yKSxcclxuICAgICAgICBjb250ZW50LFxyXG4gICAgICAgIHRpbWVzdGFtcCxcclxuICAgICAgICBsaWtlcyxcclxuICAgICAgICBjb21tZW50cyxcclxuICAgICAgICBtaXJyb3JzLFxyXG4gICAgICAgIGltYWdlcyxcclxuICAgICAgICByYXRpbmcsXHJcbiAgICAgICAgaW5fa2lsbF96b25lXHJcbiAgICAgIH0pXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAvLyBTaWxlbnQgZmFpbHVyZSAtIG5vdCBhIHBvc3QgYWNjb3VudFxyXG4gICAgICByZXR1cm4gbnVsbFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQ29udmVydCBDb21tdW5pdHlBY2NvdW50IHRvIENvbW11bml0eSBpbnRlcmZhY2VcclxuICBjb25zdCBjb252ZXJ0Q29tbXVuaXR5QWNjb3VudCA9IChjb21tdW5pdHlBY2NvdW50OiBDb21tdW5pdHlBY2NvdW50KTogQ29tbXVuaXR5ID0+IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlzSW5pdGlhbGl6ZWQ6IGNvbW11bml0eUFjY291bnQuaXNfaW5pdGlhbGl6ZWQgPT09IDEsXHJcbiAgICAgIGlkOiBOdW1iZXIoY29tbXVuaXR5QWNjb3VudC5pZCksXHJcbiAgICAgIGNyZWF0b3I6IG5ldyBQdWJsaWNLZXkoY29tbXVuaXR5QWNjb3VudC5jcmVhdG9yKSxcclxuICAgICAgbmFtZTogY29tbXVuaXR5QWNjb3VudC5uYW1lLFxyXG4gICAgICBkZXNjcmlwdGlvbjogY29tbXVuaXR5QWNjb3VudC5kZXNjcmlwdGlvbixcclxuICAgICAgYXZhdGFyOiBjb21tdW5pdHlBY2NvdW50LmF2YXRhcixcclxuICAgICAgcnVsZXM6IGNvbW11bml0eUFjY291bnQucnVsZXMsXHJcbiAgICAgIG1lbWJlckNvdW50OiBOdW1iZXIoY29tbXVuaXR5QWNjb3VudC5tZW1iZXJfY291bnQpLFxyXG4gICAgICBjcmVhdGVkQXQ6IE51bWJlcihjb21tdW5pdHlBY2NvdW50LmNyZWF0ZWRfYXQpICogMTAwMCwgLy8gQ29udmVydCBzZWNvbmRzIHRvIG1pbGxpc2Vjb25kc1xyXG4gICAgICBpc1ByaXZhdGU6IGNvbW11bml0eUFjY291bnQuaXNfcHJpdmF0ZSA9PT0gMSxcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIENyZWF0ZSBDb21tdW5pdHlcclxuICBjb25zdCBjcmVhdGVDb21tdW5pdHkgPSBhc3luYyAoXHJcbiAgICBuYW1lOiBzdHJpbmcsXHJcbiAgICBkZXNjcmlwdGlvbjogc3RyaW5nLFxyXG4gICAgYXZhdGFyOiBzdHJpbmcsXHJcbiAgICBydWxlczogc3RyaW5nW10gPSBbXVxyXG4gICkgPT4ge1xyXG4gICAgaWYgKCFwdWJsaWNLZXkpIHRocm93IG5ldyBFcnJvcignV2FsbGV0IG5vdCBjb25uZWN0ZWQnKVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn4+Y77iPIENyZWF0aW5nIGNvbW11bml0eTonLCBuYW1lKVxyXG4gICAgICBcclxuICAgICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IGNoZWNrU09MQmFsYW5jZSgpXHJcbiAgICAgIGlmIChiYWxhbmNlIDwgMC4wNSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdWZmaWNpZW50IFNPTCBiYWxhbmNlOiAke2JhbGFuY2V9LiBOZWVkIGF0IGxlYXN0IDAuMDUgU09MLmApXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEdlbmVyYXRlIGEga2V5cGFpciBmb3IgdGhlIGNvbW11bml0eSBhY2NvdW50XHJcbiAgICAgIGNvbnN0IGNvbW11bml0eUtleXBhaXIgPSBLZXlwYWlyLmdlbmVyYXRlKClcclxuICAgICAgY29uc29sZS5sb2coYPCfk40gQ29tbXVuaXR5IEFjY291bnQ6ICR7Y29tbXVuaXR5S2V5cGFpci5wdWJsaWNLZXkudG9TdHJpbmcoKX1gKVxyXG5cclxuICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0gbmV3IENyZWF0ZUNvbW11bml0eUluc3RydWN0aW9uKHtcclxuICAgICAgICBuYW1lLFxyXG4gICAgICAgIGRlc2NyaXB0aW9uLFxyXG4gICAgICAgIGF2YXRhcixcclxuICAgICAgICBydWxlcyxcclxuICAgICAgfSlcclxuXHJcbiAgICAgIGNvbnN0IGNyZWF0ZUNvbW11bml0eVZhcmlhbnQgPSBCdWZmZXIuZnJvbShbN10pIC8vIENyZWF0ZUNvbW11bml0eSBlbnVtIGluZGV4XHJcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWREYXRhID0gc2VyaWFsaXplKGNyZWF0ZUNvbW11bml0eVNjaGVtYSwgaW5zdHJ1Y3Rpb25EYXRhKVxyXG4gICAgICBjb25zdCBmdWxsSW5zdHJ1Y3Rpb25EYXRhID0gQnVmZmVyLmNvbmNhdChbY3JlYXRlQ29tbXVuaXR5VmFyaWFudCwgQnVmZmVyLmZyb20oc2VyaWFsaXplZERhdGEpXSlcclxuXHJcbiAgICAgIGNvbnN0IGluc3RydWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xyXG4gICAgICAgIGtleXM6IFtcclxuICAgICAgICAgIHsgcHVia2V5OiBwdWJsaWNLZXksIGlzU2lnbmVyOiB0cnVlLCBpc1dyaXRhYmxlOiB0cnVlIH0sIC8vIENyZWF0b3IgYWNjb3VudFxyXG4gICAgICAgICAgeyBwdWJrZXk6IGNvbW11bml0eUtleXBhaXIucHVibGljS2V5LCBpc1NpZ25lcjogdHJ1ZSwgaXNXcml0YWJsZTogdHJ1ZSB9LCAvLyBDb21tdW5pdHkgYWNjb3VudFxyXG4gICAgICAgICAgeyBwdWJrZXk6IFN5c3RlbVByb2dyYW0ucHJvZ3JhbUlkLCBpc1NpZ25lcjogZmFsc2UsIGlzV3JpdGFibGU6IGZhbHNlIH0sIC8vIFN5c3RlbSBwcm9ncmFtXHJcbiAgICAgICAgXSxcclxuICAgICAgICBwcm9ncmFtSWQ6IFBST0dSQU1fSUQsXHJcbiAgICAgICAgZGF0YTogZnVsbEluc3RydWN0aW9uRGF0YSxcclxuICAgICAgfSlcclxuXHJcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKGluc3RydWN0aW9uKVxyXG4gICAgICBjb25zdCB7IGJsb2NraGFzaCB9ID0gYXdhaXQgY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goJ3Byb2Nlc3NlZCcpXHJcbiAgICAgIHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCA9IGJsb2NraGFzaFxyXG4gICAgICB0cmFuc2FjdGlvbi5mZWVQYXllciA9IHB1YmxpY0tleVxyXG5cclxuICAgICAgLy8gU2lnbiB3aXRoIGNvbW11bml0eSBrZXlwYWlyXHJcbiAgICAgIHRyYW5zYWN0aW9uLnBhcnRpYWxTaWduKGNvbW11bml0eUtleXBhaXIpXHJcblxyXG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIGNvbm5lY3Rpb24sIHtcclxuICAgICAgICBza2lwUHJlZmxpZ2h0OiBmYWxzZSxcclxuICAgICAgICBwcmVmbGlnaHRDb21taXRtZW50OiAncHJvY2Vzc2VkJyxcclxuICAgICAgICBtYXhSZXRyaWVzOiAzLFxyXG4gICAgICAgIHNpZ25lcnM6IFtjb21tdW5pdHlLZXlwYWlyXSxcclxuICAgICAgfSlcclxuXHJcbiAgICAgIGF3YWl0IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHtcclxuICAgICAgICBzaWduYXR1cmUsXHJcbiAgICAgICAgYmxvY2toYXNoLFxyXG4gICAgICAgIGxhc3RWYWxpZEJsb2NrSGVpZ2h0OiAoYXdhaXQgY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goKSkubGFzdFZhbGlkQmxvY2tIZWlnaHQsXHJcbiAgICAgIH0sICdwcm9jZXNzZWQnKVxyXG5cclxuICAgICAgY29uc29sZS5sb2coJ+KchSBDb21tdW5pdHkgY3JlYXRlZCBzdWNjZXNzZnVsbHkhJylcclxuICAgICAgdG9hc3Quc3VjY2VzcyhgQ29tbXVuaXR5IFwiJHtuYW1lfVwiIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5IWApXHJcbiAgICAgIHJldHVybiBzaWduYXR1cmVcclxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIENvbW11bml0eSBjcmVhdGlvbiBlcnJvcjonLCBlcnJvcilcclxuICAgICAgdG9hc3QuZXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgY29tbXVuaXR5OiAke2Vycm9yLm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InfWApXHJcbiAgICAgIHRocm93IGVycm9yXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBGb2xsb3cgUHJvZmlsZVxyXG4gIGNvbnN0IGZvbGxvd1Byb2ZpbGUgPSBhc3luYyAocHJvZmlsZVB1YmxpY0tleTogUHVibGljS2V5KSA9PiB7XHJcbiAgICBpZiAoIXB1YmxpY0tleSkgdGhyb3cgbmV3IEVycm9yKCdXYWxsZXQgbm90IGNvbm5lY3RlZCcpXHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ/CfkaUgRm9sbG93aW5nIHByb2ZpbGU6JywgcHJvZmlsZVB1YmxpY0tleS50b1N0cmluZygpKVxyXG5cclxuICAgICAgLy8gRmluZCB0aGUgZm9sbG93ZXIncyBwcm9maWxlIGFjY291bnQgKGN1cnJlbnQgdXNlcidzIHByb2ZpbGUpXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIFNlYXJjaGluZyBmb3IgZm9sbG93ZXIgcHJvZmlsZTogJHtwdWJsaWNLZXkudG9TdHJpbmcoKS5zbGljZSgwLCA4KX0uLi5gKVxyXG4gICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0UHJvZ3JhbUFjY291bnRzKFBST0dSQU1fSUQpXHJcbiAgICAgIGxldCBmb2xsb3dlclByb2ZpbGVBZGRyZXNzOiBQdWJsaWNLZXkgfCBudWxsID0gbnVsbFxyXG4gICAgICBcclxuICAgICAgZm9yIChjb25zdCB7IGFjY291bnQsIHB1YmtleSB9IG9mIGFjY291bnRzKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IHBhcnNlZFByb2ZpbGUgPSBtYW51YWxQYXJzZVByb2ZpbGUoYWNjb3VudC5kYXRhKVxyXG4gICAgICAgICAgaWYgKHBhcnNlZFByb2ZpbGUgJiYgXHJcbiAgICAgICAgICAgICAgcGFyc2VkUHJvZmlsZS5pc19pbml0aWFsaXplZCA9PT0gMSAmJiBcclxuICAgICAgICAgICAgICBuZXcgUHVibGljS2V5KHBhcnNlZFByb2ZpbGUub3duZXIpLmVxdWFscyhwdWJsaWNLZXkpKSB7XHJcbiAgICAgICAgICAgIGZvbGxvd2VyUHJvZmlsZUFkZHJlc3MgPSBwdWJrZXlcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBGb3VuZCBmb2xsb3dlciBwcm9maWxlIGFjY291bnQ6ICR7cHVia2V5LnRvU3RyaW5nKCl9YClcclxuICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgLy8gU2lsZW50IGZhaWx1cmUgLSBub3QgYSBwcm9maWxlIGFjY291bnRcclxuICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIWZvbGxvd2VyUHJvZmlsZUFkZHJlc3MpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IGNyZWF0ZSBhIHByb2ZpbGUgYmVmb3JlIGZvbGxvd2luZyBvdGhlcnMnKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSBuZXcgRm9sbG93UHJvZmlsZUluc3RydWN0aW9uKHtcclxuICAgICAgICBwcm9maWxlX2lkOiBwcm9maWxlUHVibGljS2V5LFxyXG4gICAgICB9KVxyXG5cclxuICAgICAgY29uc3QgZm9sbG93UHJvZmlsZVZhcmlhbnQgPSBCdWZmZXIuZnJvbShbNV0pIC8vIEZvbGxvd1Byb2ZpbGUgZW51bSBpbmRleFxyXG4gICAgICBjb25zdCBzZXJpYWxpemVkRGF0YSA9IHNlcmlhbGl6ZShmb2xsb3dQcm9maWxlU2NoZW1hLCBpbnN0cnVjdGlvbkRhdGEpXHJcbiAgICAgIGNvbnN0IGZ1bGxJbnN0cnVjdGlvbkRhdGEgPSBCdWZmZXIuY29uY2F0KFtmb2xsb3dQcm9maWxlVmFyaWFudCwgQnVmZmVyLmZyb20oc2VyaWFsaXplZERhdGEpXSlcclxuXHJcbiAgICAgIGNvbnN0IGluc3RydWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xyXG4gICAgICAgIGtleXM6IFtcclxuICAgICAgICAgIHsgcHVia2V5OiBwdWJsaWNLZXksIGlzU2lnbmVyOiB0cnVlLCBpc1dyaXRhYmxlOiBmYWxzZSB9LCAvLyBGb2xsb3dlciBhY2NvdW50XHJcbiAgICAgICAgICB7IHB1YmtleTogcHJvZmlsZVB1YmxpY0tleSwgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiB0cnVlIH0sIC8vIFByb2ZpbGUgdG8gZm9sbG93XHJcbiAgICAgICAgICB7IHB1YmtleTogZm9sbG93ZXJQcm9maWxlQWRkcmVzcywgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiB0cnVlIH0sIC8vIEZvbGxvd2VyJ3MgcHJvZmlsZSBhY2NvdW50XHJcbiAgICAgICAgXSxcclxuICAgICAgICBwcm9ncmFtSWQ6IFBST0dSQU1fSUQsXHJcbiAgICAgICAgZGF0YTogZnVsbEluc3RydWN0aW9uRGF0YSxcclxuICAgICAgfSlcclxuXHJcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKGluc3RydWN0aW9uKVxyXG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIGNvbm5lY3Rpb24pXHJcblxyXG4gICAgICBhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbihzaWduYXR1cmUsICdwcm9jZXNzZWQnKVxyXG4gICAgICBcclxuICAgICAgLy8gQ2xlYXIgcHJvZmlsZSBjYWNoZSB0byBmb3JjZSByZWZyZXNoIG9mIGZvbGxvd2VyIGNvdW50c1xyXG4gICAgICBjbGVhclByb2ZpbGVDYWNoZSgpXHJcbiAgICAgIFxyXG4gICAgICB0b2FzdC5zdWNjZXNzKCdQcm9maWxlIGZvbGxvd2VkIScpXHJcbiAgICAgIHJldHVybiBzaWduYXR1cmVcclxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRm9sbG93IGVycm9yOicsIGVycm9yKVxyXG4gICAgICB0b2FzdC5lcnJvcignRmFpbGVkIHRvIGZvbGxvdyBwcm9maWxlJylcclxuICAgICAgdGhyb3cgZXJyb3JcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFVuZm9sbG93IFByb2ZpbGVcclxuICBjb25zdCB1bmZvbGxvd1Byb2ZpbGUgPSBhc3luYyAocHJvZmlsZVB1YmxpY0tleTogUHVibGljS2V5KSA9PiB7XHJcbiAgICBpZiAoIXB1YmxpY0tleSkgdGhyb3cgbmV3IEVycm9yKCdXYWxsZXQgbm90IGNvbm5lY3RlZCcpXHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ/CfkaUgVW5mb2xsb3dpbmcgcHJvZmlsZTonLCBwcm9maWxlUHVibGljS2V5LnRvU3RyaW5nKCkpXHJcblxyXG4gICAgICAvLyBGaW5kIHRoZSBmb2xsb3dlcidzIHByb2ZpbGUgYWNjb3VudCAoY3VycmVudCB1c2VyJ3MgcHJvZmlsZSlcclxuICAgICAgY29uc29sZS5sb2coYPCflI0gU2VhcmNoaW5nIGZvciBmb2xsb3dlciBwcm9maWxlOiAke3B1YmxpY0tleS50b1N0cmluZygpLnNsaWNlKDAsIDgpfS4uLmApXHJcbiAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgY29ubmVjdGlvbi5nZXRQcm9ncmFtQWNjb3VudHMoUFJPR1JBTV9JRClcclxuICAgICAgbGV0IGZvbGxvd2VyUHJvZmlsZUFkZHJlc3M6IFB1YmxpY0tleSB8IG51bGwgPSBudWxsXHJcbiAgICAgIFxyXG4gICAgICBmb3IgKGNvbnN0IHsgYWNjb3VudCwgcHVia2V5IH0gb2YgYWNjb3VudHMpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgcGFyc2VkUHJvZmlsZSA9IG1hbnVhbFBhcnNlUHJvZmlsZShhY2NvdW50LmRhdGEpXHJcbiAgICAgICAgICBpZiAocGFyc2VkUHJvZmlsZSAmJiBcclxuICAgICAgICAgICAgICBwYXJzZWRQcm9maWxlLmlzX2luaXRpYWxpemVkID09PSAxICYmIFxyXG4gICAgICAgICAgICAgIG5ldyBQdWJsaWNLZXkocGFyc2VkUHJvZmlsZS5vd25lcikuZXF1YWxzKHB1YmxpY0tleSkpIHtcclxuICAgICAgICAgICAgZm9sbG93ZXJQcm9maWxlQWRkcmVzcyA9IHB1YmtleVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEZvdW5kIGZvbGxvd2VyIHByb2ZpbGUgYWNjb3VudDogJHtwdWJrZXkudG9TdHJpbmcoKX1gKVxyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAvLyBTaWxlbnQgZmFpbHVyZSAtIG5vdCBhIHByb2ZpbGUgYWNjb3VudFxyXG4gICAgICAgICAgY29udGludWVcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghZm9sbG93ZXJQcm9maWxlQWRkcmVzcykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgY3JlYXRlIGEgcHJvZmlsZSBiZWZvcmUgdW5mb2xsb3dpbmcgb3RoZXJzJylcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0gbmV3IEZvbGxvd1Byb2ZpbGVJbnN0cnVjdGlvbih7XHJcbiAgICAgICAgcHJvZmlsZV9pZDogcHJvZmlsZVB1YmxpY0tleSxcclxuICAgICAgfSlcclxuXHJcbiAgICAgIGNvbnN0IHVuZm9sbG93UHJvZmlsZVZhcmlhbnQgPSBCdWZmZXIuZnJvbShbNl0pIC8vIFVuZm9sbG93UHJvZmlsZSBlbnVtIGluZGV4XHJcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWREYXRhID0gc2VyaWFsaXplKGZvbGxvd1Byb2ZpbGVTY2hlbWEsIGluc3RydWN0aW9uRGF0YSlcclxuICAgICAgY29uc3QgZnVsbEluc3RydWN0aW9uRGF0YSA9IEJ1ZmZlci5jb25jYXQoW3VuZm9sbG93UHJvZmlsZVZhcmlhbnQsIEJ1ZmZlci5mcm9tKHNlcmlhbGl6ZWREYXRhKV0pXHJcblxyXG4gICAgICBjb25zdCBpbnN0cnVjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcclxuICAgICAgICBrZXlzOiBbXHJcbiAgICAgICAgICB7IHB1YmtleTogcHVibGljS2V5LCBpc1NpZ25lcjogdHJ1ZSwgaXNXcml0YWJsZTogZmFsc2UgfSwgLy8gRm9sbG93ZXIgYWNjb3VudFxyXG4gICAgICAgICAgeyBwdWJrZXk6IHByb2ZpbGVQdWJsaWNLZXksIGlzU2lnbmVyOiBmYWxzZSwgaXNXcml0YWJsZTogdHJ1ZSB9LCAvLyBQcm9maWxlIHRvIHVuZm9sbG93XHJcbiAgICAgICAgICB7IHB1YmtleTogZm9sbG93ZXJQcm9maWxlQWRkcmVzcywgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiB0cnVlIH0sIC8vIEZvbGxvd2VyJ3MgcHJvZmlsZSBhY2NvdW50XHJcbiAgICAgICAgXSxcclxuICAgICAgICBwcm9ncmFtSWQ6IFBST0dSQU1fSUQsXHJcbiAgICAgICAgZGF0YTogZnVsbEluc3RydWN0aW9uRGF0YSxcclxuICAgICAgfSlcclxuXHJcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKGluc3RydWN0aW9uKVxyXG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIGNvbm5lY3Rpb24pXHJcblxyXG4gICAgICBhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbihzaWduYXR1cmUsICdwcm9jZXNzZWQnKVxyXG4gICAgICBcclxuICAgICAgLy8gQ2xlYXIgcHJvZmlsZSBjYWNoZSB0byBmb3JjZSByZWZyZXNoIG9mIGZvbGxvd2VyIGNvdW50c1xyXG4gICAgICBjbGVhclByb2ZpbGVDYWNoZSgpXHJcbiAgICAgIFxyXG4gICAgICB0b2FzdC5zdWNjZXNzKCdQcm9maWxlIHVuZm9sbG93ZWQhJylcclxuICAgICAgcmV0dXJuIHNpZ25hdHVyZVxyXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdVbmZvbGxvdyBlcnJvcjonLCBlcnJvcilcclxuICAgICAgdG9hc3QuZXJyb3IoJ0ZhaWxlZCB0byB1bmZvbGxvdyBwcm9maWxlJylcclxuICAgICAgdGhyb3cgZXJyb3JcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFVwZGF0ZSBQcm9maWxlXHJcbiAgY29uc3QgdXBkYXRlUHJvZmlsZSA9IGFzeW5jIChcclxuICAgIHVzZXJuYW1lOiBzdHJpbmcsXHJcbiAgICBiaW86IHN0cmluZyxcclxuICAgIHByb2ZpbGVJbWFnZTogc3RyaW5nLFxyXG4gICAgY292ZXJJbWFnZTogc3RyaW5nXHJcbiAgKSA9PiB7XHJcbiAgICBpZiAoIXB1YmxpY0tleSkgdGhyb3cgbmV3IEVycm9yKCdXYWxsZXQgbm90IGNvbm5lY3RlZCcpXHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ/CflIQgVXBkYXRpbmcgcHJvZmlsZTonLCB1c2VybmFtZSlcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGluc3RydWN0aW9uRGF0YSA9IG5ldyBDcmVhdGVQcm9maWxlSW5zdHJ1Y3Rpb24oe1xyXG4gICAgICAgIHVzZXJuYW1lLFxyXG4gICAgICAgIGJpbyxcclxuICAgICAgICBwcm9maWxlX2ltYWdlOiBwcm9maWxlSW1hZ2UsXHJcbiAgICAgICAgY292ZXJfaW1hZ2U6IGNvdmVySW1hZ2UsXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBjb25zdCB1cGRhdGVQcm9maWxlVmFyaWFudCA9IEJ1ZmZlci5mcm9tKFsxXSkgLy8gVXBkYXRlUHJvZmlsZSBlbnVtIGluZGV4IChzYW1lIGFzIENyZWF0ZVByb2ZpbGUpXHJcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWREYXRhID0gc2VyaWFsaXplKGNyZWF0ZVByb2ZpbGVTY2hlbWEsIGluc3RydWN0aW9uRGF0YSlcclxuICAgICAgY29uc3QgZnVsbEluc3RydWN0aW9uRGF0YSA9IEJ1ZmZlci5jb25jYXQoW3VwZGF0ZVByb2ZpbGVWYXJpYW50LCBCdWZmZXIuZnJvbShzZXJpYWxpemVkRGF0YSldKVxyXG5cclxuICAgICAgY29uc3QgaW5zdHJ1Y3Rpb24gPSBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XHJcbiAgICAgICAga2V5czogW1xyXG4gICAgICAgICAgeyBwdWJrZXk6IHB1YmxpY0tleSwgaXNTaWduZXI6IHRydWUsIGlzV3JpdGFibGU6IHRydWUgfSwgLy8gUHJvZmlsZSBvd25lciBhY2NvdW50XHJcbiAgICAgICAgXSxcclxuICAgICAgICBwcm9ncmFtSWQ6IFBST0dSQU1fSUQsXHJcbiAgICAgICAgZGF0YTogZnVsbEluc3RydWN0aW9uRGF0YSxcclxuICAgICAgfSlcclxuXHJcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKGluc3RydWN0aW9uKVxyXG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIGNvbm5lY3Rpb24pXHJcblxyXG4gICAgICBhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbihzaWduYXR1cmUsICdwcm9jZXNzZWQnKVxyXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFByb2ZpbGUgdXBkYXRlZCBzdWNjZXNzZnVsbHkhJylcclxuICAgICAgXHJcbiAgICAgIC8vIENsZWFyIGNhY2hlIHRvIGZvcmNlIHJlZnJlc2hcclxuICAgICAgcHJvZmlsZUNhY2hlLmRlbGV0ZShwdWJsaWNLZXkudG9TdHJpbmcoKSlcclxuICAgICAgXHJcbiAgICAgIHJldHVybiBzaWduYXR1cmVcclxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIFVwZGF0ZSBwcm9maWxlIGVycm9yOicsIGVycm9yKVxyXG4gICAgICB0aHJvdyBlcnJvclxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQ29tbWVudCBvbiBQb3N0XHJcbiAgY29uc3QgY29tbWVudE9uUG9zdCA9IGFzeW5jIChwb3N0SWQ6IG51bWJlciwgY29udGVudDogc3RyaW5nLCBwb3N0QXV0aG9yOiBQdWJsaWNLZXkpID0+IHtcclxuICAgIGlmICghcHVibGljS2V5KSB0aHJvdyBuZXcgRXJyb3IoJ1dhbGxldCBub3QgY29ubmVjdGVkJylcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+SrCBDb21tZW50aW5nIG9uIHBvc3QgSUQgJHtwb3N0SWR9Li4uYClcclxuICAgICAgXHJcbiAgICAgIC8vIENoZWNrIFNPTCBiYWxhbmNlIGZpcnN0XHJcbiAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBjaGVja1NPTEJhbGFuY2UoKVxyXG4gICAgICBpZiAoYmFsYW5jZSA8IDAuMDEpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluc3VmZmljaWVudCBTT0wgYmFsYW5jZTogJHtiYWxhbmNlfS4gTmVlZCBhdCBsZWFzdCAwLjAxIFNPTCBmb3IgdHJhbnNhY3Rpb24gZmVlcy5gKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBGaW5kIHRoZSBhY3R1YWwgcG9zdCBhY2NvdW50IGJ5IHNjYW5uaW5nIGFsbCBwcm9ncmFtIGFjY291bnRzXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIFNlYXJjaGluZyBmb3IgcG9zdCBJRCAke3Bvc3RJZH0gYnkgYXV0aG9yICR7cG9zdEF1dGhvci50b1N0cmluZygpLnNsaWNlKDAsIDgpfS4uLmApXHJcbiAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgY29ubmVjdGlvbi5nZXRQcm9ncmFtQWNjb3VudHMoUFJPR1JBTV9JRClcclxuICAgICAgbGV0IHBvc3RBZGRyZXNzOiBQdWJsaWNLZXkgfCBudWxsID0gbnVsbFxyXG4gICAgICBsZXQgdXNlclByb2ZpbGVBZGRyZXNzOiBQdWJsaWNLZXkgfCBudWxsID0gbnVsbFxyXG4gICAgICBcclxuICAgICAgLy8gRmlyc3QgcGFzczogZmluZCB0aGUgcG9zdCBhY2NvdW50XHJcbiAgICAgIGZvciAoY29uc3QgeyBhY2NvdW50LCBwdWJrZXkgfSBvZiBhY2NvdW50cykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCBwYXJzZWRQb3N0ID0gbWFudWFsUGFyc2VQb3N0KGFjY291bnQuZGF0YSlcclxuICAgICAgICAgIGlmIChwYXJzZWRQb3N0ICYmIFxyXG4gICAgICAgICAgICAgIHBhcnNlZFBvc3QuaXNfaW5pdGlhbGl6ZWQgPT09IDEgJiYgXHJcbiAgICAgICAgICAgICAgTnVtYmVyKHBhcnNlZFBvc3QuaWQpID09PSBwb3N0SWQgJiZcclxuICAgICAgICAgICAgICBuZXcgUHVibGljS2V5KHBhcnNlZFBvc3QuYXV0aG9yKS5lcXVhbHMocG9zdEF1dGhvcikpIHtcclxuICAgICAgICAgICAgcG9zdEFkZHJlc3MgPSBwdWJrZXlcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBGb3VuZCBwb3N0IGFjY291bnQ6ICR7cHVia2V5LnRvU3RyaW5nKCl9YClcclxuICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgLy8gU2lsZW50IGZhaWx1cmUgLSBub3QgYSBwb3N0IGFjY291bnRcclxuICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXBvc3RBZGRyZXNzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb3N0IHdpdGggSUQgJHtwb3N0SWR9IG5vdCBmb3VuZGApXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFNlY29uZCBwYXNzOiBmaW5kIHRoZSBjb21tZW50ZXIncyBwcm9maWxlIGFjY291bnRcclxuICAgICAgY29uc29sZS5sb2coYPCflI0gU2VhcmNoaW5nIGZvciBjb21tZW50ZXIgcHJvZmlsZTogJHtwdWJsaWNLZXkudG9TdHJpbmcoKS5zbGljZSgwLCA4KX0uLi5gKVxyXG4gICAgICBmb3IgKGNvbnN0IHsgYWNjb3VudCwgcHVia2V5IH0gb2YgYWNjb3VudHMpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgcGFyc2VkUHJvZmlsZSA9IG1hbnVhbFBhcnNlUHJvZmlsZShhY2NvdW50LmRhdGEpXHJcbiAgICAgICAgICBpZiAocGFyc2VkUHJvZmlsZSAmJiBcclxuICAgICAgICAgICAgICBwYXJzZWRQcm9maWxlLmlzX2luaXRpYWxpemVkID09PSAxICYmIFxyXG4gICAgICAgICAgICAgIG5ldyBQdWJsaWNLZXkocGFyc2VkUHJvZmlsZS5vd25lcikuZXF1YWxzKHB1YmxpY0tleSkpIHtcclxuICAgICAgICAgICAgdXNlclByb2ZpbGVBZGRyZXNzID0gcHVia2V5XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgRm91bmQgY29tbWVudGVyIHByb2ZpbGUgYWNjb3VudDogJHtwdWJrZXkudG9TdHJpbmcoKX1gKVxyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAvLyBTaWxlbnQgZmFpbHVyZSAtIG5vdCBhIHByb2ZpbGUgYWNjb3VudFxyXG4gICAgICAgICAgY29udGludWVcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghdXNlclByb2ZpbGVBZGRyZXNzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBjcmVhdGUgYSBwcm9maWxlIGJlZm9yZSBjb21tZW50aW5nJylcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gR2VuZXJhdGUgYSBuZXcga2V5cGFpciBmb3IgdGhlIGNvbW1lbnQgYWNjb3VudFxyXG4gICAgICBjb25zdCBjb21tZW50S2V5cGFpciA9IEtleXBhaXIuZ2VuZXJhdGUoKVxyXG4gICAgICBjb25zb2xlLmxvZyhg8J+TjSBDb21tZW50IEFjY291bnQ6ICR7Y29tbWVudEtleXBhaXIucHVibGljS2V5LnRvU3RyaW5nKCl9YClcclxuXHJcbiAgICAgIGNvbnN0IGluc3RydWN0aW9uRGF0YSA9IG5ldyBDb21tZW50T25Qb3N0SW5zdHJ1Y3Rpb24oe1xyXG4gICAgICAgIGNvbnRlbnQsXHJcbiAgICAgICAgcGFyZW50X2lkOiBCaWdJbnQocG9zdElkKSxcclxuICAgICAgfSlcclxuXHJcbiAgICAgIGNvbnN0IGNvbW1lbnRWYXJpYW50ID0gQnVmZmVyLmZyb20oWzRdKSAvLyBDb21tZW50T25Qb3N0IGVudW0gaW5kZXhcclxuICAgICAgY29uc3Qgc2VyaWFsaXplZERhdGEgPSBzZXJpYWxpemUoY29tbWVudE9uUG9zdFNjaGVtYSwgaW5zdHJ1Y3Rpb25EYXRhKVxyXG4gICAgICBjb25zdCBmdWxsSW5zdHJ1Y3Rpb25EYXRhID0gQnVmZmVyLmNvbmNhdChbY29tbWVudFZhcmlhbnQsIEJ1ZmZlci5mcm9tKHNlcmlhbGl6ZWREYXRhKV0pXHJcblxyXG4gICAgICBjb25zdCBpbnN0cnVjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcclxuICAgICAgICBrZXlzOiBbXHJcbiAgICAgICAgICB7IHB1YmtleTogcHVibGljS2V5LCBpc1NpZ25lcjogdHJ1ZSwgaXNXcml0YWJsZTogdHJ1ZSB9LCAvLyBVc2VyIGFjY291bnQgKGNvbW1lbnRlcilcclxuICAgICAgICAgIHsgcHVia2V5OiBjb21tZW50S2V5cGFpci5wdWJsaWNLZXksIGlzU2lnbmVyOiB0cnVlLCBpc1dyaXRhYmxlOiB0cnVlIH0sIC8vIENvbW1lbnQgYWNjb3VudCAobmV3KVxyXG4gICAgICAgICAgeyBwdWJrZXk6IHBvc3RBZGRyZXNzLCBpc1NpZ25lcjogZmFsc2UsIGlzV3JpdGFibGU6IHRydWUgfSwgLy8gUGFyZW50IHBvc3QgYWNjb3VudFxyXG4gICAgICAgICAgeyBwdWJrZXk6IHVzZXJQcm9maWxlQWRkcmVzcywgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiB0cnVlIH0sIC8vIFVzZXIgcHJvZmlsZSBhY2NvdW50XHJcbiAgICAgICAgICB7IHB1YmtleTogU3lzdGVtUHJvZ3JhbS5wcm9ncmFtSWQsIGlzU2lnbmVyOiBmYWxzZSwgaXNXcml0YWJsZTogZmFsc2UgfSwgLy8gU3lzdGVtIHByb2dyYW1cclxuICAgICAgICBdLFxyXG4gICAgICAgIHByb2dyYW1JZDogUFJPR1JBTV9JRCxcclxuICAgICAgICBkYXRhOiBmdWxsSW5zdHJ1Y3Rpb25EYXRhLFxyXG4gICAgICB9KVxyXG5cclxuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoaW5zdHJ1Y3Rpb24pXHJcbiAgICAgIGNvbnN0IHsgYmxvY2toYXNoIH0gPSBhd2FpdCBjb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCgncHJvY2Vzc2VkJylcclxuICAgICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoXHJcbiAgICAgIHRyYW5zYWN0aW9uLmZlZVBheWVyID0gcHVibGljS2V5XHJcblxyXG4gICAgICAvLyBTaWduIHdpdGggY29tbWVudCBrZXlwYWlyXHJcbiAgICAgIHRyYW5zYWN0aW9uLnBhcnRpYWxTaWduKGNvbW1lbnRLZXlwYWlyKVxyXG5cclxuICAgICAgY29uc29sZS5sb2coJ/Cfjq8gU2ltdWxhdGluZyB0cmFuc2FjdGlvbi4uLicpXHJcbiAgICAgIGNvbnN0IHNpbXVsYXRpb24gPSBhd2FpdCBjb25uZWN0aW9uLnNpbXVsYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pXHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OKIFNpbXVsYXRpb24gcmVzdWx0OicsIHNpbXVsYXRpb24pXHJcblxyXG4gICAgICBpZiAoc2ltdWxhdGlvbi52YWx1ZS5lcnIpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgU2ltdWxhdGlvbiBmYWlsZWQ6Jywgc2ltdWxhdGlvbi52YWx1ZS5lcnIpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiBzaW11bGF0aW9uIGZhaWxlZDogJHtKU09OLnN0cmluZ2lmeShzaW11bGF0aW9uLnZhbHVlLmVycil9YClcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBjb25uZWN0aW9uLCB7XHJcbiAgICAgICAgc2tpcFByZWZsaWdodDogZmFsc2UsXHJcbiAgICAgICAgcHJlZmxpZ2h0Q29tbWl0bWVudDogJ3Byb2Nlc3NlZCcsXHJcbiAgICAgICAgbWF4UmV0cmllczogMyxcclxuICAgICAgICBzaWduZXJzOiBbY29tbWVudEtleXBhaXJdLCAvLyBDb21tZW50IGtleXBhaXIgbXVzdCBzaWduIHRoZSB0cmFuc2FjdGlvblxyXG4gICAgICB9KVxyXG5cclxuICAgICAgYXdhaXQgY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oe1xyXG4gICAgICAgIHNpZ25hdHVyZSxcclxuICAgICAgICBibG9ja2hhc2gsXHJcbiAgICAgICAgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IChhd2FpdCBjb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCgpKS5sYXN0VmFsaWRCbG9ja0hlaWdodCxcclxuICAgICAgfSwgJ3Byb2Nlc3NlZCcpXHJcblxyXG4gICAgICBjb25zb2xlLmxvZygn4pyFIENvbW1lbnQgcG9zdGVkIHN1Y2Nlc3NmdWxseSEnKVxyXG4gICAgICBcclxuICAgICAgLy8gQ2xlYXIgcG9zdHMgY2FjaGUgdG8gZm9yY2UgcmVmcmVzaFxyXG4gICAgICBwb3N0c0NhY2hlID0gbnVsbFxyXG4gICAgICBcclxuICAgICAgdG9hc3Quc3VjY2VzcygnQ29tbWVudCBwb3N0ZWQhJylcclxuICAgICAgcmV0dXJuIHNpZ25hdHVyZVxyXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgQ29tbWVudCBwb3N0IGVycm9yOicsIGVycm9yKVxyXG4gICAgICB0b2FzdC5lcnJvcihgRmFpbGVkIHRvIGNvbW1lbnQ6ICR7ZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YClcclxuICAgICAgdGhyb3cgZXJyb3JcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEJvb2ttYXJrIFBvc3QgKHVzaW5nIGxvY2FsU3RvcmFnZSBzaW5jZSB3ZSBkb24ndCBoYXZlIGJvb2ttYXJrIGZ1bmN0aW9uYWxpdHkpXHJcbiAgY29uc3QgYm9va21hcmtQb3N0ID0gYXN5bmMgKHBvc3RJZDogbnVtYmVyKSA9PiB7XHJcbiAgICBpZiAoIXB1YmxpY0tleSkgdGhyb3cgbmV3IEVycm9yKCdXYWxsZXQgbm90IGNvbm5lY3RlZCcpXHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coYPCflJYgQm9va21hcmtpbmcgcG9zdCBJRCAke3Bvc3RJZH0uLi5gKVxyXG4gICAgICBcclxuICAgICAgY29uc3QgYm9va21hcmtzS2V5ID0gYGJvb2ttYXJrc18ke3B1YmxpY0tleS50b1N0cmluZygpfWBcclxuICAgICAgY29uc3QgZXhpc3RpbmdCb29rbWFya3MgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShib29rbWFya3NLZXkpXHJcbiAgICAgIGNvbnN0IGJvb2ttYXJrczogbnVtYmVyW10gPSBleGlzdGluZ0Jvb2ttYXJrcyA/IEpTT04ucGFyc2UoZXhpc3RpbmdCb29rbWFya3MpIDogW11cclxuICAgICAgXHJcbiAgICAgIGlmIChib29rbWFya3MuaW5jbHVkZXMocG9zdElkKSkge1xyXG4gICAgICAgIC8vIFJlbW92ZSBib29rbWFya1xyXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRCb29rbWFya3MgPSBib29rbWFya3MuZmlsdGVyKGlkID0+IGlkICE9PSBwb3N0SWQpXHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oYm9va21hcmtzS2V5LCBKU09OLnN0cmluZ2lmeSh1cGRhdGVkQm9va21hcmtzKSlcclxuICAgICAgICB0b2FzdC5zdWNjZXNzKCdCb29rbWFyayByZW1vdmVkIScpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gQWRkIGJvb2ttYXJrXHJcbiAgICAgICAgYm9va21hcmtzLnB1c2gocG9zdElkKVxyXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGJvb2ttYXJrc0tleSwgSlNPTi5zdHJpbmdpZnkoYm9va21hcmtzKSlcclxuICAgICAgICB0b2FzdC5zdWNjZXNzKCdQb3N0IGJvb2ttYXJrZWQhJylcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgcmV0dXJuICdib29rbWFya2VkJ1xyXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgQm9va21hcmsgZXJyb3I6JywgZXJyb3IpXHJcbiAgICAgIHRvYXN0LmVycm9yKCdGYWlsZWQgdG8gYm9va21hcmsgcG9zdCcpXHJcbiAgICAgIHRocm93IGVycm9yXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBHZXQgdXNlciBib29rbWFya3NcclxuICBjb25zdCBnZXRVc2VyQm9va21hcmtzID0gKCk6IG51bWJlcltdID0+IHtcclxuICAgIGlmICghcHVibGljS2V5KSByZXR1cm4gW11cclxuICAgIFxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgYm9va21hcmtzS2V5ID0gYGJvb2ttYXJrc18ke3B1YmxpY0tleS50b1N0cmluZygpfWBcclxuICAgICAgY29uc3QgZXhpc3RpbmdCb29rbWFya3MgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShib29rbWFya3NLZXkpXHJcbiAgICAgIHJldHVybiBleGlzdGluZ0Jvb2ttYXJrcyA/IEpTT04ucGFyc2UoZXhpc3RpbmdCb29rbWFya3MpIDogW11cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgYm9va21hcmtzOicsIGVycm9yKVxyXG4gICAgICByZXR1cm4gW11cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIENoZWNrIGlmIHBvc3QgaXMgYm9va21hcmtlZFxyXG4gIGNvbnN0IGlzUG9zdEJvb2ttYXJrZWQgPSAocG9zdElkOiBudW1iZXIpOiBib29sZWFuID0+IHtcclxuICAgIGNvbnN0IGJvb2ttYXJrcyA9IGdldFVzZXJCb29rbWFya3MoKVxyXG4gICAgcmV0dXJuIGJvb2ttYXJrcy5pbmNsdWRlcyhwb3N0SWQpXHJcbiAgfVxyXG5cclxuICAvLyBVdGlsaXR5IGZ1bmN0aW9uIHRvIHByZWxvYWQgcHJvZmlsZSBvbiB3YWxsZXQgY29ubmVjdGlvblxyXG4gIGNvbnN0IHByZWxvYWRQcm9maWxlID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgaWYgKCFwdWJsaWNLZXkpIHJldHVyblxyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygn8J+agCBQcmVsb2FkaW5nIHByb2ZpbGUgb24gd2FsbGV0IGNvbm5lY3Rpb24uLi4nKVxyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgZ2V0UHJvZmlsZShwdWJsaWNLZXkpXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBwcmVsb2FkIHByb2ZpbGU6JywgZXJyb3IpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBGb3JjZSByZWZyZXNoIGFsbCBkYXRhIC0gY2xlYXJzIGFsbCBjYWNoZXNcclxuICBjb25zdCByZWZyZXNoRGF0YSA9ICgpID0+IHtcclxuICAgIGNvbnNvbGUubG9nKCfwn5SEIEZvcmNlIHJlZnJlc2hpbmcgYWxsIGRhdGEuLi4nKVxyXG4gICAgY2xlYXJQcm9maWxlQ2FjaGUoKVxyXG4gICAgcG9zdHNDYWNoZSA9IG51bGxcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBjcmVhdGVQcm9maWxlLFxyXG4gICAgY3JlYXRlUG9zdCxcclxuICAgIGxpa2VQb3N0LFxyXG4gICAgZ2V0UHJvZmlsZSxcclxuICAgIGdldFByb2ZpbGVCeVVzZXJuYW1lLFxyXG4gICAgZ2V0UG9zdHMsXHJcbiAgICBnZXRQcm9maWxlUERBLFxyXG4gICAgZ2V0UG9zdFBEQSxcclxuICAgIGNoZWNrUHJvZmlsZUF0UERBLFxyXG4gICAgcHJlbG9hZFByb2ZpbGUsXHJcbiAgICBjbGVhclByb2ZpbGVDYWNoZSxcclxuICAgIHJlZnJlc2hEYXRhLFxyXG4gICAgY3JlYXRlQ29tbXVuaXR5LFxyXG4gICAgZm9sbG93UHJvZmlsZSxcclxuICAgIHVuZm9sbG93UHJvZmlsZSxcclxuICAgIHVwZGF0ZVByb2ZpbGUsXHJcbiAgICBjb21tZW50T25Qb3N0LFxyXG4gICAgYm9va21hcmtQb3N0LFxyXG4gICAgZ2V0VXNlckJvb2ttYXJrcyxcclxuICAgIGlzUG9zdEJvb2ttYXJrZWQsXHJcbiAgfVxyXG59Il0sIm5hbWVzIjpbInVzZUNvbm5lY3Rpb24iLCJ1c2VXYWxsZXQiLCJQdWJsaWNLZXkiLCJUcmFuc2FjdGlvbiIsIlRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24iLCJTeXN0ZW1Qcm9ncmFtIiwiTEFNUE9SVFNfUEVSX1NPTCIsIktleXBhaXIiLCJzZXJpYWxpemUiLCJkZXNlcmlhbGl6ZSIsInRvYXN0IiwiY29uZmlnIiwiUFJPR1JBTV9JRCIsInNvbGFuYSIsInByb2dyYW1JZCIsIkRFQlVHX01PREUiLCJwcm9jZXNzIiwiQ29udHJhY3RJbnN0cnVjdGlvbiIsIlBvc3RSYXRpbmciLCJDcmVhdGVQcm9maWxlSW5zdHJ1Y3Rpb24iLCJjb25zdHJ1Y3RvciIsImZpZWxkcyIsInVzZXJuYW1lIiwiYmlvIiwicHJvZmlsZV9pbWFnZSIsImNvdmVyX2ltYWdlIiwiQ3JlYXRlUG9zdEluc3RydWN0aW9uIiwiY29udGVudCIsImltYWdlcyIsIkxpa2VQb3N0SW5zdHJ1Y3Rpb24iLCJwb3N0X2lkIiwiQ29tbWVudE9uUG9zdEluc3RydWN0aW9uIiwicGFyZW50X2lkIiwiQm9va21hcmtQb3N0SW5zdHJ1Y3Rpb24iLCJQcm9maWxlQWNjb3VudCIsImlzX2luaXRpYWxpemVkIiwib3duZXIiLCJjcmVhdGVkX2F0IiwiZm9sbG93ZXJzX2NvdW50IiwiZm9sbG93aW5nX2NvdW50IiwidXNlcl9jcmVkaXRfcmF0aW5nIiwicG9zdHNfY291bnQiLCJsYXN0X3Bvc3RfdGltZXN0YW1wIiwiZGFpbHlfcG9zdF9jb3VudCIsImlzX3ZlcmlmaWVkIiwiUG9zdEFjY291bnQiLCJpZCIsImF1dGhvciIsInRpbWVzdGFtcCIsImxpa2VzIiwiY29tbWVudHMiLCJtaXJyb3JzIiwicmF0aW5nIiwiaW5fa2lsbF96b25lIiwiY3JlYXRlUHJvZmlsZVNjaGVtYSIsIk1hcCIsImtpbmQiLCJjcmVhdGVQb3N0U2NoZW1hIiwibGlrZVBvc3RTY2hlbWEiLCJjb21tZW50T25Qb3N0U2NoZW1hIiwiYm9va21hcmtQb3N0U2NoZW1hIiwicHJvZmlsZUFjY291bnRTY2hlbWEiLCJwb3N0QWNjb3VudFNjaGVtYSIsIkNvbW11bml0eUFjY291bnQiLCJjcmVhdG9yIiwibmFtZSIsImRlc2NyaXB0aW9uIiwiYXZhdGFyIiwicnVsZXMiLCJtZW1iZXJfY291bnQiLCJpc19wcml2YXRlIiwiQ3JlYXRlQ29tbXVuaXR5SW5zdHJ1Y3Rpb24iLCJGb2xsb3dQcm9maWxlSW5zdHJ1Y3Rpb24iLCJwcm9maWxlX2lkIiwidG9CdWZmZXIiLCJjcmVhdGVDb21tdW5pdHlTY2hlbWEiLCJmb2xsb3dQcm9maWxlU2NoZW1hIiwiY29tbXVuaXR5QWNjb3VudFNjaGVtYSIsInByb2ZpbGVDYWNoZSIsIkNBQ0hFX0RVUkFUSU9OIiwicG9zdHNDYWNoZSIsIlBPU1RTX0NBQ0hFX0RVUkFUSU9OIiwiTE9DQUxTVE9SQUdFX0NBQ0hFX1BSRUZJWCIsIkxPQ0FMU1RPUkFHRV9DQUNIRV9EVVJBVElPTiIsInNhdmVQcm9maWxlVG9Mb2NhbFN0b3JhZ2UiLCJ3YWxsZXRBZGRyZXNzIiwicHJvZmlsZSIsImNhY2hlS2V5IiwiY2FjaGVEYXRhIiwiRGF0ZSIsIm5vdyIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJKU09OIiwic3RyaW5naWZ5IiwiY29uc29sZSIsImxvZyIsInNsaWNlIiwiZXJyb3IiLCJ3YXJuIiwiZ2V0UHJvZmlsZUZyb21Mb2NhbFN0b3JhZ2UiLCJjYWNoZWQiLCJnZXRJdGVtIiwicGFyc2UiLCJyZW1vdmVJdGVtIiwiY2xlYXJQcm9maWxlQ2FjaGUiLCJkZWxldGUiLCJjbGVhciIsImtleXMiLCJPYmplY3QiLCJmb3JFYWNoIiwia2V5Iiwic3RhcnRzV2l0aCIsInVzZUJsb2Nrc1Byb2dyYW0iLCJjb25uZWN0aW9uIiwicHVibGljS2V5Iiwic2VuZFRyYW5zYWN0aW9uIiwiZ2V0UHJvZmlsZVBEQSIsInVzZXJQdWJsaWNLZXkiLCJwcm9maWxlUERBIiwiZmluZFByb2dyYW1BZGRyZXNzIiwiQnVmZmVyIiwiZnJvbSIsImdldFBvc3RQREEiLCJwb3N0SWQiLCJwb3N0UERBIiwidG9TdHJpbmciLCJjaGVja1Byb2dyYW1FeGlzdHMiLCJwcm9ncmFtSW5mbyIsImdldEFjY291bnRJbmZvIiwiZXhlY3V0YWJsZSIsImNoZWNrU09MQmFsYW5jZSIsImJhbGFuY2UiLCJnZXRCYWxhbmNlIiwiY29udmVydFByb2ZpbGVBY2NvdW50IiwicHJvZmlsZUFjY291bnQiLCJjYWxjdWxhdGVVQ1IiLCJwb3N0c0NvdW50IiwiTnVtYmVyIiwiZm9sbG93ZXJzQ291bnQiLCJmb2xsb3dpbmdDb3VudCIsInVjciIsInBvc3RzU2NvcmUiLCJNYXRoIiwibWluIiwiZm9sbG93ZXJzU2NvcmUiLCJyYXRpb0JvbnVzIiwicmF0aW8iLCJhY2NvdW50QWdlIiwiZGF5c09sZCIsImFnZUJvbnVzIiwidmVyaWZpY2F0aW9uQm9udXMiLCJsYXN0UG9zdEFnZSIsImRheXNTaW5jZUxhc3RQb3N0IiwiYWN0aXZpdHlCb251cyIsImlzSW5pdGlhbGl6ZWQiLCJwcm9maWxlSW1hZ2UiLCJjb3ZlckltYWdlIiwiY3JlYXRlZEF0IiwidXNlckNyZWRpdFJhdGluZyIsImxhc3RQb3N0VGltZXN0YW1wIiwiZGFpbHlQb3N0Q291bnQiLCJpc1ZlcmlmaWVkIiwiY29udmVydFBvc3RBY2NvdW50IiwicG9zdEFjY291bnQiLCJpbktpbGxab25lIiwiY3JlYXRlUHJvZmlsZSIsIkVycm9yIiwicHJvZ3JhbUV4aXN0cyIsIm5ldHdvcmsiLCJpbnN0cnVjdGlvbkRhdGEiLCJjcmVhdGVQcm9maWxlVmFyaWFudCIsInNlcmlhbGl6ZWREYXRhIiwiZnVsbEluc3RydWN0aW9uRGF0YSIsImNvbmNhdCIsImluc3RydWN0aW9uIiwicHVia2V5IiwiaXNTaWduZXIiLCJpc1dyaXRhYmxlIiwiZGF0YSIsInRyYW5zYWN0aW9uIiwiYWRkIiwiYmxvY2toYXNoIiwiZ2V0TGF0ZXN0QmxvY2toYXNoIiwicmVjZW50QmxvY2toYXNoIiwiZmVlUGF5ZXIiLCJzaW11bGF0aW9uIiwic2ltdWxhdGVUcmFuc2FjdGlvbiIsInZhbHVlIiwiZXJyIiwic2lnbmF0dXJlIiwic2tpcFByZWZsaWdodCIsInByZWZsaWdodENvbW1pdG1lbnQiLCJtYXhSZXRyaWVzIiwiY29uZmlybVRyYW5zYWN0aW9uIiwibGFzdFZhbGlkQmxvY2tIZWlnaHQiLCJzdWNjZXNzIiwibWVzc2FnZSIsImdldFByb2ZpbGUiLCJjYWNoZWRQcm9maWxlIiwic2V0Iiwic2V0VGltZW91dCIsImhhcyIsImdldCIsImFjY291bnRzIiwiZ2V0UHJvZ3JhbUFjY291bnRzIiwibGVuZ3RoIiwicHJvZmlsZXNGb3VuZCIsImFjY291bnQiLCJtYW51YWxQYXJzZVByb2ZpbGUiLCJhY2NvdW50T3duZXIiLCJlcXVhbHMiLCJnZXRQcm9maWxlQnlVc2VybmFtZSIsImFjY291bnRJbmZvIiwiZ2V0UG9zdHMiLCJwb3N0cyIsIm1hbnVhbFBhcnNlUG9zdCIsInBvc3QiLCJwdXNoIiwic3Vic3RyaW5nIiwic29ydCIsImEiLCJiIiwiY3JlYXRlUG9zdCIsInVzZXJQcm9maWxlIiwicG9zdEtleXBhaXIiLCJnZW5lcmF0ZSIsInVzZXJQcm9maWxlUERBIiwiY3JlYXRlUG9zdFZhcmlhbnQiLCJtYXAiLCJrIiwicGFydGlhbFNpZ24iLCJzaWduZXJzIiwiaW5jbHVkZXMiLCJ0b0ZpeGVkIiwibGlrZVBvc3QiLCJwb3N0QXV0aG9yIiwicG9zdEFjY291bnRBZGRyZXNzIiwiYXV0aG9yUHJvZmlsZUFkZHJlc3MiLCJwYXJzZWRQb3N0IiwicGFyc2VkUHJvZmlsZSIsIkJpZ0ludCIsImxpa2VQb3N0VmFyaWFudCIsImNoZWNrUHJvZmlsZUF0UERBIiwicGRhQWRkcmVzcyIsInBkYSIsIkFycmF5Iiwib2Zmc2V0IiwidXNlcm5hbWVMZW5ndGgiLCJyZWFkVUludDMyTEUiLCJiaW9MZW5ndGgiLCJwcm9maWxlSW1hZ2VMZW5ndGgiLCJjb3ZlckltYWdlTGVuZ3RoIiwicmVhZEJpZ1VJbnQ2NExFIiwicmVhZEJpZ0ludDY0TEUiLCJVaW50OEFycmF5IiwiY29udGVudExlbmd0aCIsImltYWdlc0xlbmd0aCIsImkiLCJpbWFnZUxlbmd0aCIsImltYWdlIiwiY29udmVydENvbW11bml0eUFjY291bnQiLCJjb21tdW5pdHlBY2NvdW50IiwibWVtYmVyQ291bnQiLCJpc1ByaXZhdGUiLCJjcmVhdGVDb21tdW5pdHkiLCJjb21tdW5pdHlLZXlwYWlyIiwiY3JlYXRlQ29tbXVuaXR5VmFyaWFudCIsImZvbGxvd1Byb2ZpbGUiLCJwcm9maWxlUHVibGljS2V5IiwiZm9sbG93ZXJQcm9maWxlQWRkcmVzcyIsImZvbGxvd1Byb2ZpbGVWYXJpYW50IiwidW5mb2xsb3dQcm9maWxlIiwidW5mb2xsb3dQcm9maWxlVmFyaWFudCIsInVwZGF0ZVByb2ZpbGUiLCJ1cGRhdGVQcm9maWxlVmFyaWFudCIsImNvbW1lbnRPblBvc3QiLCJwb3N0QWRkcmVzcyIsInVzZXJQcm9maWxlQWRkcmVzcyIsImNvbW1lbnRLZXlwYWlyIiwiY29tbWVudFZhcmlhbnQiLCJib29rbWFya1Bvc3QiLCJib29rbWFya3NLZXkiLCJleGlzdGluZ0Jvb2ttYXJrcyIsImJvb2ttYXJrcyIsInVwZGF0ZWRCb29rbWFya3MiLCJmaWx0ZXIiLCJnZXRVc2VyQm9va21hcmtzIiwiaXNQb3N0Qm9va21hcmtlZCIsInByZWxvYWRQcm9maWxlIiwicmVmcmVzaERhdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useBlocksProgram.ts\n"));

/***/ })

});