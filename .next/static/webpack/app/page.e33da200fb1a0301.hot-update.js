"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/useBlocksProgram.ts":
/*!***********************************!*\
  !*** ./hooks/useBlocksProgram.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PostRating: function() { return /* binding */ PostRating; },\n/* harmony export */   useBlocksProgram: function() { return /* binding */ useBlocksProgram; }\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/wallet-adapter-react */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/useConnection.js\");\n/* harmony import */ var _solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @solana/wallet-adapter-react */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/useWallet.js\");\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n/* harmony import */ var borsh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! borsh */ \"(app-pages-browser)/./node_modules/borsh/lib/index.js\");\n/* harmony import */ var borsh__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(borsh__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_hot_toast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-hot-toast */ \"(app-pages-browser)/./node_modules/react-hot-toast/dist/index.mjs\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/config */ \"(app-pages-browser)/./config/index.ts\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\n\n\n\n// Your deployed program ID - configured from environment\nconst PROGRAM_ID = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(_config__WEBPACK_IMPORTED_MODULE_3__.config.solana.programId);\n// Add debug mode for testing without actual blockchain transactions\nconst DEBUG_MODE = \"development\" === \"development\";\nvar ContractInstruction;\n// Instruction enum matching your Rust contract\n(function(ContractInstruction) {\n    ContractInstruction[ContractInstruction[\"CreateProfile\"] = 0] = \"CreateProfile\";\n    ContractInstruction[ContractInstruction[\"UpdateProfile\"] = 1] = \"UpdateProfile\";\n    ContractInstruction[ContractInstruction[\"CreatePost\"] = 2] = \"CreatePost\";\n    ContractInstruction[ContractInstruction[\"LikePost\"] = 3] = \"LikePost\";\n    ContractInstruction[ContractInstruction[\"CommentOnPost\"] = 4] = \"CommentOnPost\";\n    ContractInstruction[ContractInstruction[\"FollowProfile\"] = 5] = \"FollowProfile\";\n    ContractInstruction[ContractInstruction[\"UnfollowProfile\"] = 6] = \"UnfollowProfile\";\n    ContractInstruction[ContractInstruction[\"CreateCommunity\"] = 7] = \"CreateCommunity\";\n    ContractInstruction[ContractInstruction[\"JoinCommunity\"] = 8] = \"JoinCommunity\";\n})(ContractInstruction || (ContractInstruction = {}));\nvar PostRating;\n(function(PostRating) {\n    PostRating[PostRating[\"None\"] = 0] = \"None\";\n    PostRating[PostRating[\"Bronze\"] = 1] = \"Bronze\";\n    PostRating[PostRating[\"Silver\"] = 2] = \"Silver\";\n    PostRating[PostRating[\"Gold\"] = 3] = \"Gold\";\n    PostRating[PostRating[\"Platinum\"] = 4] = \"Platinum\";\n    PostRating[PostRating[\"Diamond\"] = 5] = \"Diamond\";\n    PostRating[PostRating[\"Ace\"] = 6] = \"Ace\";\n    PostRating[PostRating[\"Conqueror\"] = 7] = \"Conqueror\";\n})(PostRating || (PostRating = {}));\n// Create Profile instruction data class\nclass CreateProfileInstruction {\n    constructor(fields){\n        this.username = fields.username;\n        this.bio = fields.bio;\n        this.profile_image = fields.profile_image;\n        this.cover_image = fields.cover_image;\n    }\n}\n// Create Post instruction data class\nclass CreatePostInstruction {\n    constructor(fields){\n        this.content = fields.content;\n        this.images = fields.images;\n    }\n}\n// Like Post instruction data class\nclass LikePostInstruction {\n    constructor(fields){\n        this.post_id = fields.post_id;\n    }\n}\n// Profile struct for deserialization - matching Rust exactly\nclass ProfileAccount {\n    constructor(fields){\n        this.is_initialized = fields.is_initialized;\n        this.owner = fields.owner;\n        this.username = fields.username;\n        this.bio = fields.bio;\n        this.profile_image = fields.profile_image;\n        this.cover_image = fields.cover_image;\n        this.created_at = fields.created_at;\n        this.followers_count = fields.followers_count;\n        this.following_count = fields.following_count;\n        this.user_credit_rating = fields.user_credit_rating;\n        this.posts_count = fields.posts_count;\n        this.last_post_timestamp = fields.last_post_timestamp;\n        this.daily_post_count = fields.daily_post_count;\n        this.is_verified = fields.is_verified;\n    }\n}\n// Post struct for deserialization - matching Rust exactly\nclass PostAccount {\n    constructor(fields){\n        this.is_initialized = fields.is_initialized;\n        this.id = fields.id;\n        this.author = fields.author;\n        this.content = fields.content;\n        this.timestamp = fields.timestamp;\n        this.likes = fields.likes;\n        this.comments = fields.comments;\n        this.mirrors = fields.mirrors;\n        this.images = fields.images;\n        this.rating = fields.rating;\n        this.in_kill_zone = fields.in_kill_zone;\n    }\n}\n// Borsh schemas\nconst createProfileSchema = new Map([\n    [\n        CreateProfileInstruction,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"username\",\n                    \"string\"\n                ],\n                [\n                    \"bio\",\n                    \"string\"\n                ],\n                [\n                    \"profile_image\",\n                    \"string\"\n                ],\n                [\n                    \"cover_image\",\n                    \"string\"\n                ]\n            ]\n        }\n    ]\n]);\nconst createPostSchema = new Map([\n    [\n        CreatePostInstruction,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"content\",\n                    \"string\"\n                ],\n                [\n                    \"images\",\n                    [\n                        \"string\"\n                    ]\n                ]\n            ]\n        }\n    ]\n]);\nconst likePostSchema = new Map([\n    [\n        LikePostInstruction,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"post_id\",\n                    \"u64\"\n                ]\n            ]\n        }\n    ]\n]);\nconst profileAccountSchema = new Map([\n    [\n        ProfileAccount,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"is_initialized\",\n                    \"u8\"\n                ],\n                [\n                    \"owner\",\n                    [\n                        32\n                    ]\n                ],\n                [\n                    \"username\",\n                    \"string\"\n                ],\n                [\n                    \"bio\",\n                    \"string\"\n                ],\n                [\n                    \"profile_image\",\n                    \"string\"\n                ],\n                [\n                    \"cover_image\",\n                    \"string\"\n                ],\n                [\n                    \"created_at\",\n                    \"u64\"\n                ],\n                [\n                    \"followers_count\",\n                    \"u64\"\n                ],\n                [\n                    \"following_count\",\n                    \"u64\"\n                ],\n                [\n                    \"user_credit_rating\",\n                    \"i64\"\n                ],\n                [\n                    \"posts_count\",\n                    \"u64\"\n                ],\n                [\n                    \"last_post_timestamp\",\n                    \"u64\"\n                ],\n                [\n                    \"daily_post_count\",\n                    \"u64\"\n                ],\n                [\n                    \"is_verified\",\n                    \"u8\"\n                ]\n            ]\n        }\n    ]\n]);\nconst postAccountSchema = new Map([\n    [\n        PostAccount,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"is_initialized\",\n                    \"u8\"\n                ],\n                [\n                    \"id\",\n                    \"u64\"\n                ],\n                [\n                    \"author\",\n                    [\n                        32\n                    ]\n                ],\n                [\n                    \"content\",\n                    \"string\"\n                ],\n                [\n                    \"timestamp\",\n                    \"u64\"\n                ],\n                [\n                    \"likes\",\n                    \"u64\"\n                ],\n                [\n                    \"comments\",\n                    \"u64\"\n                ],\n                [\n                    \"mirrors\",\n                    \"u64\"\n                ],\n                [\n                    \"images\",\n                    [\n                        \"string\"\n                    ]\n                ],\n                [\n                    \"rating\",\n                    \"u8\"\n                ],\n                [\n                    \"in_kill_zone\",\n                    \"u8\"\n                ]\n            ]\n        }\n    ]\n]);\n// Community struct for deserialization\nclass CommunityAccount {\n    constructor(fields){\n        this.is_initialized = fields.is_initialized;\n        this.id = fields.id;\n        this.creator = fields.creator;\n        this.name = fields.name;\n        this.description = fields.description;\n        this.avatar = fields.avatar;\n        this.rules = fields.rules;\n        this.member_count = fields.member_count;\n        this.created_at = fields.created_at;\n        this.is_private = fields.is_private;\n    }\n}\n// Create Community instruction\nclass CreateCommunityInstruction {\n    constructor(fields){\n        this.name = fields.name;\n        this.description = fields.description;\n        this.avatar = fields.avatar;\n        this.rules = fields.rules;\n    }\n}\n// Follow Profile instruction\nclass FollowProfileInstruction {\n    constructor(fields){\n        this.profile_id = fields.profile_id.toBuffer();\n    }\n}\nconst createCommunitySchema = new Map([\n    [\n        CreateCommunityInstruction,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"name\",\n                    \"string\"\n                ],\n                [\n                    \"description\",\n                    \"string\"\n                ],\n                [\n                    \"avatar\",\n                    \"string\"\n                ],\n                [\n                    \"rules\",\n                    [\n                        \"string\"\n                    ]\n                ]\n            ]\n        }\n    ]\n]);\nconst followProfileSchema = new Map([\n    [\n        FollowProfileInstruction,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"profile_id\",\n                    [\n                        32\n                    ]\n                ]\n            ]\n        }\n    ]\n]);\nconst communityAccountSchema = new Map([\n    [\n        CommunityAccount,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"is_initialized\",\n                    \"u8\"\n                ],\n                [\n                    \"id\",\n                    \"u64\"\n                ],\n                [\n                    \"creator\",\n                    [\n                        32\n                    ]\n                ],\n                [\n                    \"name\",\n                    \"string\"\n                ],\n                [\n                    \"description\",\n                    \"string\"\n                ],\n                [\n                    \"avatar\",\n                    \"string\"\n                ],\n                [\n                    \"rules\",\n                    [\n                        \"string\"\n                    ]\n                ],\n                [\n                    \"member_count\",\n                    \"u64\"\n                ],\n                [\n                    \"created_at\",\n                    \"u64\"\n                ],\n                [\n                    \"is_private\",\n                    \"u8\"\n                ]\n            ]\n        }\n    ]\n]);\n// Cache for profile lookups to avoid repeated blockchain calls\nconst profileCache = new Map();\nconst CACHE_DURATION = 60000 // 1 minute for memory cache (increased from 30 seconds)\n;\n// Posts cache\nlet postsCache = null;\nconst POSTS_CACHE_DURATION = 30000 // 30 seconds for posts cache (increased from 10 seconds)\n;\n// localStorage cache configuration - Updated to support multiple profiles\nconst LOCALSTORAGE_CACHE_PREFIX = \"blocks_profile_\";\nconst LOCALSTORAGE_CACHE_DURATION = 10 * 60 * 1000 // 10 minutes for localStorage cache (increased from 5 minutes)\n;\n// localStorage cache utilities - Updated to support multiple profiles\nconst saveProfileToLocalStorage = (walletAddress, profile)=>{\n    try {\n        const cacheKey = \"\".concat(LOCALSTORAGE_CACHE_PREFIX).concat(walletAddress);\n        const cacheData = {\n            profile,\n            timestamp: Date.now(),\n            walletAddress\n        };\n        localStorage.setItem(cacheKey, JSON.stringify(cacheData));\n        console.log(\"\\uD83D\\uDCBE Profile cached to localStorage for \".concat(walletAddress.slice(0, 8)));\n    } catch (error) {\n        console.warn(\"Failed to save profile to localStorage:\", error);\n    }\n};\nconst getProfileFromLocalStorage = (walletAddress)=>{\n    try {\n        const cacheKey = \"\".concat(LOCALSTORAGE_CACHE_PREFIX).concat(walletAddress);\n        const cached = localStorage.getItem(cacheKey);\n        if (!cached) return null;\n        const cacheData = JSON.parse(cached);\n        // Check if cache is expired\n        if (Date.now() - cacheData.timestamp > LOCALSTORAGE_CACHE_DURATION) {\n            console.log(\"⏰ Cache expired for \".concat(walletAddress.slice(0, 8), \", clearing\"));\n            localStorage.removeItem(cacheKey);\n            return null;\n        }\n        console.log(\"⚡ Using cached profile from localStorage for \".concat(walletAddress.slice(0, 8)));\n        return cacheData.profile;\n    } catch (error) {\n        console.warn(\"Failed to read profile from localStorage:\", error);\n        const cacheKey = \"\".concat(LOCALSTORAGE_CACHE_PREFIX).concat(walletAddress);\n        localStorage.removeItem(cacheKey);\n        return null;\n    }\n};\nconst clearProfileCache = (walletAddress)=>{\n    // Clear memory cache\n    if (walletAddress) {\n        profileCache.delete(walletAddress);\n        // Clear localStorage cache for specific user\n        const cacheKey = \"\".concat(LOCALSTORAGE_CACHE_PREFIX).concat(walletAddress);\n        localStorage.removeItem(cacheKey);\n    } else {\n        profileCache.clear();\n        // Clear all localStorage profile caches\n        const keys = Object.keys(localStorage);\n        keys.forEach((key)=>{\n            if (key.startsWith(LOCALSTORAGE_CACHE_PREFIX)) {\n                localStorage.removeItem(key);\n            }\n        });\n    }\n    // Clear posts cache\n    postsCache = null;\n    console.log(\"\\uD83D\\uDDD1️ Profile and posts cache cleared\");\n};\nfunction useBlocksProgram() {\n    const { connection } = (0,_solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_4__.useConnection)();\n    const { publicKey, sendTransaction } = (0,_solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_5__.useWallet)();\n    // Get profile PDA\n    const getProfilePDA = async (userPublicKey, username)=>{\n        const [profilePDA] = await _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey.findProgramAddress([\n            userPublicKey.toBuffer(),\n            Buffer.from(\"profile\"),\n            Buffer.from(username)\n        ], PROGRAM_ID);\n        return profilePDA;\n    };\n    // Get post PDA\n    const getPostPDA = async (userPublicKey, postId)=>{\n        const [postPDA] = await _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey.findProgramAddress([\n            userPublicKey.toBuffer(),\n            Buffer.from(\"post\"),\n            Buffer.from(postId.toString())\n        ], PROGRAM_ID);\n        return postPDA;\n    };\n    // Helper function to check if program exists\n    const checkProgramExists = async ()=>{\n        try {\n            const programInfo = await connection.getAccountInfo(PROGRAM_ID);\n            return programInfo !== null && programInfo.executable;\n        } catch (error) {\n            console.error(\"Error checking program existence:\", error);\n            return false;\n        }\n    };\n    // Helper function to check SOL balance\n    const checkSOLBalance = async ()=>{\n        if (!publicKey) return 0;\n        try {\n            const balance = await connection.getBalance(publicKey);\n            return balance / _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.LAMPORTS_PER_SOL;\n        } catch (error) {\n            console.error(\"Error checking SOL balance:\", error);\n            return 0;\n        }\n    };\n    // Convert ProfileAccount to Profile interface\n    const convertProfileAccount = (profileAccount)=>{\n        // Calculate UCR based on activity\n        const calculateUCR = (profile)=>{\n            const postsCount = Number(profile.posts_count);\n            const followersCount = Number(profile.followers_count);\n            const followingCount = Number(profile.following_count);\n            // Base UCR calculation algorithm\n            let ucr = 1.0 // Start with base rating\n            ;\n            // Posts factor (0.1 points per post, max 2.0 points)\n            const postsScore = Math.min(postsCount * 0.1, 2.0);\n            // Followers factor (0.05 points per follower, max 1.5 points)\n            const followersScore = Math.min(followersCount * 0.05, 1.5);\n            // Following/followers ratio (healthy ratio = bonus)\n            let ratioBonus = 0;\n            if (followersCount > 0 && followingCount > 0) {\n                const ratio = followersCount / followingCount;\n                if (ratio >= 0.5 && ratio <= 2.0) {\n                    ratioBonus = 0.3;\n                }\n            }\n            // Account age factor (older accounts get bonus)\n            const accountAge = Date.now() - Number(profile.created_at) * 1000;\n            const daysOld = accountAge / (1000 * 60 * 60 * 24);\n            const ageBonus = Math.min(daysOld / 30 * 0.2, 1.0) // 0.2 points per month, max 1.0\n            ;\n            // Verification bonus\n            const verificationBonus = profile.is_verified === 1 ? 0.5 : 0;\n            // Activity factor (posting regularly)\n            const lastPostAge = Date.now() - Number(profile.last_post_timestamp) * 1000;\n            const daysSinceLastPost = lastPostAge / (1000 * 60 * 60 * 24);\n            const activityBonus = daysSinceLastPost < 7 ? 0.3 : daysSinceLastPost < 30 ? 0.1 : 0;\n            ucr = ucr + postsScore + followersScore + ratioBonus + ageBonus + verificationBonus + activityBonus;\n            // Cap at 5.0 max\n            return Math.min(ucr, 5.0);\n        };\n        return {\n            isInitialized: profileAccount.is_initialized === 1,\n            owner: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(profileAccount.owner),\n            username: profileAccount.username,\n            bio: profileAccount.bio,\n            profileImage: profileAccount.profile_image,\n            coverImage: profileAccount.cover_image,\n            createdAt: Number(profileAccount.created_at) * 1000,\n            followersCount: Number(profileAccount.followers_count),\n            followingCount: Number(profileAccount.following_count),\n            userCreditRating: calculateUCR(profileAccount),\n            postsCount: Number(profileAccount.posts_count),\n            lastPostTimestamp: Number(profileAccount.last_post_timestamp) * 1000,\n            dailyPostCount: Number(profileAccount.daily_post_count),\n            isVerified: profileAccount.is_verified === 1\n        };\n    };\n    // Convert PostAccount to Post interface\n    const convertPostAccount = (postAccount)=>{\n        return {\n            isInitialized: postAccount.is_initialized === 1,\n            id: Number(postAccount.id),\n            author: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(postAccount.author),\n            content: postAccount.content,\n            timestamp: Number(postAccount.timestamp) * 1000,\n            likes: Number(postAccount.likes),\n            comments: Number(postAccount.comments),\n            mirrors: Number(postAccount.mirrors),\n            images: postAccount.images,\n            rating: postAccount.rating,\n            inKillZone: postAccount.in_kill_zone === 1\n        };\n    };\n    // Create user profile - REAL IMPLEMENTATION\n    const createProfile = async (username, bio, profileImage, coverImage)=>{\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83D\\uDD0D Running pre-flight checks...\");\n            const balance = await checkSOLBalance();\n            console.log(\"\\uD83D\\uDCB0 SOL Balance: \".concat(balance));\n            if (balance < 0.1) {\n                throw new Error(\"Insufficient SOL balance: \".concat(balance, \". You need at least 0.1 SOL for transaction fees and account creation.\"));\n            }\n            const programExists = await checkProgramExists();\n            console.log(\"\\uD83D\\uDCCB Program exists: \".concat(programExists));\n            if (!programExists) {\n                throw new Error(\"Program not found at address: \".concat(PROGRAM_ID.toString(), \". Make sure the program is deployed on \").concat(_config__WEBPACK_IMPORTED_MODULE_3__.config.solana.network, \".\"));\n            }\n            console.log(\"✅ Pre-flight checks passed\");\n            const profilePDA = await getProfilePDA(publicKey, username);\n            console.log(\"\\uD83D\\uDCCD Profile PDA: \".concat(profilePDA.toString()));\n            const instructionData = new CreateProfileInstruction({\n                username,\n                bio,\n                profile_image: profileImage,\n                cover_image: coverImage\n            });\n            const createProfileVariant = Buffer.from([\n                0\n            ]);\n            const serializedData = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.serialize)(createProfileSchema, instructionData);\n            const fullInstructionData = Buffer.concat([\n                createProfileVariant,\n                Buffer.from(serializedData)\n            ]);\n            const instruction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: profilePDA,\n                        isSigner: false,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.SystemProgram.programId,\n                        isSigner: false,\n                        isWritable: false\n                    }\n                ],\n                programId: PROGRAM_ID,\n                data: fullInstructionData\n            });\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction().add(instruction);\n            const { blockhash } = await connection.getLatestBlockhash(\"processed\");\n            transaction.recentBlockhash = blockhash;\n            transaction.feePayer = publicKey;\n            const simulation = await connection.simulateTransaction(transaction);\n            if (simulation.value.err) {\n                throw new Error(\"Transaction simulation failed: \".concat(JSON.stringify(simulation.value.err)));\n            }\n            const signature = await sendTransaction(transaction, connection, {\n                skipPreflight: false,\n                preflightCommitment: \"processed\",\n                maxRetries: 3\n            });\n            await connection.confirmTransaction({\n                signature,\n                blockhash,\n                lastValidBlockHeight: (await connection.getLatestBlockhash()).lastValidBlockHeight\n            }, \"processed\");\n            // Invalidate cache after profile creation\n            clearProfileCache(publicKey.toString());\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.success(\"Profile created successfully!\");\n            return signature;\n        } catch (error) {\n            console.error(\"❌ Profile creation error:\", error);\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Transaction failed: \".concat(error.message || \"Unknown error\"));\n            throw error;\n        }\n    };\n    // Production-ready profile detection with localStorage caching - Improved for multiple users\n    const getProfile = async (userPublicKey)=>{\n        const cacheKey = userPublicKey.toString();\n        try {\n            // 1. Check localStorage cache first (fastest)\n            const cachedProfile = getProfileFromLocalStorage(cacheKey);\n            if (cachedProfile !== null) {\n                // Also update memory cache\n                profileCache.set(cacheKey, cachedProfile);\n                setTimeout(()=>profileCache.delete(cacheKey), CACHE_DURATION);\n                return cachedProfile;\n            }\n            // 2. Check memory cache\n            if (profileCache.has(cacheKey)) {\n                const cached = profileCache.get(cacheKey);\n                return cached !== null && cached !== void 0 ? cached : null;\n            }\n            // 3. Fetch from blockchain (slowest)\n            console.log(\"\\uD83D\\uDD0D Fetching profile from blockchain for: \".concat(userPublicKey.toString().slice(0, 8), \"...\"));\n            const accounts = await connection.getProgramAccounts(PROGRAM_ID);\n            console.log(\"\\uD83D\\uDCCA Found \".concat(accounts.length, \" program accounts to scan for profiles\"));\n            let profilesFound = 0;\n            // Scan through accounts to find user's profile\n            for (const { account, pubkey } of accounts){\n                try {\n                    if (account.data.length === 0) continue;\n                    // Try manual parsing first\n                    const profileAccount = manualParseProfile(account.data);\n                    if (!profileAccount) continue;\n                    profilesFound++;\n                    const accountOwner = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(profileAccount.owner);\n                    // Check if this profile belongs to the user we're looking for\n                    if (profileAccount.is_initialized === 1 && accountOwner.equals(userPublicKey)) {\n                        console.log('\\uD83C\\uDFAF FOUND PROFILE! Username: \"'.concat(profileAccount.username, '\" for ').concat(userPublicKey.toString().slice(0, 8)));\n                        console.log('\\uD83D\\uDCF8 Profile Image URL: \"'.concat(profileAccount.profile_image, '\"'));\n                        console.log('\\uD83D\\uDDBC️ Cover Image URL: \"'.concat(profileAccount.cover_image, '\"'));\n                        console.log(\"\\uD83D\\uDCCA Profile Data:\", {\n                            username: profileAccount.username,\n                            bio: profileAccount.bio,\n                            profileImage: profileAccount.profile_image,\n                            coverImage: profileAccount.cover_image,\n                            postsCount: Number(profileAccount.posts_count),\n                            followersCount: Number(profileAccount.followers_count),\n                            isVerified: profileAccount.is_verified === 1\n                        });\n                        const profile = convertProfileAccount(profileAccount);\n                        // Cache in both memory and localStorage\n                        profileCache.set(cacheKey, profile);\n                        setTimeout(()=>profileCache.delete(cacheKey), CACHE_DURATION);\n                        saveProfileToLocalStorage(cacheKey, profile);\n                        return profile;\n                    }\n                } catch (error) {\n                    continue;\n                }\n            }\n            console.log(\"\\uD83D\\uDCCA Scanned \".concat(profilesFound, \" profiles, no match found for user: \").concat(userPublicKey.toString().slice(0, 8)));\n            // No profile found - cache null result to avoid repeated scans\n            profileCache.set(cacheKey, null);\n            setTimeout(()=>profileCache.delete(cacheKey), CACHE_DURATION);\n            saveProfileToLocalStorage(cacheKey, null);\n            return null;\n        } catch (error) {\n            console.error(\"Error fetching profile for \".concat(userPublicKey.toString().slice(0, 8), \":\"), error);\n            return null;\n        }\n    };\n    // Get profile by username (for specific lookups)\n    const getProfileByUsername = async (userPublicKey, username)=>{\n        try {\n            const profilePDA = await getProfilePDA(userPublicKey, username);\n            const accountInfo = await connection.getAccountInfo(profilePDA);\n            if (!accountInfo || !accountInfo.data || accountInfo.data.length === 0) {\n                return null;\n            }\n            // Now try manual parsing\n            const profileAccount = manualParseProfile(accountInfo.data);\n            if (profileAccount) {\n                console.log(\"✅ Successfully manually parsed profile:\", {\n                    username: profileAccount.username,\n                    bio: profileAccount.bio,\n                    isInitialized: profileAccount.is_initialized === 1,\n                    owner: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(profileAccount.owner).toString(),\n                    profileImage: profileAccount.profile_image,\n                    coverImage: profileAccount.cover_image,\n                    postsCount: Number(profileAccount.posts_count)\n                });\n                return convertProfileAccount(profileAccount);\n            } else {\n                console.log(\"❌ Manual parsing failed\");\n                return null;\n            }\n        } catch (error) {\n            return null;\n        }\n    };\n    // Get posts - REAL IMPLEMENTATION with manual parsing and caching\n    const getPosts = async ()=>{\n        try {\n            // Check cache first\n            if (postsCache && Date.now() - postsCache.timestamp < POSTS_CACHE_DURATION) {\n                console.log(\"⚡ Using cached posts\");\n                return postsCache.posts;\n            }\n            console.log(\"\\uD83D\\uDD0D Fetching posts from blockchain...\");\n            const accounts = await connection.getProgramAccounts(PROGRAM_ID);\n            const posts = [];\n            console.log(\"\\uD83D\\uDCCA Scanning \".concat(accounts.length, \" program accounts for posts...\"));\n            for (const { account, pubkey } of accounts){\n                try {\n                    if (account.data.length === 0) continue;\n                    // Try manual post parsing first\n                    const postAccount = manualParsePost(account.data);\n                    if (postAccount && postAccount.is_initialized === 1 && postAccount.content) {\n                        const post = convertPostAccount(postAccount);\n                        posts.push(post);\n                        console.log('\\uD83D\\uDCDD Found post: \"'.concat(post.content.substring(0, 50), '...\" by ').concat(post.author.toString()));\n                    }\n                } catch (error) {\n                    continue;\n                }\n            }\n            posts.sort((a, b)=>b.timestamp - a.timestamp);\n            console.log(\"✅ Loaded \".concat(posts.length, \" posts from blockchain\"));\n            // Cache the results\n            postsCache = {\n                posts,\n                timestamp: Date.now()\n            };\n            return posts;\n        } catch (error) {\n            console.error(\"Error fetching posts:\", error);\n            return [];\n        }\n    };\n    // Create post - REAL IMPLEMENTATION\n    const createPost = async function(content) {\n        let images = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83D\\uDD0D Creating post with content:\", content);\n            // Check SOL balance\n            const balance = await checkSOLBalance();\n            if (balance < 0.05) {\n                throw new Error(\"Insufficient SOL balance: \".concat(balance, \". You need at least 0.05 SOL for transaction fees and account creation.\"));\n            }\n            // Get user's profile PDA - we need this for the instruction\n            const userProfile = await getProfile(publicKey);\n            if (!userProfile) {\n                throw new Error(\"You must create a profile before posting\");\n            }\n            // Get user's current post count to generate the correct post ID\n            // The Rust contract increments posts_count first, then uses that as the post ID\n            const postId = userProfile.postsCount + 1;\n            const postPDA = await getPostPDA(publicKey, postId);\n            console.log(\"\\uD83D\\uDCCD Post PDA: \".concat(postPDA.toString(), \" for post ID: \").concat(postId));\n            // Generate a new keypair for the post account\n            // The Rust contract uses invoke with system_instruction::create_account\n            // This means the post account MUST be a keypair that signs the transaction\n            const postKeypair = _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Keypair.generate();\n            console.log(\"\\uD83D\\uDCCD Post Account: \".concat(postKeypair.publicKey.toString()));\n            // Get profile PDA for the user (we need the actual username)\n            // Try to find the profile account among all program accounts\n            const accounts = await connection.getProgramAccounts(PROGRAM_ID);\n            let userProfilePDA = null;\n            for (const { account, pubkey } of accounts){\n                try {\n                    const profileAccount = manualParseProfile(account.data);\n                    if (profileAccount && profileAccount.is_initialized === 1 && new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(profileAccount.owner).equals(publicKey)) {\n                        userProfilePDA = pubkey;\n                        console.log(\"\\uD83D\\uDCCD User Profile PDA: \".concat(userProfilePDA.toString()));\n                        break;\n                    }\n                } catch (error) {\n                    continue;\n                }\n            }\n            if (!userProfilePDA) {\n                throw new Error(\"Could not find your profile PDA. Please refresh and try again.\");\n            }\n            const instructionData = new CreatePostInstruction({\n                content,\n                images\n            });\n            const createPostVariant = Buffer.from([\n                2\n            ]) // CreatePost enum index\n            ;\n            const serializedData = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.serialize)(createPostSchema, instructionData);\n            const fullInstructionData = Buffer.concat([\n                createPostVariant,\n                Buffer.from(serializedData)\n            ]);\n            console.log(\"\\uD83D\\uDD22 Instruction data length: \".concat(fullInstructionData.length, \" bytes\"));\n            const instruction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: postKeypair.publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: userProfilePDA,\n                        isSigner: false,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.SystemProgram.programId,\n                        isSigner: false,\n                        isWritable: false\n                    }\n                ],\n                programId: PROGRAM_ID,\n                data: fullInstructionData\n            });\n            console.log(\"\\uD83D\\uDCDD Transaction instruction created\");\n            console.log(\"\\uD83D\\uDD11 Keys:\", instruction.keys.map((k)=>({\n                    pubkey: k.pubkey.toString(),\n                    isSigner: k.isSigner,\n                    isWritable: k.isWritable\n                })));\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction().add(instruction);\n            const { blockhash } = await connection.getLatestBlockhash(\"processed\");\n            transaction.recentBlockhash = blockhash;\n            transaction.feePayer = publicKey;\n            console.log(\"\\uD83D\\uDE80 Sending transaction...\");\n            // Sign transaction before simulation\n            transaction.partialSign(postKeypair);\n            // Simulate transaction \n            const simulation = await connection.simulateTransaction(transaction);\n            console.log(\"\\uD83C\\uDFAF Transaction simulation:\", simulation);\n            if (simulation.value.err) {\n                throw new Error(\"Transaction simulation failed: \".concat(JSON.stringify(simulation.value.err)));\n            }\n            // Send transaction with post keypair as additional signer\n            const signature = await sendTransaction(transaction, connection, {\n                skipPreflight: false,\n                preflightCommitment: \"processed\",\n                maxRetries: 3,\n                signers: [\n                    postKeypair\n                ]\n            });\n            console.log(\"\\uD83D\\uDCCB Transaction signature: \".concat(signature));\n            await connection.confirmTransaction({\n                signature,\n                blockhash,\n                lastValidBlockHeight: (await connection.getLatestBlockhash()).lastValidBlockHeight\n            }, \"processed\");\n            // Invalidate cache after post creation (profile post count changed)\n            clearProfileCache(publicKey.toString());\n            console.log(\"✅ Post created successfully!\");\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.success(\"Post created successfully!\");\n            return signature;\n        } catch (error) {\n            var _error_message, _error_message1;\n            console.error(\"❌ Post creation error:\", error);\n            if ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"insufficient funds\")) {\n                const balance = await checkSOLBalance();\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Insufficient SOL: \".concat(balance.toFixed(4), \" SOL. Need at least 0.05 SOL for fees.\"));\n            } else if ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes(\"simulation failed\")) {\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Transaction would fail: Check account setup and balance\");\n                console.error(\"Simulation error details:\", error.message);\n            } else {\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Failed to create post: \".concat(error.message || \"Unknown error\"));\n            }\n            throw error;\n        }\n    };\n    // Like post - REAL IMPLEMENTATION - Fixed to find actual post accounts\n    const likePost = async (postId, postAuthor)=>{\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83D\\uDD0D Attempting to like post ID \".concat(postId, \" by author \").concat(postAuthor.toString().slice(0, 8), \"...\"));\n            // Check SOL balance first\n            const balance = await checkSOLBalance();\n            console.log(\"\\uD83D\\uDCB0 Current SOL balance: \".concat(balance));\n            if (balance < 0.01) {\n                throw new Error(\"Insufficient SOL balance: \".concat(balance, \". Need at least 0.01 SOL for transaction fees.\"));\n            }\n            // Find the actual post account by scanning all program accounts\n            // Since posts are stored at random keypairs, not PDAs, we need to find the right one\n            console.log(\"\\uD83D\\uDD0D Searching for post ID \".concat(postId, \" by author \").concat(postAuthor.toString().slice(0, 8), \"...\"));\n            const accounts = await connection.getProgramAccounts(PROGRAM_ID);\n            let postAccountAddress = null;\n            let postAccount = null;\n            for (const { account, pubkey } of accounts){\n                try {\n                    const parsedPost = manualParsePost(account.data);\n                    if (parsedPost && parsedPost.is_initialized === 1 && Number(parsedPost.id) === postId && new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(parsedPost.author).equals(postAuthor)) {\n                        postAccountAddress = pubkey;\n                        postAccount = parsedPost;\n                        console.log(\"\\uD83C\\uDFAF Found post ID \".concat(postId, \" at address: \").concat(pubkey.toString()));\n                        break;\n                    }\n                } catch (error) {\n                    continue;\n                }\n            }\n            if (!postAccountAddress || !postAccount) {\n                throw new Error(\"Post ID \".concat(postId, \" by author \").concat(postAuthor.toString().slice(0, 8), \" not found on blockchain\"));\n            }\n            console.log('\\uD83D\\uDCDD Post data verified: \"'.concat(postAccount.content.slice(0, 30), '...\" with ').concat(Number(postAccount.likes), \" likes\"));\n            const instructionData = new LikePostInstruction({\n                post_id: BigInt(postId)\n            });\n            const likePostVariant = Buffer.from([\n                3\n            ]) // LikePost instruction variant\n            ;\n            const serializedData = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.serialize)(likePostSchema, instructionData);\n            const fullInstructionData = Buffer.concat([\n                likePostVariant,\n                Buffer.from(serializedData)\n            ]);\n            console.log(\"\\uD83D\\uDD22 Instruction data: variant [3], serialized length: \".concat(serializedData.length, \", total: \").concat(fullInstructionData.length, \" bytes\"));\n            const instruction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: publicKey,\n                        isSigner: true,\n                        isWritable: false\n                    },\n                    {\n                        pubkey: postAccountAddress,\n                        isSigner: false,\n                        isWritable: true\n                    }\n                ],\n                programId: PROGRAM_ID,\n                data: fullInstructionData\n            });\n            console.log(\"\\uD83D\\uDD11 Transaction accounts:\");\n            console.log(\"  User (liker): \".concat(publicKey.toString(), \" (signer, readonly)\"));\n            console.log(\"  Post: \".concat(postAccountAddress.toString(), \" (not signer, writable)\"));\n            console.log(\"  Program: \".concat(PROGRAM_ID.toString()));\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction().add(instruction);\n            const { blockhash } = await connection.getLatestBlockhash(\"processed\");\n            transaction.recentBlockhash = blockhash;\n            transaction.feePayer = publicKey;\n            // Simulate transaction before sending\n            console.log(\"\\uD83C\\uDFAF Simulating transaction...\");\n            const simulation = await connection.simulateTransaction(transaction);\n            console.log(\"\\uD83D\\uDCCA Simulation result:\", simulation);\n            if (simulation.value.err) {\n                throw new Error(\"Transaction simulation failed: \".concat(JSON.stringify(simulation.value.err)));\n            }\n            console.log(\"✅ Transaction simulation successful\");\n            console.log(\"\\uD83D\\uDE80 Sending transaction...\");\n            const signature = await sendTransaction(transaction, connection, {\n                skipPreflight: false,\n                preflightCommitment: \"processed\",\n                maxRetries: 3\n            });\n            console.log(\"\\uD83D\\uDCCB Transaction sent with signature: \".concat(signature));\n            console.log(\"⏳ Confirming transaction...\");\n            await connection.confirmTransaction({\n                signature,\n                blockhash,\n                lastValidBlockHeight: (await connection.getLatestBlockhash()).lastValidBlockHeight\n            }, \"processed\");\n            console.log(\"✅ Transaction confirmed! Post liked successfully!\");\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.success(\"Post liked!\");\n            return signature;\n        } catch (error) {\n            var _error_message, _error_message1, _error_message2;\n            console.error(\"❌ Like post error:\", error);\n            // More specific error messages\n            if ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"insufficient funds\")) {\n                const balance = await checkSOLBalance();\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Insufficient SOL: \".concat(balance.toFixed(4), \" SOL. Need at least 0.01 SOL for fees.\"));\n            } else if ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes(\"simulation failed\")) {\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Transaction would fail: Check post exists and wallet has permission\");\n                console.error(\"Simulation error details:\", error.message);\n            } else if ((_error_message2 = error.message) === null || _error_message2 === void 0 ? void 0 : _error_message2.includes(\"not found on blockchain\")) {\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Post not found on blockchain\");\n            } else {\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Failed to like post: \".concat(error.message || \"Unknown error\"));\n            }\n            throw error;\n        }\n    };\n    // Check specific profile PDA - for debugging profile detection issues\n    const checkProfileAtPDA = async (pdaAddress)=>{\n        try {\n            console.log(\"\\uD83D\\uDD0D Checking specific PDA: \".concat(pdaAddress));\n            const pda = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(pdaAddress);\n            const accountInfo = await connection.getAccountInfo(pda);\n            if (!accountInfo) {\n                console.log(\"❌ No account found at PDA: \".concat(pdaAddress));\n                return;\n            }\n            console.log(\"✅ Account exists! Owner: \".concat(accountInfo.owner.toString(), \", Size: \").concat(accountInfo.data.length, \" bytes\"));\n            // Inspect raw data\n            console.log(\"\\uD83D\\uDD0D Raw data (first 100 bytes):\", Array.from(accountInfo.data.slice(0, 100)));\n            if (accountInfo.owner.equals(PROGRAM_ID)) {\n                console.log(\"✅ Account is owned by our program\");\n                try {\n                    // Try manual parsing to understand the structure\n                    let offset = 0;\n                    const is_initialized = accountInfo.data[offset];\n                    offset += 1;\n                    console.log(\"\\uD83D\\uDCCA is_initialized: \".concat(is_initialized));\n                    const owner = accountInfo.data.slice(offset, offset + 32);\n                    offset += 32;\n                    console.log(\"\\uD83D\\uDCCA owner: \".concat(new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(owner).toString()));\n                    // Try to read the username length (Borsh string format: 4 bytes length + string)\n                    const usernameLength = accountInfo.data.readUInt32LE(offset);\n                    offset += 4;\n                    console.log(\"\\uD83D\\uDCCA username length: \".concat(usernameLength));\n                    if (usernameLength > 0 && usernameLength < 100) {\n                        const username = accountInfo.data.slice(offset, offset + usernameLength).toString(\"utf8\");\n                        console.log('\\uD83D\\uDCCA username: \"'.concat(username, '\"'));\n                    }\n                    // Now try manual parsing\n                    const profileAccount = manualParseProfile(accountInfo.data);\n                    if (profileAccount) {\n                        console.log(\"✅ Successfully manually parsed profile:\", {\n                            username: profileAccount.username,\n                            bio: profileAccount.bio,\n                            isInitialized: profileAccount.is_initialized === 1,\n                            owner: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(profileAccount.owner).toString(),\n                            profileImage: profileAccount.profile_image,\n                            coverImage: profileAccount.cover_image,\n                            postsCount: Number(profileAccount.posts_count)\n                        });\n                    } else {\n                        console.log(\"❌ Manual parsing failed\");\n                    }\n                    // Also try Borsh for comparison\n                    try {\n                        const profileAccount = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.deserialize)(profileAccountSchema, ProfileAccount, accountInfo.data);\n                        console.log(\"✅ Borsh deserialization also worked:\", {\n                            username: profileAccount.username,\n                            bio: profileAccount.bio,\n                            isInitialized: profileAccount.is_initialized === 1,\n                            owner: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(profileAccount.owner).toString()\n                        });\n                    } catch (error) {\n                        console.log(\"❌ Borsh deserialization still fails:\", error);\n                    }\n                } catch (error) {\n                    console.log(\"❌ Error checking PDA:\", error);\n                }\n            } else {\n                console.log(\"❌ Account is owned by different program: \".concat(accountInfo.owner.toString()));\n            }\n        } catch (error) {\n            console.log(\"❌ Error checking PDA:\", error);\n        }\n    };\n    // Manual profile parser - bypasses Borsh deserialization issues\n    const manualParseProfile = (data)=>{\n        try {\n            // Basic validation - profiles should have a minimum size\n            if (data.length < 150) return null // Profiles need at least 150 bytes for basic structure\n            ;\n            let offset = 0;\n            // Parse each field manually\n            const is_initialized = data[offset];\n            if (is_initialized !== 1) return null // Must be initialized\n            ;\n            offset += 1;\n            const owner = data.slice(offset, offset + 32);\n            offset += 32;\n            // Validate we have enough data for username length\n            if (offset + 4 > data.length) return null;\n            // String fields (username, bio, profile_image, cover_image)\n            const usernameLength = data.readUInt32LE(offset);\n            offset += 4;\n            // Validate username length is reasonable\n            if (usernameLength > 100 || usernameLength === 0) return null;\n            if (offset + usernameLength > data.length) return null;\n            const username = data.slice(offset, offset + usernameLength).toString(\"utf8\");\n            offset += usernameLength;\n            // Validate we have enough data for bio length\n            if (offset + 4 > data.length) return null;\n            const bioLength = data.readUInt32LE(offset);\n            offset += 4;\n            // Validate bio length is reasonable\n            if (bioLength > 1000) return null;\n            if (offset + bioLength > data.length) return null;\n            const bio = data.slice(offset, offset + bioLength).toString(\"utf8\");\n            offset += bioLength;\n            // Validate we have enough data for profile image length\n            if (offset + 4 > data.length) return null;\n            const profileImageLength = data.readUInt32LE(offset);\n            offset += 4;\n            // Validate profile image length is reasonable\n            if (profileImageLength > 500) return null;\n            if (offset + profileImageLength > data.length) return null;\n            const profile_image = data.slice(offset, offset + profileImageLength).toString(\"utf8\");\n            offset += profileImageLength;\n            // Validate we have enough data for cover image length\n            if (offset + 4 > data.length) return null;\n            const coverImageLength = data.readUInt32LE(offset);\n            offset += 4;\n            // Validate cover image length is reasonable\n            if (coverImageLength > 500) return null;\n            if (offset + coverImageLength > data.length) return null;\n            const cover_image = data.slice(offset, offset + coverImageLength).toString(\"utf8\");\n            offset += coverImageLength;\n            // Validate we have enough data for all the u64 fields (8 bytes each * 6 fields = 48 bytes)\n            if (offset + 48 > data.length) return null;\n            // u64 fields\n            const created_at = data.readBigUInt64LE(offset);\n            offset += 8;\n            const followers_count = data.readBigUInt64LE(offset);\n            offset += 8;\n            const following_count = data.readBigUInt64LE(offset);\n            offset += 8;\n            // i64 field\n            const user_credit_rating = data.readBigInt64LE(offset);\n            offset += 8;\n            const posts_count = data.readBigUInt64LE(offset);\n            offset += 8;\n            const last_post_timestamp = data.readBigUInt64LE(offset);\n            offset += 8;\n            const daily_post_count = data.readBigUInt64LE(offset);\n            offset += 8;\n            // Validate we have enough data for the final u8 field\n            if (offset + 1 > data.length) return null;\n            const is_verified = data[offset];\n            offset += 1;\n            return new ProfileAccount({\n                is_initialized,\n                owner: new Uint8Array(owner),\n                username,\n                bio,\n                profile_image,\n                cover_image,\n                created_at,\n                followers_count,\n                following_count,\n                user_credit_rating,\n                posts_count,\n                last_post_timestamp,\n                daily_post_count,\n                is_verified\n            });\n        } catch (error) {\n            // Silent failure - not a profile account or invalid data\n            return null;\n        }\n    };\n    // Manual post parser - bypasses Borsh deserialization issues\n    const manualParsePost = (data)=>{\n        try {\n            // Quick validation: posts should have specific size and structure\n            if (data.length < 100) return null // Posts should be larger than profiles\n            ;\n            let offset = 0;\n            // Parse each field manually\n            const is_initialized = data[offset];\n            if (is_initialized !== 1) return null // Must be initialized\n            ;\n            offset += 1;\n            // Check if this looks like a post vs profile by examining the structure\n            // Posts start with: u8 (init), u64 (id), [32]u8 (author), string (content)\n            // Profiles start with: u8 (init), [32]u8 (owner), string (username)\n            const id = data.readBigUInt64LE(offset);\n            offset += 8;\n            const author = data.slice(offset, offset + 32);\n            offset += 32;\n            const contentLength = data.readUInt32LE(offset);\n            offset += 4;\n            // Validate content length is reasonable (not too large)\n            if (contentLength > 10000 || contentLength === 0) return null;\n            if (offset + contentLength > data.length) return null;\n            const content = data.slice(offset, offset + contentLength).toString(\"utf8\");\n            offset += contentLength;\n            // Ensure we have enough remaining data for the rest of the post structure\n            if (offset + 40 > data.length) return null // Need at least 40 more bytes for timestamps and counts\n            ;\n            const timestamp = data.readBigUInt64LE(offset);\n            offset += 8;\n            const likes = data.readBigUInt64LE(offset);\n            offset += 8;\n            const comments = data.readBigUInt64LE(offset);\n            offset += 8;\n            const mirrors = data.readBigUInt64LE(offset);\n            offset += 8;\n            // Parse images array length\n            if (offset + 4 > data.length) return null;\n            const imagesLength = data.readUInt32LE(offset);\n            offset += 4;\n            const images = [];\n            // Parse images array - each image is a length-prefixed string\n            for(let i = 0; i < imagesLength; i++){\n                if (offset + 4 > data.length) return null;\n                const imageLength = data.readUInt32LE(offset);\n                offset += 4;\n                if (offset + imageLength > data.length) return null;\n                const image = data.slice(offset, offset + imageLength).toString(\"utf8\");\n                offset += imageLength;\n                images.push(image);\n            }\n            // Ensure we have enough data for rating and kill zone\n            if (offset + 2 > data.length) return null;\n            const rating = data[offset];\n            offset += 1;\n            const in_kill_zone = data[offset];\n            offset += 1;\n            return new PostAccount({\n                is_initialized,\n                id,\n                author: new Uint8Array(author),\n                content,\n                timestamp,\n                likes,\n                comments,\n                mirrors,\n                images,\n                rating,\n                in_kill_zone\n            });\n        } catch (error) {\n            // Silent failure - not a post account\n            return null;\n        }\n    };\n    // Convert CommunityAccount to Community interface\n    const convertCommunityAccount = (communityAccount)=>{\n        return {\n            isInitialized: communityAccount.is_initialized === 1,\n            id: Number(communityAccount.id),\n            creator: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(communityAccount.creator),\n            name: communityAccount.name,\n            description: communityAccount.description,\n            avatar: communityAccount.avatar,\n            rules: communityAccount.rules,\n            memberCount: Number(communityAccount.member_count),\n            createdAt: Number(communityAccount.created_at) * 1000,\n            isPrivate: communityAccount.is_private === 1\n        };\n    };\n    // Create Community\n    const createCommunity = async function(name, description, avatar) {\n        let rules = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83C\\uDFD8️ Creating community:\", name);\n            const balance = await checkSOLBalance();\n            if (balance < 0.05) {\n                throw new Error(\"Insufficient SOL balance: \".concat(balance, \". Need at least 0.05 SOL.\"));\n            }\n            // Generate a keypair for the community account\n            const communityKeypair = _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Keypair.generate();\n            console.log(\"\\uD83D\\uDCCD Community Account: \".concat(communityKeypair.publicKey.toString()));\n            const instructionData = new CreateCommunityInstruction({\n                name,\n                description,\n                avatar,\n                rules\n            });\n            const createCommunityVariant = Buffer.from([\n                7\n            ]) // CreateCommunity enum index\n            ;\n            const serializedData = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.serialize)(createCommunitySchema, instructionData);\n            const fullInstructionData = Buffer.concat([\n                createCommunityVariant,\n                Buffer.from(serializedData)\n            ]);\n            const instruction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: communityKeypair.publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.SystemProgram.programId,\n                        isSigner: false,\n                        isWritable: false\n                    }\n                ],\n                programId: PROGRAM_ID,\n                data: fullInstructionData\n            });\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction().add(instruction);\n            const { blockhash } = await connection.getLatestBlockhash(\"processed\");\n            transaction.recentBlockhash = blockhash;\n            transaction.feePayer = publicKey;\n            // Sign with community keypair\n            transaction.partialSign(communityKeypair);\n            const signature = await sendTransaction(transaction, connection, {\n                skipPreflight: false,\n                preflightCommitment: \"processed\",\n                maxRetries: 3,\n                signers: [\n                    communityKeypair\n                ]\n            });\n            await connection.confirmTransaction({\n                signature,\n                blockhash,\n                lastValidBlockHeight: (await connection.getLatestBlockhash()).lastValidBlockHeight\n            }, \"processed\");\n            console.log(\"✅ Community created successfully!\");\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.success('Community \"'.concat(name, '\" created successfully!'));\n            return signature;\n        } catch (error) {\n            console.error(\"❌ Community creation error:\", error);\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Failed to create community: \".concat(error.message || \"Unknown error\"));\n            throw error;\n        }\n    };\n    // Follow Profile\n    const followProfile = async (profilePublicKey)=>{\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83D\\uDC65 Following profile:\", profilePublicKey.toString());\n            const instructionData = new FollowProfileInstruction({\n                profile_id: profilePublicKey\n            });\n            const followProfileVariant = Buffer.from([\n                5\n            ]) // FollowProfile enum index\n            ;\n            const serializedData = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.serialize)(followProfileSchema, instructionData);\n            const fullInstructionData = Buffer.concat([\n                followProfileVariant,\n                Buffer.from(serializedData)\n            ]);\n            const instruction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: publicKey,\n                        isSigner: true,\n                        isWritable: false\n                    },\n                    {\n                        pubkey: profilePublicKey,\n                        isSigner: false,\n                        isWritable: true\n                    }\n                ],\n                programId: PROGRAM_ID,\n                data: fullInstructionData\n            });\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction().add(instruction);\n            const signature = await sendTransaction(transaction, connection);\n            await connection.confirmTransaction(signature, \"processed\");\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.success(\"Profile followed!\");\n            return signature;\n        } catch (error) {\n            console.error(\"Follow error:\", error);\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Failed to follow profile\");\n            throw error;\n        }\n    };\n    // Unfollow Profile\n    const unfollowProfile = async (profilePublicKey)=>{\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83D\\uDC65 Unfollowing profile:\", profilePublicKey.toString());\n            const instructionData = new FollowProfileInstruction({\n                profile_id: profilePublicKey\n            });\n            const unfollowProfileVariant = Buffer.from([\n                6\n            ]) // UnfollowProfile enum index\n            ;\n            const serializedData = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.serialize)(followProfileSchema, instructionData);\n            const fullInstructionData = Buffer.concat([\n                unfollowProfileVariant,\n                Buffer.from(serializedData)\n            ]);\n            const instruction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: publicKey,\n                        isSigner: true,\n                        isWritable: false\n                    },\n                    {\n                        pubkey: profilePublicKey,\n                        isSigner: false,\n                        isWritable: true\n                    }\n                ],\n                programId: PROGRAM_ID,\n                data: fullInstructionData\n            });\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction().add(instruction);\n            const signature = await sendTransaction(transaction, connection);\n            await connection.confirmTransaction(signature, \"processed\");\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.success(\"Profile unfollowed!\");\n            return signature;\n        } catch (error) {\n            console.error(\"Unfollow error:\", error);\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Failed to unfollow profile\");\n            throw error;\n        }\n    };\n    // Update Profile\n    const updateProfile = async (username, bio, profileImage, coverImage)=>{\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83D\\uDD04 Updating profile:\", username);\n            const instructionData = new CreateProfileInstruction({\n                username,\n                bio,\n                profile_image: profileImage,\n                cover_image: coverImage\n            });\n            const updateProfileVariant = Buffer.from([\n                1\n            ]) // UpdateProfile enum index (same as CreateProfile)\n            ;\n            const serializedData = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.serialize)(createProfileSchema, instructionData);\n            const fullInstructionData = Buffer.concat([\n                updateProfileVariant,\n                Buffer.from(serializedData)\n            ]);\n            const instruction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    }\n                ],\n                programId: PROGRAM_ID,\n                data: fullInstructionData\n            });\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction().add(instruction);\n            const signature = await sendTransaction(transaction, connection);\n            await connection.confirmTransaction(signature, \"processed\");\n            console.log(\"✅ Profile updated successfully!\");\n            // Clear cache to force refresh\n            profileCache.delete(publicKey.toString());\n            return signature;\n        } catch (error) {\n            console.error(\"❌ Update profile error:\", error);\n            throw error;\n        }\n    };\n    // Utility function to preload profile on wallet connection\n    const preloadProfile = async ()=>{\n        if (!publicKey) return;\n        console.log(\"\\uD83D\\uDE80 Preloading profile on wallet connection...\");\n        try {\n            await getProfile(publicKey);\n        } catch (error) {\n            console.warn(\"Failed to preload profile:\", error);\n        }\n    };\n    return {\n        createProfile,\n        createPost,\n        likePost,\n        getProfile,\n        getProfileByUsername,\n        getPosts,\n        getProfilePDA,\n        getPostPDA,\n        checkProfileAtPDA,\n        preloadProfile,\n        clearProfileCache,\n        createCommunity,\n        followProfile,\n        unfollowProfile,\n        updateProfile\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZUJsb2Nrc1Byb2dyYW0udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUF1RTtBQUNtRDtBQUM1RTtBQUNQO0FBQ047QUFFakMseURBQXlEO0FBQ3pELE1BQU1ZLGFBQWEsSUFBSVYsc0RBQVNBLENBQUNTLDJDQUFNQSxDQUFDRSxNQUFNLENBQUNDLFNBQVM7QUFFeEQsb0VBQW9FO0FBQ3BFLE1BQU1DLGFBQWFDLGtCQUF5Qjs7QUFFNUMsK0NBQStDO1VBQzFDQzs7Ozs7Ozs7OztHQUFBQSx3QkFBQUE7O1VBYU9DOzs7Ozs7Ozs7R0FBQUEsZUFBQUE7QUFXWix3Q0FBd0M7QUFDeEMsTUFBTUM7SUFNSkMsWUFBWUMsTUFLWCxDQUFFO1FBQ0QsSUFBSSxDQUFDQyxRQUFRLEdBQUdELE9BQU9DLFFBQVE7UUFDL0IsSUFBSSxDQUFDQyxHQUFHLEdBQUdGLE9BQU9FLEdBQUc7UUFDckIsSUFBSSxDQUFDQyxhQUFhLEdBQUdILE9BQU9HLGFBQWE7UUFDekMsSUFBSSxDQUFDQyxXQUFXLEdBQUdKLE9BQU9JLFdBQVc7SUFDdkM7QUFDRjtBQUVBLHFDQUFxQztBQUNyQyxNQUFNQztJQUlKTixZQUFZQyxNQUdYLENBQUU7UUFDRCxJQUFJLENBQUNNLE9BQU8sR0FBR04sT0FBT00sT0FBTztRQUM3QixJQUFJLENBQUNDLE1BQU0sR0FBR1AsT0FBT08sTUFBTTtJQUM3QjtBQUNGO0FBRUEsbUNBQW1DO0FBQ25DLE1BQU1DO0lBR0pULFlBQVlDLE1BRVgsQ0FBRTtRQUNELElBQUksQ0FBQ1MsT0FBTyxHQUFHVCxPQUFPUyxPQUFPO0lBQy9CO0FBQ0Y7QUFFQSw2REFBNkQ7QUFDN0QsTUFBTUM7SUFnQkpYLFlBQVlDLE1BQVcsQ0FBRTtRQUN2QixJQUFJLENBQUNXLGNBQWMsR0FBR1gsT0FBT1csY0FBYztRQUMzQyxJQUFJLENBQUNDLEtBQUssR0FBR1osT0FBT1ksS0FBSztRQUN6QixJQUFJLENBQUNYLFFBQVEsR0FB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TUFBTUEsV0FBV2dGLGtCQUFrQixDQUFDSixXQUFXO1lBQy9DL0YsUUFBUUMsR0FBRyxDQUFDO1lBRVosK0JBQStCO1lBQy9CbEIsYUFBYTRCLE1BQU0sQ0FBQ1MsVUFBVVcsUUFBUTtZQUV0QyxPQUFPZ0U7UUFDVCxFQUFFLE9BQU81RixPQUFZO1lBQ25CSCxRQUFRRyxLQUFLLENBQUMsMkJBQTJCQTtZQUN6QyxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSwyREFBMkQ7SUFDM0QsTUFBTStLLGlCQUFpQjtRQUNyQixJQUFJLENBQUM5SixXQUFXO1FBRWhCcEIsUUFBUUMsR0FBRyxDQUFDO1FBQ1osSUFBSTtZQUNGLE1BQU1zRyxXQUFXbkY7UUFDbkIsRUFBRSxPQUFPakIsT0FBTztZQUNkSCxRQUFRSSxJQUFJLENBQUMsOEJBQThCRDtRQUM3QztJQUNGO0lBRUEsT0FBTztRQUNMb0U7UUFDQXlEO1FBQ0FZO1FBQ0FyQztRQUNBYztRQUNBRTtRQUNBakc7UUFDQU07UUFDQXNIO1FBQ0FnQztRQUNBeEs7UUFDQThKO1FBQ0FHO1FBQ0FHO1FBQ0FFO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ob29rcy91c2VCbG9ja3NQcm9ncmFtLnRzPzVlOGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlQ29ubmVjdGlvbiwgdXNlV2FsbGV0IH0gZnJvbSAnQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdCdcclxuaW1wb3J0IHsgUHVibGljS2V5LCBUcmFuc2FjdGlvbiwgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiwgU3lzdGVtUHJvZ3JhbSwgTEFNUE9SVFNfUEVSX1NPTCwgS2V5cGFpciB9IGZyb20gJ0Bzb2xhbmEvd2ViMy5qcydcclxuaW1wb3J0IHsgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSB9IGZyb20gJ2JvcnNoJ1xyXG5pbXBvcnQgeyB0b2FzdCB9IGZyb20gJ3JlYWN0LWhvdC10b2FzdCdcclxuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnQC9jb25maWcnXHJcblxyXG4vLyBZb3VyIGRlcGxveWVkIHByb2dyYW0gSUQgLSBjb25maWd1cmVkIGZyb20gZW52aXJvbm1lbnRcclxuY29uc3QgUFJPR1JBTV9JRCA9IG5ldyBQdWJsaWNLZXkoY29uZmlnLnNvbGFuYS5wcm9ncmFtSWQpXHJcblxyXG4vLyBBZGQgZGVidWcgbW9kZSBmb3IgdGVzdGluZyB3aXRob3V0IGFjdHVhbCBibG9ja2NoYWluIHRyYW5zYWN0aW9uc1xyXG5jb25zdCBERUJVR19NT0RFID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCdcclxuXHJcbi8vIEluc3RydWN0aW9uIGVudW0gbWF0Y2hpbmcgeW91ciBSdXN0IGNvbnRyYWN0XHJcbmVudW0gQ29udHJhY3RJbnN0cnVjdGlvbiB7XHJcbiAgQ3JlYXRlUHJvZmlsZSA9IDAsXHJcbiAgVXBkYXRlUHJvZmlsZSA9IDEsXHJcbiAgQ3JlYXRlUG9zdCA9IDIsXHJcbiAgTGlrZVBvc3QgPSAzLFxyXG4gIENvbW1lbnRPblBvc3QgPSA0LFxyXG4gIEZvbGxvd1Byb2ZpbGUgPSA1LFxyXG4gIFVuZm9sbG93UHJvZmlsZSA9IDYsXHJcbiAgQ3JlYXRlQ29tbXVuaXR5ID0gNyxcclxuICBKb2luQ29tbXVuaXR5ID0gOCxcclxufVxyXG5cclxuLy8gUG9zdFJhdGluZyBlbnVtIG1hdGNoaW5nIFJ1c3QgY29udHJhY3RcclxuZXhwb3J0IGVudW0gUG9zdFJhdGluZyB7XHJcbiAgTm9uZSA9IDAsXHJcbiAgQnJvbnplID0gMSxcclxuICBTaWx2ZXIgPSAyLFxyXG4gIEdvbGQgPSAzLFxyXG4gIFBsYXRpbnVtID0gNCxcclxuICBEaWFtb25kID0gNSxcclxuICBBY2UgPSA2LFxyXG4gIENvbnF1ZXJvciA9IDcsXHJcbn1cclxuXHJcbi8vIENyZWF0ZSBQcm9maWxlIGluc3RydWN0aW9uIGRhdGEgY2xhc3NcclxuY2xhc3MgQ3JlYXRlUHJvZmlsZUluc3RydWN0aW9uIHtcclxuICB1c2VybmFtZTogc3RyaW5nXHJcbiAgYmlvOiBzdHJpbmdcclxuICBwcm9maWxlX2ltYWdlOiBzdHJpbmdcclxuICBjb3Zlcl9pbWFnZTogc3RyaW5nXHJcblxyXG4gIGNvbnN0cnVjdG9yKGZpZWxkczoge1xyXG4gICAgdXNlcm5hbWU6IHN0cmluZ1xyXG4gICAgYmlvOiBzdHJpbmdcclxuICAgIHByb2ZpbGVfaW1hZ2U6IHN0cmluZ1xyXG4gICAgY292ZXJfaW1hZ2U6IHN0cmluZ1xyXG4gIH0pIHtcclxuICAgIHRoaXMudXNlcm5hbWUgPSBmaWVsZHMudXNlcm5hbWVcclxuICAgIHRoaXMuYmlvID0gZmllbGRzLmJpb1xyXG4gICAgdGhpcy5wcm9maWxlX2ltYWdlID0gZmllbGRzLnByb2ZpbGVfaW1hZ2VcclxuICAgIHRoaXMuY292ZXJfaW1hZ2UgPSBmaWVsZHMuY292ZXJfaW1hZ2VcclxuICB9XHJcbn1cclxuXHJcbi8vIENyZWF0ZSBQb3N0IGluc3RydWN0aW9uIGRhdGEgY2xhc3NcclxuY2xhc3MgQ3JlYXRlUG9zdEluc3RydWN0aW9uIHtcclxuICBjb250ZW50OiBzdHJpbmdcclxuICBpbWFnZXM6IHN0cmluZ1tdXHJcblxyXG4gIGNvbnN0cnVjdG9yKGZpZWxkczoge1xyXG4gICAgY29udGVudDogc3RyaW5nXHJcbiAgICBpbWFnZXM6IHN0cmluZ1tdXHJcbiAgfSkge1xyXG4gICAgdGhpcy5jb250ZW50ID0gZmllbGRzLmNvbnRlbnRcclxuICAgIHRoaXMuaW1hZ2VzID0gZmllbGRzLmltYWdlc1xyXG4gIH1cclxufVxyXG5cclxuLy8gTGlrZSBQb3N0IGluc3RydWN0aW9uIGRhdGEgY2xhc3NcclxuY2xhc3MgTGlrZVBvc3RJbnN0cnVjdGlvbiB7XHJcbiAgcG9zdF9pZDogYmlnaW50XHJcblxyXG4gIGNvbnN0cnVjdG9yKGZpZWxkczoge1xyXG4gICAgcG9zdF9pZDogYmlnaW50XHJcbiAgfSkge1xyXG4gICAgdGhpcy5wb3N0X2lkID0gZmllbGRzLnBvc3RfaWRcclxuICB9XHJcbn1cclxuXHJcbi8vIFByb2ZpbGUgc3RydWN0IGZvciBkZXNlcmlhbGl6YXRpb24gLSBtYXRjaGluZyBSdXN0IGV4YWN0bHlcclxuY2xhc3MgUHJvZmlsZUFjY291bnQge1xyXG4gIGlzX2luaXRpYWxpemVkOiBudW1iZXIgIC8vIHU4IGZyb20gUnVzdCBib29sXHJcbiAgb3duZXI6IFVpbnQ4QXJyYXlcclxuICB1c2VybmFtZTogc3RyaW5nXHJcbiAgYmlvOiBzdHJpbmdcclxuICBwcm9maWxlX2ltYWdlOiBzdHJpbmdcclxuICBjb3Zlcl9pbWFnZTogc3RyaW5nXHJcbiAgY3JlYXRlZF9hdDogYmlnaW50XHJcbiAgZm9sbG93ZXJzX2NvdW50OiBiaWdpbnRcclxuICBmb2xsb3dpbmdfY291bnQ6IGJpZ2ludFxyXG4gIHVzZXJfY3JlZGl0X3JhdGluZzogYmlnaW50XHJcbiAgcG9zdHNfY291bnQ6IGJpZ2ludFxyXG4gIGxhc3RfcG9zdF90aW1lc3RhbXA6IGJpZ2ludFxyXG4gIGRhaWx5X3Bvc3RfY291bnQ6IGJpZ2ludFxyXG4gIGlzX3ZlcmlmaWVkOiBudW1iZXIgIC8vIHU4IGZyb20gUnVzdCBib29sXHJcblxyXG4gIGNvbnN0cnVjdG9yKGZpZWxkczogYW55KSB7XHJcbiAgICB0aGlzLmlzX2luaXRpYWxpemVkID0gZmllbGRzLmlzX2luaXRpYWxpemVkXHJcbiAgICB0aGlzLm93bmVyID0gZmllbGRzLm93bmVyXHJcbiAgICB0aGlzLnVzZXJuYW1lID0gZmllbGRzLnVzZXJuYW1lXHJcbiAgICB0aGlzLmJpbyA9IGZpZWxkcy5iaW9cclxuICAgIHRoaXMucHJvZmlsZV9pbWFnZSA9IGZpZWxkcy5wcm9maWxlX2ltYWdlXHJcbiAgICB0aGlzLmNvdmVyX2ltYWdlID0gZmllbGRzLmNvdmVyX2ltYWdlXHJcbiAgICB0aGlzLmNyZWF0ZWRfYXQgPSBmaWVsZHMuY3JlYXRlZF9hdFxyXG4gICAgdGhpcy5mb2xsb3dlcnNfY291bnQgPSBmaWVsZHMuZm9sbG93ZXJzX2NvdW50XHJcbiAgICB0aGlzLmZvbGxvd2luZ19jb3VudCA9IGZpZWxkcy5mb2xsb3dpbmdfY291bnRcclxuICAgIHRoaXMudXNlcl9jcmVkaXRfcmF0aW5nID0gZmllbGRzLnVzZXJfY3JlZGl0X3JhdGluZ1xyXG4gICAgdGhpcy5wb3N0c19jb3VudCA9IGZpZWxkcy5wb3N0c19jb3VudFxyXG4gICAgdGhpcy5sYXN0X3Bvc3RfdGltZXN0YW1wID0gZmllbGRzLmxhc3RfcG9zdF90aW1lc3RhbXBcclxuICAgIHRoaXMuZGFpbHlfcG9zdF9jb3VudCA9IGZpZWxkcy5kYWlseV9wb3N0X2NvdW50XHJcbiAgICB0aGlzLmlzX3ZlcmlmaWVkID0gZmllbGRzLmlzX3ZlcmlmaWVkXHJcbiAgfVxyXG59XHJcblxyXG4vLyBQb3N0IHN0cnVjdCBmb3IgZGVzZXJpYWxpemF0aW9uIC0gbWF0Y2hpbmcgUnVzdCBleGFjdGx5XHJcbmNsYXNzIFBvc3RBY2NvdW50IHtcclxuICBpc19pbml0aWFsaXplZDogbnVtYmVyICAvLyB1OCBmcm9tIFJ1c3QgYm9vbFxyXG4gIGlkOiBiaWdpbnRcclxuICBhdXRob3I6IFVpbnQ4QXJyYXlcclxuICBjb250ZW50OiBzdHJpbmdcclxuICB0aW1lc3RhbXA6IGJpZ2ludFxyXG4gIGxpa2VzOiBiaWdpbnRcclxuICBjb21tZW50czogYmlnaW50XHJcbiAgbWlycm9yczogYmlnaW50XHJcbiAgaW1hZ2VzOiBzdHJpbmdbXVxyXG4gIHJhdGluZzogbnVtYmVyXHJcbiAgaW5fa2lsbF96b25lOiBudW1iZXIgIC8vIHU4IGZyb20gUnVzdCBib29sXHJcblxyXG4gIGNvbnN0cnVjdG9yKGZpZWxkczogYW55KSB7XHJcbiAgICB0aGlzLmlzX2luaXRpYWxpemVkID0gZmllbGRzLmlzX2luaXRpYWxpemVkXHJcbiAgICB0aGlzLmlkID0gZmllbGRzLmlkXHJcbiAgICB0aGlzLmF1dGhvciA9IGZpZWxkcy5hdXRob3JcclxuICAgIHRoaXMuY29udGVudCA9IGZpZWxkcy5jb250ZW50XHJcbiAgICB0aGlzLnRpbWVzdGFtcCA9IGZpZWxkcy50aW1lc3RhbXBcclxuICAgIHRoaXMubGlrZXMgPSBmaWVsZHMubGlrZXNcclxuICAgIHRoaXMuY29tbWVudHMgPSBmaWVsZHMuY29tbWVudHNcclxuICAgIHRoaXMubWlycm9ycyA9IGZpZWxkcy5taXJyb3JzXHJcbiAgICB0aGlzLmltYWdlcyA9IGZpZWxkcy5pbWFnZXNcclxuICAgIHRoaXMucmF0aW5nID0gZmllbGRzLnJhdGluZ1xyXG4gICAgdGhpcy5pbl9raWxsX3pvbmUgPSBmaWVsZHMuaW5fa2lsbF96b25lXHJcbiAgfVxyXG59XHJcblxyXG4vLyBCb3JzaCBzY2hlbWFzXHJcbmNvbnN0IGNyZWF0ZVByb2ZpbGVTY2hlbWEgPSBuZXcgTWFwKFtcclxuICBbQ3JlYXRlUHJvZmlsZUluc3RydWN0aW9uLCB7XHJcbiAgICBraW5kOiAnc3RydWN0JyxcclxuICAgIGZpZWxkczogW1xyXG4gICAgICBbJ3VzZXJuYW1lJywgJ3N0cmluZyddLFxyXG4gICAgICBbJ2JpbycsICdzdHJpbmcnXSxcclxuICAgICAgWydwcm9maWxlX2ltYWdlJywgJ3N0cmluZyddLFxyXG4gICAgICBbJ2NvdmVyX2ltYWdlJywgJ3N0cmluZyddLFxyXG4gICAgXSxcclxuICB9XSxcclxuXSlcclxuXHJcbmNvbnN0IGNyZWF0ZVBvc3RTY2hlbWEgPSBuZXcgTWFwKFtcclxuICBbQ3JlYXRlUG9zdEluc3RydWN0aW9uLCB7XHJcbiAgICBraW5kOiAnc3RydWN0JyxcclxuICAgIGZpZWxkczogW1xyXG4gICAgICBbJ2NvbnRlbnQnLCAnc3RyaW5nJ10sXHJcbiAgICAgIFsnaW1hZ2VzJywgWydzdHJpbmcnXV0sXHJcbiAgICBdLFxyXG4gIH1dLFxyXG5dKVxyXG5cclxuY29uc3QgbGlrZVBvc3RTY2hlbWEgPSBuZXcgTWFwKFtcclxuICBbTGlrZVBvc3RJbnN0cnVjdGlvbiwge1xyXG4gICAga2luZDogJ3N0cnVjdCcsXHJcbiAgICBmaWVsZHM6IFtcclxuICAgICAgWydwb3N0X2lkJywgJ3U2NCddLFxyXG4gICAgXSxcclxuICB9XSxcclxuXSlcclxuXHJcbmNvbnN0IHByb2ZpbGVBY2NvdW50U2NoZW1hID0gbmV3IE1hcChbXHJcbiAgW1Byb2ZpbGVBY2NvdW50LCB7XHJcbiAgICBraW5kOiAnc3RydWN0JyxcclxuICAgIGZpZWxkczogW1xyXG4gICAgICBbJ2lzX2luaXRpYWxpemVkJywgJ3U4J10sICAvLyBSdXN0IGJvb2wgaXMgc2VyaWFsaXplZCBhcyB1OFxyXG4gICAgICBbJ293bmVyJywgWzMyXV0sXHJcbiAgICAgIFsndXNlcm5hbWUnLCAnc3RyaW5nJ10sXHJcbiAgICAgIFsnYmlvJywgJ3N0cmluZyddLFxyXG4gICAgICBbJ3Byb2ZpbGVfaW1hZ2UnLCAnc3RyaW5nJ10sXHJcbiAgICAgIFsnY292ZXJfaW1hZ2UnLCAnc3RyaW5nJ10sXHJcbiAgICAgIFsnY3JlYXRlZF9hdCcsICd1NjQnXSxcclxuICAgICAgWydmb2xsb3dlcnNfY291bnQnLCAndTY0J10sXHJcbiAgICAgIFsnZm9sbG93aW5nX2NvdW50JywgJ3U2NCddLFxyXG4gICAgICBbJ3VzZXJfY3JlZGl0X3JhdGluZycsICdpNjQnXSxcclxuICAgICAgWydwb3N0c19jb3VudCcsICd1NjQnXSxcclxuICAgICAgWydsYXN0X3Bvc3RfdGltZXN0YW1wJywgJ3U2NCddLFxyXG4gICAgICBbJ2RhaWx5X3Bvc3RfY291bnQnLCAndTY0J10sXHJcbiAgICAgIFsnaXNfdmVyaWZpZWQnLCAndTgnXSwgIC8vIFJ1c3QgYm9vbCBpcyBzZXJpYWxpemVkIGFzIHU4XHJcbiAgICBdLFxyXG4gIH1dLFxyXG5dKVxyXG5cclxuY29uc3QgcG9zdEFjY291bnRTY2hlbWEgPSBuZXcgTWFwKFtcclxuICBbUG9zdEFjY291bnQsIHtcclxuICAgIGtpbmQ6ICdzdHJ1Y3QnLFxyXG4gICAgZmllbGRzOiBbXHJcbiAgICAgIFsnaXNfaW5pdGlhbGl6ZWQnLCAndTgnXSwgIC8vIFJ1c3QgYm9vbCBpcyBzZXJpYWxpemVkIGFzIHU4XHJcbiAgICAgIFsnaWQnLCAndTY0J10sXHJcbiAgICAgIFsnYXV0aG9yJywgWzMyXV0sXHJcbiAgICAgIFsnY29udGVudCcsICdzdHJpbmcnXSxcclxuICAgICAgWyd0aW1lc3RhbXAnLCAndTY0J10sXHJcbiAgICAgIFsnbGlrZXMnLCAndTY0J10sXHJcbiAgICAgIFsnY29tbWVudHMnLCAndTY0J10sXHJcbiAgICAgIFsnbWlycm9ycycsICd1NjQnXSxcclxuICAgICAgWydpbWFnZXMnLCBbJ3N0cmluZyddXSxcclxuICAgICAgWydyYXRpbmcnLCAndTgnXSxcclxuICAgICAgWydpbl9raWxsX3pvbmUnLCAndTgnXSwgIC8vIFJ1c3QgYm9vbCBpcyBzZXJpYWxpemVkIGFzIHU4XHJcbiAgICBdLFxyXG4gIH1dLFxyXG5dKVxyXG5cclxuLy8gQ29tbXVuaXR5L1N1YkJsb2NrIGludGVyZmFjZVxyXG5leHBvcnQgaW50ZXJmYWNlIENvbW11bml0eSB7XHJcbiAgaXNJbml0aWFsaXplZDogYm9vbGVhblxyXG4gIGlkOiBudW1iZXJcclxuICBjcmVhdG9yOiBQdWJsaWNLZXlcclxuICBuYW1lOiBzdHJpbmdcclxuICBkZXNjcmlwdGlvbjogc3RyaW5nXHJcbiAgYXZhdGFyOiBzdHJpbmdcclxuICBydWxlczogc3RyaW5nW11cclxuICBtZW1iZXJDb3VudDogbnVtYmVyXHJcbiAgY3JlYXRlZEF0OiBudW1iZXJcclxuICBpc1ByaXZhdGU6IGJvb2xlYW5cclxufVxyXG5cclxuLy8gQ29tbXVuaXR5IHN0cnVjdCBmb3IgZGVzZXJpYWxpemF0aW9uXHJcbmNsYXNzIENvbW11bml0eUFjY291bnQge1xyXG4gIGlzX2luaXRpYWxpemVkOiBudW1iZXJcclxuICBpZDogYmlnaW50XHJcbiAgY3JlYXRvcjogVWludDhBcnJheVxyXG4gIG5hbWU6IHN0cmluZ1xyXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmdcclxuICBhdmF0YXI6IHN0cmluZ1xyXG4gIHJ1bGVzOiBzdHJpbmdbXVxyXG4gIG1lbWJlcl9jb3VudDogYmlnaW50XHJcbiAgY3JlYXRlZF9hdDogYmlnaW50XHJcbiAgaXNfcHJpdmF0ZTogbnVtYmVyXHJcblxyXG4gIGNvbnN0cnVjdG9yKGZpZWxkczogYW55KSB7XHJcbiAgICB0aGlzLmlzX2luaXRpYWxpemVkID0gZmllbGRzLmlzX2luaXRpYWxpemVkXHJcbiAgICB0aGlzLmlkID0gZmllbGRzLmlkXHJcbiAgICB0aGlzLmNyZWF0b3IgPSBmaWVsZHMuY3JlYXRvclxyXG4gICAgdGhpcy5uYW1lID0gZmllbGRzLm5hbWVcclxuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBmaWVsZHMuZGVzY3JpcHRpb25cclxuICAgIHRoaXMuYXZhdGFyID0gZmllbGRzLmF2YXRhclxyXG4gICAgdGhpcy5ydWxlcyA9IGZpZWxkcy5ydWxlc1xyXG4gICAgdGhpcy5tZW1iZXJfY291bnQgPSBmaWVsZHMubWVtYmVyX2NvdW50XHJcbiAgICB0aGlzLmNyZWF0ZWRfYXQgPSBmaWVsZHMuY3JlYXRlZF9hdFxyXG4gICAgdGhpcy5pc19wcml2YXRlID0gZmllbGRzLmlzX3ByaXZhdGVcclxuICB9XHJcbn1cclxuXHJcbi8vIENyZWF0ZSBDb21tdW5pdHkgaW5zdHJ1Y3Rpb25cclxuY2xhc3MgQ3JlYXRlQ29tbXVuaXR5SW5zdHJ1Y3Rpb24ge1xyXG4gIG5hbWU6IHN0cmluZ1xyXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmdcclxuICBhdmF0YXI6IHN0cmluZ1xyXG4gIHJ1bGVzOiBzdHJpbmdbXVxyXG5cclxuICBjb25zdHJ1Y3RvcihmaWVsZHM6IHtcclxuICAgIG5hbWU6IHN0cmluZ1xyXG4gICAgZGVzY3JpcHRpb246IHN0cmluZ1xyXG4gICAgYXZhdGFyOiBzdHJpbmdcclxuICAgIHJ1bGVzOiBzdHJpbmdbXVxyXG4gIH0pIHtcclxuICAgIHRoaXMubmFtZSA9IGZpZWxkcy5uYW1lXHJcbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gZmllbGRzLmRlc2NyaXB0aW9uXHJcbiAgICB0aGlzLmF2YXRhciA9IGZpZWxkcy5hdmF0YXJcclxuICAgIHRoaXMucnVsZXMgPSBmaWVsZHMucnVsZXNcclxuICB9XHJcbn1cclxuXHJcbi8vIEZvbGxvdyBQcm9maWxlIGluc3RydWN0aW9uXHJcbmNsYXNzIEZvbGxvd1Byb2ZpbGVJbnN0cnVjdGlvbiB7XHJcbiAgcHJvZmlsZV9pZDogVWludDhBcnJheVxyXG5cclxuICBjb25zdHJ1Y3RvcihmaWVsZHM6IHtcclxuICAgIHByb2ZpbGVfaWQ6IFB1YmxpY0tleVxyXG4gIH0pIHtcclxuICAgIHRoaXMucHJvZmlsZV9pZCA9IGZpZWxkcy5wcm9maWxlX2lkLnRvQnVmZmVyKClcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IGNyZWF0ZUNvbW11bml0eVNjaGVtYSA9IG5ldyBNYXAoW1xyXG4gIFtDcmVhdGVDb21tdW5pdHlJbnN0cnVjdGlvbiwge1xyXG4gICAga2luZDogJ3N0cnVjdCcsXHJcbiAgICBmaWVsZHM6IFtcclxuICAgICAgWyduYW1lJywgJ3N0cmluZyddLFxyXG4gICAgICBbJ2Rlc2NyaXB0aW9uJywgJ3N0cmluZyddLFxyXG4gICAgICBbJ2F2YXRhcicsICdzdHJpbmcnXSxcclxuICAgICAgWydydWxlcycsIFsnc3RyaW5nJ11dLFxyXG4gICAgXSxcclxuICB9XSxcclxuXSlcclxuXHJcbmNvbnN0IGZvbGxvd1Byb2ZpbGVTY2hlbWEgPSBuZXcgTWFwKFtcclxuICBbRm9sbG93UHJvZmlsZUluc3RydWN0aW9uLCB7XHJcbiAgICBraW5kOiAnc3RydWN0JyxcclxuICAgIGZpZWxkczogW1xyXG4gICAgICBbJ3Byb2ZpbGVfaWQnLCBbMzJdXSxcclxuICAgIF0sXHJcbiAgfV0sXHJcbl0pXHJcblxyXG5jb25zdCBjb21tdW5pdHlBY2NvdW50U2NoZW1hID0gbmV3IE1hcChbXHJcbiAgW0NvbW11bml0eUFjY291bnQsIHtcclxuICAgIGtpbmQ6ICdzdHJ1Y3QnLFxyXG4gICAgZmllbGRzOiBbXHJcbiAgICAgIFsnaXNfaW5pdGlhbGl6ZWQnLCAndTgnXSxcclxuICAgICAgWydpZCcsICd1NjQnXSxcclxuICAgICAgWydjcmVhdG9yJywgWzMyXV0sXHJcbiAgICAgIFsnbmFtZScsICdzdHJpbmcnXSxcclxuICAgICAgWydkZXNjcmlwdGlvbicsICdzdHJpbmcnXSxcclxuICAgICAgWydhdmF0YXInLCAnc3RyaW5nJ10sXHJcbiAgICAgIFsncnVsZXMnLCBbJ3N0cmluZyddXSxcclxuICAgICAgWydtZW1iZXJfY291bnQnLCAndTY0J10sXHJcbiAgICAgIFsnY3JlYXRlZF9hdCcsICd1NjQnXSxcclxuICAgICAgWydpc19wcml2YXRlJywgJ3U4J10sXHJcbiAgICBdLFxyXG4gIH1dLFxyXG5dKVxyXG5cclxuLy8gUHJvZmlsZSBpbnRlcmZhY2VcclxuZXhwb3J0IGludGVyZmFjZSBQcm9maWxlIHtcclxuICBpc0luaXRpYWxpemVkOiBib29sZWFuXHJcbiAgb3duZXI6IFB1YmxpY0tleVxyXG4gIHVzZXJuYW1lOiBzdHJpbmdcclxuICBiaW86IHN0cmluZ1xyXG4gIHByb2ZpbGVJbWFnZTogc3RyaW5nXHJcbiAgY292ZXJJbWFnZTogc3RyaW5nXHJcbiAgY3JlYXRlZEF0OiBudW1iZXJcclxuICBmb2xsb3dlcnNDb3VudDogbnVtYmVyXHJcbiAgZm9sbG93aW5nQ291bnQ6IG51bWJlclxyXG4gIHVzZXJDcmVkaXRSYXRpbmc6IG51bWJlclxyXG4gIHBvc3RzQ291bnQ6IG51bWJlclxyXG4gIGxhc3RQb3N0VGltZXN0YW1wOiBudW1iZXJcclxuICBkYWlseVBvc3RDb3VudDogbnVtYmVyXHJcbiAgaXNWZXJpZmllZDogYm9vbGVhblxyXG59XHJcblxyXG4vLyBQb3N0IGludGVyZmFjZVxyXG5leHBvcnQgaW50ZXJmYWNlIFBvc3Qge1xyXG4gIGlzSW5pdGlhbGl6ZWQ6IGJvb2xlYW5cclxuICBpZDogbnVtYmVyXHJcbiAgYXV0aG9yOiBQdWJsaWNLZXlcclxuICBjb250ZW50OiBzdHJpbmdcclxuICB0aW1lc3RhbXA6IG51bWJlclxyXG4gIGxpa2VzOiBudW1iZXJcclxuICBjb21tZW50czogbnVtYmVyXHJcbiAgbWlycm9yczogbnVtYmVyXHJcbiAgaW1hZ2VzOiBzdHJpbmdbXVxyXG4gIHJhdGluZzogUG9zdFJhdGluZ1xyXG4gIGluS2lsbFpvbmU6IGJvb2xlYW5cclxufVxyXG5cclxuLy8gQ2FjaGUgZm9yIHByb2ZpbGUgbG9va3VwcyB0byBhdm9pZCByZXBlYXRlZCBibG9ja2NoYWluIGNhbGxzXHJcbmNvbnN0IHByb2ZpbGVDYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBQcm9maWxlIHwgbnVsbD4oKVxyXG5jb25zdCBDQUNIRV9EVVJBVElPTiA9IDYwMDAwIC8vIDEgbWludXRlIGZvciBtZW1vcnkgY2FjaGUgKGluY3JlYXNlZCBmcm9tIDMwIHNlY29uZHMpXHJcblxyXG4vLyBQb3N0cyBjYWNoZVxyXG5sZXQgcG9zdHNDYWNoZTogeyBwb3N0czogUG9zdFtdLCB0aW1lc3RhbXA6IG51bWJlciB9IHwgbnVsbCA9IG51bGxcclxuY29uc3QgUE9TVFNfQ0FDSEVfRFVSQVRJT04gPSAzMDAwMCAvLyAzMCBzZWNvbmRzIGZvciBwb3N0cyBjYWNoZSAoaW5jcmVhc2VkIGZyb20gMTAgc2Vjb25kcylcclxuXHJcbi8vIGxvY2FsU3RvcmFnZSBjYWNoZSBjb25maWd1cmF0aW9uIC0gVXBkYXRlZCB0byBzdXBwb3J0IG11bHRpcGxlIHByb2ZpbGVzXHJcbmNvbnN0IExPQ0FMU1RPUkFHRV9DQUNIRV9QUkVGSVggPSAnYmxvY2tzX3Byb2ZpbGVfJ1xyXG5jb25zdCBMT0NBTFNUT1JBR0VfQ0FDSEVfRFVSQVRJT04gPSAxMCAqIDYwICogMTAwMCAvLyAxMCBtaW51dGVzIGZvciBsb2NhbFN0b3JhZ2UgY2FjaGUgKGluY3JlYXNlZCBmcm9tIDUgbWludXRlcylcclxuXHJcbmludGVyZmFjZSBDYWNoZWRQcm9maWxlIHtcclxuICBwcm9maWxlOiBQcm9maWxlIHwgbnVsbFxyXG4gIHRpbWVzdGFtcDogbnVtYmVyXHJcbiAgd2FsbGV0QWRkcmVzczogc3RyaW5nXHJcbn1cclxuXHJcbi8vIGxvY2FsU3RvcmFnZSBjYWNoZSB1dGlsaXRpZXMgLSBVcGRhdGVkIHRvIHN1cHBvcnQgbXVsdGlwbGUgcHJvZmlsZXNcclxuY29uc3Qgc2F2ZVByb2ZpbGVUb0xvY2FsU3RvcmFnZSA9ICh3YWxsZXRBZGRyZXNzOiBzdHJpbmcsIHByb2ZpbGU6IFByb2ZpbGUgfCBudWxsKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGNhY2hlS2V5ID0gYCR7TE9DQUxTVE9SQUdFX0NBQ0hFX1BSRUZJWH0ke3dhbGxldEFkZHJlc3N9YFxyXG4gICAgY29uc3QgY2FjaGVEYXRhOiBDYWNoZWRQcm9maWxlID0ge1xyXG4gICAgICBwcm9maWxlLFxyXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgIHdhbGxldEFkZHJlc3NcclxuICAgIH1cclxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGNhY2hlS2V5LCBKU09OLnN0cmluZ2lmeShjYWNoZURhdGEpKVxyXG4gICAgY29uc29sZS5sb2coYPCfkr4gUHJvZmlsZSBjYWNoZWQgdG8gbG9jYWxTdG9yYWdlIGZvciAke3dhbGxldEFkZHJlc3Muc2xpY2UoMCwgOCl9YClcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gc2F2ZSBwcm9maWxlIHRvIGxvY2FsU3RvcmFnZTonLCBlcnJvcilcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IGdldFByb2ZpbGVGcm9tTG9jYWxTdG9yYWdlID0gKHdhbGxldEFkZHJlc3M6IHN0cmluZyk6IFByb2ZpbGUgfCBudWxsID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgY2FjaGVLZXkgPSBgJHtMT0NBTFNUT1JBR0VfQ0FDSEVfUFJFRklYfSR7d2FsbGV0QWRkcmVzc31gXHJcbiAgICBjb25zdCBjYWNoZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShjYWNoZUtleSlcclxuICAgIGlmICghY2FjaGVkKSByZXR1cm4gbnVsbFxyXG5cclxuICAgIGNvbnN0IGNhY2hlRGF0YTogQ2FjaGVkUHJvZmlsZSA9IEpTT04ucGFyc2UoY2FjaGVkKVxyXG4gICAgXHJcbiAgICAvLyBDaGVjayBpZiBjYWNoZSBpcyBleHBpcmVkXHJcbiAgICBpZiAoRGF0ZS5ub3coKSAtIGNhY2hlRGF0YS50aW1lc3RhbXAgPiBMT0NBTFNUT1JBR0VfQ0FDSEVfRFVSQVRJT04pIHtcclxuICAgICAgY29uc29sZS5sb2coYOKPsCBDYWNoZSBleHBpcmVkIGZvciAke3dhbGxldEFkZHJlc3Muc2xpY2UoMCwgOCl9LCBjbGVhcmluZ2ApXHJcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGNhY2hlS2V5KVxyXG4gICAgICByZXR1cm4gbnVsbFxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZyhg4pqhIFVzaW5nIGNhY2hlZCBwcm9maWxlIGZyb20gbG9jYWxTdG9yYWdlIGZvciAke3dhbGxldEFkZHJlc3Muc2xpY2UoMCwgOCl9YClcclxuICAgIHJldHVybiBjYWNoZURhdGEucHJvZmlsZVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byByZWFkIHByb2ZpbGUgZnJvbSBsb2NhbFN0b3JhZ2U6JywgZXJyb3IpXHJcbiAgICBjb25zdCBjYWNoZUtleSA9IGAke0xPQ0FMU1RPUkFHRV9DQUNIRV9QUkVGSVh9JHt3YWxsZXRBZGRyZXNzfWBcclxuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGNhY2hlS2V5KVxyXG4gICAgcmV0dXJuIG51bGxcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IGNsZWFyUHJvZmlsZUNhY2hlID0gKHdhbGxldEFkZHJlc3M/OiBzdHJpbmcpID0+IHtcclxuICAvLyBDbGVhciBtZW1vcnkgY2FjaGVcclxuICBpZiAod2FsbGV0QWRkcmVzcykge1xyXG4gICAgcHJvZmlsZUNhY2hlLmRlbGV0ZSh3YWxsZXRBZGRyZXNzKVxyXG4gICAgLy8gQ2xlYXIgbG9jYWxTdG9yYWdlIGNhY2hlIGZvciBzcGVjaWZpYyB1c2VyXHJcbiAgICBjb25zdCBjYWNoZUtleSA9IGAke0xPQ0FMU1RPUkFHRV9DQUNIRV9QUkVGSVh9JHt3YWxsZXRBZGRyZXNzfWBcclxuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGNhY2hlS2V5KVxyXG4gIH0gZWxzZSB7XHJcbiAgICBwcm9maWxlQ2FjaGUuY2xlYXIoKVxyXG4gICAgLy8gQ2xlYXIgYWxsIGxvY2FsU3RvcmFnZSBwcm9maWxlIGNhY2hlc1xyXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGxvY2FsU3RvcmFnZSlcclxuICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoTE9DQUxTVE9SQUdFX0NBQ0hFX1BSRUZJWCkpIHtcclxuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpXHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgfVxyXG4gIFxyXG4gIC8vIENsZWFyIHBvc3RzIGNhY2hlXHJcbiAgcG9zdHNDYWNoZSA9IG51bGxcclxuICBcclxuICBjb25zb2xlLmxvZygn8J+Xke+4jyBQcm9maWxlIGFuZCBwb3N0cyBjYWNoZSBjbGVhcmVkJylcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUJsb2Nrc1Byb2dyYW0oKSB7XHJcbiAgY29uc3QgeyBjb25uZWN0aW9uIH0gPSB1c2VDb25uZWN0aW9uKClcclxuICBjb25zdCB7IHB1YmxpY0tleSwgc2VuZFRyYW5zYWN0aW9uIH0gPSB1c2VXYWxsZXQoKVxyXG5cclxuICAvLyBHZXQgcHJvZmlsZSBQREFcclxuICBjb25zdCBnZXRQcm9maWxlUERBID0gYXN5bmMgKHVzZXJQdWJsaWNLZXk6IFB1YmxpY0tleSwgdXNlcm5hbWU6IHN0cmluZyk6IFByb21pc2U8UHVibGljS2V5PiA9PiB7XHJcbiAgICBjb25zdCBbcHJvZmlsZVBEQV0gPSBhd2FpdCBQdWJsaWNLZXkuZmluZFByb2dyYW1BZGRyZXNzKFxyXG4gICAgICBbdXNlclB1YmxpY0tleS50b0J1ZmZlcigpLCBCdWZmZXIuZnJvbSgncHJvZmlsZScpLCBCdWZmZXIuZnJvbSh1c2VybmFtZSldLFxyXG4gICAgICBQUk9HUkFNX0lEXHJcbiAgICApXHJcbiAgICByZXR1cm4gcHJvZmlsZVBEQVxyXG4gIH1cclxuXHJcbiAgLy8gR2V0IHBvc3QgUERBXHJcbiAgY29uc3QgZ2V0UG9zdFBEQSA9IGFzeW5jICh1c2VyUHVibGljS2V5OiBQdWJsaWNLZXksIHBvc3RJZDogbnVtYmVyKTogUHJvbWlzZTxQdWJsaWNLZXk+ID0+IHtcclxuICAgIGNvbnN0IFtwb3N0UERBXSA9IGF3YWl0IFB1YmxpY0tleS5maW5kUHJvZ3JhbUFkZHJlc3MoXHJcbiAgICAgIFt1c2VyUHVibGljS2V5LnRvQnVmZmVyKCksIEJ1ZmZlci5mcm9tKCdwb3N0JyksIEJ1ZmZlci5mcm9tKHBvc3RJZC50b1N0cmluZygpKV0sXHJcbiAgICAgIFBST0dSQU1fSURcclxuICAgIClcclxuICAgIHJldHVybiBwb3N0UERBXHJcbiAgfVxyXG5cclxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY2hlY2sgaWYgcHJvZ3JhbSBleGlzdHNcclxuICBjb25zdCBjaGVja1Byb2dyYW1FeGlzdHMgPSBhc3luYyAoKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBwcm9ncmFtSW5mbyA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0QWNjb3VudEluZm8oUFJPR1JBTV9JRClcclxuICAgICAgcmV0dXJuIHByb2dyYW1JbmZvICE9PSBudWxsICYmIHByb2dyYW1JbmZvLmV4ZWN1dGFibGVcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIHByb2dyYW0gZXhpc3RlbmNlOicsIGVycm9yKVxyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjaGVjayBTT0wgYmFsYW5jZVxyXG4gIGNvbnN0IGNoZWNrU09MQmFsYW5jZSA9IGFzeW5jICgpOiBQcm9taXNlPG51bWJlcj4gPT4ge1xyXG4gICAgaWYgKCFwdWJsaWNLZXkpIHJldHVybiAwXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBiYWxhbmNlID0gYXdhaXQgY29ubmVjdGlvbi5nZXRCYWxhbmNlKHB1YmxpY0tleSlcclxuICAgICAgcmV0dXJuIGJhbGFuY2UgLyBMQU1QT1JUU19QRVJfU09MXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBTT0wgYmFsYW5jZTonLCBlcnJvcilcclxuICAgICAgcmV0dXJuIDBcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIENvbnZlcnQgUHJvZmlsZUFjY291bnQgdG8gUHJvZmlsZSBpbnRlcmZhY2VcclxuICBjb25zdCBjb252ZXJ0UHJvZmlsZUFjY291bnQgPSAocHJvZmlsZUFjY291bnQ6IFByb2ZpbGVBY2NvdW50KTogUHJvZmlsZSA9PiB7XHJcbiAgICAvLyBDYWxjdWxhdGUgVUNSIGJhc2VkIG9uIGFjdGl2aXR5XHJcbiAgICBjb25zdCBjYWxjdWxhdGVVQ1IgPSAocHJvZmlsZTogUHJvZmlsZUFjY291bnQpID0+IHtcclxuICAgICAgY29uc3QgcG9zdHNDb3VudCA9IE51bWJlcihwcm9maWxlLnBvc3RzX2NvdW50KVxyXG4gICAgICBjb25zdCBmb2xsb3dlcnNDb3VudCA9IE51bWJlcihwcm9maWxlLmZvbGxvd2Vyc19jb3VudClcclxuICAgICAgY29uc3QgZm9sbG93aW5nQ291bnQgPSBOdW1iZXIocHJvZmlsZS5mb2xsb3dpbmdfY291bnQpXHJcbiAgICAgIFxyXG4gICAgICAvLyBCYXNlIFVDUiBjYWxjdWxhdGlvbiBhbGdvcml0aG1cclxuICAgICAgbGV0IHVjciA9IDEuMCAvLyBTdGFydCB3aXRoIGJhc2UgcmF0aW5nXHJcbiAgICAgIFxyXG4gICAgICAvLyBQb3N0cyBmYWN0b3IgKDAuMSBwb2ludHMgcGVyIHBvc3QsIG1heCAyLjAgcG9pbnRzKVxyXG4gICAgICBjb25zdCBwb3N0c1Njb3JlID0gTWF0aC5taW4ocG9zdHNDb3VudCAqIDAuMSwgMi4wKVxyXG4gICAgICBcclxuICAgICAgLy8gRm9sbG93ZXJzIGZhY3RvciAoMC4wNSBwb2ludHMgcGVyIGZvbGxvd2VyLCBtYXggMS41IHBvaW50cylcclxuICAgICAgY29uc3QgZm9sbG93ZXJzU2NvcmUgPSBNYXRoLm1pbihmb2xsb3dlcnNDb3VudCAqIDAuMDUsIDEuNSlcclxuICAgICAgXHJcbiAgICAgIC8vIEZvbGxvd2luZy9mb2xsb3dlcnMgcmF0aW8gKGhlYWx0aHkgcmF0aW8gPSBib251cylcclxuICAgICAgbGV0IHJhdGlvQm9udXMgPSAwXHJcbiAgICAgIGlmIChmb2xsb3dlcnNDb3VudCA+IDAgJiYgZm9sbG93aW5nQ291bnQgPiAwKSB7XHJcbiAgICAgICAgY29uc3QgcmF0aW8gPSBmb2xsb3dlcnNDb3VudCAvIGZvbGxvd2luZ0NvdW50XHJcbiAgICAgICAgaWYgKHJhdGlvID49IDAuNSAmJiByYXRpbyA8PSAyLjApIHsgLy8gSGVhbHRoeSByYXRpb1xyXG4gICAgICAgICAgcmF0aW9Cb251cyA9IDAuM1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gQWNjb3VudCBhZ2UgZmFjdG9yIChvbGRlciBhY2NvdW50cyBnZXQgYm9udXMpXHJcbiAgICAgIGNvbnN0IGFjY291bnRBZ2UgPSBEYXRlLm5vdygpIC0gTnVtYmVyKHByb2ZpbGUuY3JlYXRlZF9hdCkgKiAxMDAwXHJcbiAgICAgIGNvbnN0IGRheXNPbGQgPSBhY2NvdW50QWdlIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpXHJcbiAgICAgIGNvbnN0IGFnZUJvbnVzID0gTWF0aC5taW4oZGF5c09sZCAvIDMwICogMC4yLCAxLjApIC8vIDAuMiBwb2ludHMgcGVyIG1vbnRoLCBtYXggMS4wXHJcbiAgICAgIFxyXG4gICAgICAvLyBWZXJpZmljYXRpb24gYm9udXNcclxuICAgICAgY29uc3QgdmVyaWZpY2F0aW9uQm9udXMgPSBwcm9maWxlLmlzX3ZlcmlmaWVkID09PSAxID8gMC41IDogMFxyXG4gICAgICBcclxuICAgICAgLy8gQWN0aXZpdHkgZmFjdG9yIChwb3N0aW5nIHJlZ3VsYXJseSlcclxuICAgICAgY29uc3QgbGFzdFBvc3RBZ2UgPSBEYXRlLm5vdygpIC0gTnVtYmVyKHByb2ZpbGUubGFzdF9wb3N0X3RpbWVzdGFtcCkgKiAxMDAwXHJcbiAgICAgIGNvbnN0IGRheXNTaW5jZUxhc3RQb3N0ID0gbGFzdFBvc3RBZ2UgLyAoMTAwMCAqIDYwICogNjAgKiAyNClcclxuICAgICAgY29uc3QgYWN0aXZpdHlCb251cyA9IGRheXNTaW5jZUxhc3RQb3N0IDwgNyA/IDAuMyA6IGRheXNTaW5jZUxhc3RQb3N0IDwgMzAgPyAwLjEgOiAwXHJcbiAgICAgIFxyXG4gICAgICB1Y3IgPSB1Y3IgKyBwb3N0c1Njb3JlICsgZm9sbG93ZXJzU2NvcmUgKyByYXRpb0JvbnVzICsgYWdlQm9udXMgKyB2ZXJpZmljYXRpb25Cb251cyArIGFjdGl2aXR5Qm9udXNcclxuICAgICAgXHJcbiAgICAgIC8vIENhcCBhdCA1LjAgbWF4XHJcbiAgICAgIHJldHVybiBNYXRoLm1pbih1Y3IsIDUuMClcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBpc0luaXRpYWxpemVkOiBwcm9maWxlQWNjb3VudC5pc19pbml0aWFsaXplZCA9PT0gMSxcclxuICAgICAgb3duZXI6IG5ldyBQdWJsaWNLZXkocHJvZmlsZUFjY291bnQub3duZXIpLFxyXG4gICAgICB1c2VybmFtZTogcHJvZmlsZUFjY291bnQudXNlcm5hbWUsXHJcbiAgICAgIGJpbzogcHJvZmlsZUFjY291bnQuYmlvLFxyXG4gICAgICBwcm9maWxlSW1hZ2U6IHByb2ZpbGVBY2NvdW50LnByb2ZpbGVfaW1hZ2UsXHJcbiAgICAgIGNvdmVySW1hZ2U6IHByb2ZpbGVBY2NvdW50LmNvdmVyX2ltYWdlLFxyXG4gICAgICBjcmVhdGVkQXQ6IE51bWJlcihwcm9maWxlQWNjb3VudC5jcmVhdGVkX2F0KSAqIDEwMDAsIC8vIENvbnZlcnQgc2Vjb25kcyB0byBtaWxsaXNlY29uZHNcclxuICAgICAgZm9sbG93ZXJzQ291bnQ6IE51bWJlcihwcm9maWxlQWNjb3VudC5mb2xsb3dlcnNfY291bnQpLFxyXG4gICAgICBmb2xsb3dpbmdDb3VudDogTnVtYmVyKHByb2ZpbGVBY2NvdW50LmZvbGxvd2luZ19jb3VudCksXHJcbiAgICAgIHVzZXJDcmVkaXRSYXRpbmc6IGNhbGN1bGF0ZVVDUihwcm9maWxlQWNjb3VudCksIC8vIFVzZSBjYWxjdWxhdGVkIFVDUiBpbnN0ZWFkIG9mIHN0b3JlZCB2YWx1ZVxyXG4gICAgICBwb3N0c0NvdW50OiBOdW1iZXIocHJvZmlsZUFjY291bnQucG9zdHNfY291bnQpLFxyXG4gICAgICBsYXN0UG9zdFRpbWVzdGFtcDogTnVtYmVyKHByb2ZpbGVBY2NvdW50Lmxhc3RfcG9zdF90aW1lc3RhbXApICogMTAwMCwgLy8gQ29udmVydCBzZWNvbmRzIHRvIG1pbGxpc2Vjb25kc1xyXG4gICAgICBkYWlseVBvc3RDb3VudDogTnVtYmVyKHByb2ZpbGVBY2NvdW50LmRhaWx5X3Bvc3RfY291bnQpLFxyXG4gICAgICBpc1ZlcmlmaWVkOiBwcm9maWxlQWNjb3VudC5pc192ZXJpZmllZCA9PT0gMSxcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIENvbnZlcnQgUG9zdEFjY291bnQgdG8gUG9zdCBpbnRlcmZhY2VcclxuICBjb25zdCBjb252ZXJ0UG9zdEFjY291bnQgPSAocG9zdEFjY291bnQ6IFBvc3RBY2NvdW50KTogUG9zdCA9PiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBpc0luaXRpYWxpemVkOiBwb3N0QWNjb3VudC5pc19pbml0aWFsaXplZCA9PT0gMSxcclxuICAgICAgaWQ6IE51bWJlcihwb3N0QWNjb3VudC5pZCksXHJcbiAgICAgIGF1dGhvcjogbmV3IFB1YmxpY0tleShwb3N0QWNjb3VudC5hdXRob3IpLFxyXG4gICAgICBjb250ZW50OiBwb3N0QWNjb3VudC5jb250ZW50LFxyXG4gICAgICB0aW1lc3RhbXA6IE51bWJlcihwb3N0QWNjb3VudC50aW1lc3RhbXApICogMTAwMCwgLy8gQ29udmVydCBzZWNvbmRzIHRvIG1pbGxpc2Vjb25kc1xyXG4gICAgICBsaWtlczogTnVtYmVyKHBvc3RBY2NvdW50Lmxpa2VzKSxcclxuICAgICAgY29tbWVudHM6IE51bWJlcihwb3N0QWNjb3VudC5jb21tZW50cyksXHJcbiAgICAgIG1pcnJvcnM6IE51bWJlcihwb3N0QWNjb3VudC5taXJyb3JzKSxcclxuICAgICAgaW1hZ2VzOiBwb3N0QWNjb3VudC5pbWFnZXMsXHJcbiAgICAgIHJhdGluZzogcG9zdEFjY291bnQucmF0aW5nIGFzIFBvc3RSYXRpbmcsXHJcbiAgICAgIGluS2lsbFpvbmU6IHBvc3RBY2NvdW50LmluX2tpbGxfem9uZSA9PT0gMSxcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIENyZWF0ZSB1c2VyIHByb2ZpbGUgLSBSRUFMIElNUExFTUVOVEFUSU9OXHJcbiAgY29uc3QgY3JlYXRlUHJvZmlsZSA9IGFzeW5jIChcclxuICAgIHVzZXJuYW1lOiBzdHJpbmcsXHJcbiAgICBiaW86IHN0cmluZyxcclxuICAgIHByb2ZpbGVJbWFnZTogc3RyaW5nLFxyXG4gICAgY292ZXJJbWFnZTogc3RyaW5nXHJcbiAgKSA9PiB7XHJcbiAgICBpZiAoIXB1YmxpY0tleSkgdGhyb3cgbmV3IEVycm9yKCdXYWxsZXQgbm90IGNvbm5lY3RlZCcpXHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ/CflI0gUnVubmluZyBwcmUtZmxpZ2h0IGNoZWNrcy4uLicpXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBiYWxhbmNlID0gYXdhaXQgY2hlY2tTT0xCYWxhbmNlKClcclxuICAgICAgY29uc29sZS5sb2coYPCfkrAgU09MIEJhbGFuY2U6ICR7YmFsYW5jZX1gKVxyXG4gICAgICBpZiAoYmFsYW5jZSA8IDAuMSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdWZmaWNpZW50IFNPTCBiYWxhbmNlOiAke2JhbGFuY2V9LiBZb3UgbmVlZCBhdCBsZWFzdCAwLjEgU09MIGZvciB0cmFuc2FjdGlvbiBmZWVzIGFuZCBhY2NvdW50IGNyZWF0aW9uLmApXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHByb2dyYW1FeGlzdHMgPSBhd2FpdCBjaGVja1Byb2dyYW1FeGlzdHMoKVxyXG4gICAgICBjb25zb2xlLmxvZyhg8J+TiyBQcm9ncmFtIGV4aXN0czogJHtwcm9ncmFtRXhpc3RzfWApXHJcbiAgICAgIGlmICghcHJvZ3JhbUV4aXN0cykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvZ3JhbSBub3QgZm91bmQgYXQgYWRkcmVzczogJHtQUk9HUkFNX0lELnRvU3RyaW5nKCl9LiBNYWtlIHN1cmUgdGhlIHByb2dyYW0gaXMgZGVwbG95ZWQgb24gJHtjb25maWcuc29sYW5hLm5ldHdvcmt9LmApXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgUHJlLWZsaWdodCBjaGVja3MgcGFzc2VkJylcclxuXHJcbiAgICAgIGNvbnN0IHByb2ZpbGVQREEgPSBhd2FpdCBnZXRQcm9maWxlUERBKHB1YmxpY0tleSwgdXNlcm5hbWUpXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5ONIFByb2ZpbGUgUERBOiAke3Byb2ZpbGVQREEudG9TdHJpbmcoKX1gKVxyXG5cclxuICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0gbmV3IENyZWF0ZVByb2ZpbGVJbnN0cnVjdGlvbih7XHJcbiAgICAgICAgdXNlcm5hbWUsXHJcbiAgICAgICAgYmlvLFxyXG4gICAgICAgIHByb2ZpbGVfaW1hZ2U6IHByb2ZpbGVJbWFnZSxcclxuICAgICAgICBjb3Zlcl9pbWFnZTogY292ZXJJbWFnZSxcclxuICAgICAgfSlcclxuXHJcbiAgICAgIGNvbnN0IGNyZWF0ZVByb2ZpbGVWYXJpYW50ID0gQnVmZmVyLmZyb20oWzBdKVxyXG4gICAgICBjb25zdCBzZXJpYWxpemVkRGF0YSA9IHNlcmlhbGl6ZShjcmVhdGVQcm9maWxlU2NoZW1hLCBpbnN0cnVjdGlvbkRhdGEpXHJcbiAgICAgIGNvbnN0IGZ1bGxJbnN0cnVjdGlvbkRhdGEgPSBCdWZmZXIuY29uY2F0KFtjcmVhdGVQcm9maWxlVmFyaWFudCwgQnVmZmVyLmZyb20oc2VyaWFsaXplZERhdGEpXSlcclxuXHJcbiAgICAgIGNvbnN0IGluc3RydWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xyXG4gICAgICAgIGtleXM6IFtcclxuICAgICAgICAgIHsgcHVia2V5OiBwdWJsaWNLZXksIGlzU2lnbmVyOiB0cnVlLCBpc1dyaXRhYmxlOiB0cnVlIH0sXHJcbiAgICAgICAgICB7IHB1YmtleTogcHJvZmlsZVBEQSwgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiB0cnVlIH0sXHJcbiAgICAgICAgICB7IHB1YmtleTogU3lzdGVtUHJvZ3JhbS5wcm9ncmFtSWQsIGlzU2lnbmVyOiBmYWxzZSwgaXNXcml0YWJsZTogZmFsc2UgfSxcclxuICAgICAgICBdLFxyXG4gICAgICAgIHByb2dyYW1JZDogUFJPR1JBTV9JRCxcclxuICAgICAgICBkYXRhOiBmdWxsSW5zdHJ1Y3Rpb25EYXRhLFxyXG4gICAgICB9KVxyXG5cclxuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoaW5zdHJ1Y3Rpb24pXHJcbiAgICAgIGNvbnN0IHsgYmxvY2toYXNoIH0gPSBhd2FpdCBjb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCgncHJvY2Vzc2VkJylcclxuICAgICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoXHJcbiAgICAgIHRyYW5zYWN0aW9uLmZlZVBheWVyID0gcHVibGljS2V5XHJcblxyXG4gICAgICBjb25zdCBzaW11bGF0aW9uID0gYXdhaXQgY29ubmVjdGlvbi5zaW11bGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKVxyXG4gICAgICBpZiAoc2ltdWxhdGlvbi52YWx1ZS5lcnIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zYWN0aW9uIHNpbXVsYXRpb24gZmFpbGVkOiAke0pTT04uc3RyaW5naWZ5KHNpbXVsYXRpb24udmFsdWUuZXJyKX1gKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIGNvbm5lY3Rpb24sIHtcclxuICAgICAgICBza2lwUHJlZmxpZ2h0OiBmYWxzZSxcclxuICAgICAgICBwcmVmbGlnaHRDb21taXRtZW50OiAncHJvY2Vzc2VkJyxcclxuICAgICAgICBtYXhSZXRyaWVzOiAzLFxyXG4gICAgICB9KVxyXG5cclxuICAgICAgYXdhaXQgY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oe1xyXG4gICAgICAgIHNpZ25hdHVyZSxcclxuICAgICAgICBibG9ja2hhc2gsXHJcbiAgICAgICAgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IChhd2FpdCBjb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCgpKS5sYXN0VmFsaWRCbG9ja0hlaWdodCxcclxuICAgICAgfSwgJ3Byb2Nlc3NlZCcpXHJcbiAgICAgIFxyXG4gICAgICAvLyBJbnZhbGlkYXRlIGNhY2hlIGFmdGVyIHByb2ZpbGUgY3JlYXRpb25cclxuICAgICAgY2xlYXJQcm9maWxlQ2FjaGUocHVibGljS2V5LnRvU3RyaW5nKCkpXHJcbiAgICAgIFxyXG4gICAgICB0b2FzdC5zdWNjZXNzKCdQcm9maWxlIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5IScpXHJcbiAgICAgIHJldHVybiBzaWduYXR1cmVcclxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIFByb2ZpbGUgY3JlYXRpb24gZXJyb3I6JywgZXJyb3IpXHJcbiAgICAgIHRvYXN0LmVycm9yKGBUcmFuc2FjdGlvbiBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YClcclxuICAgICAgdGhyb3cgZXJyb3JcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFByb2R1Y3Rpb24tcmVhZHkgcHJvZmlsZSBkZXRlY3Rpb24gd2l0aCBsb2NhbFN0b3JhZ2UgY2FjaGluZyAtIEltcHJvdmVkIGZvciBtdWx0aXBsZSB1c2Vyc1xyXG4gIGNvbnN0IGdldFByb2ZpbGUgPSBhc3luYyAodXNlclB1YmxpY0tleTogUHVibGljS2V5KTogUHJvbWlzZTxQcm9maWxlIHwgbnVsbD4gPT4ge1xyXG4gICAgY29uc3QgY2FjaGVLZXkgPSB1c2VyUHVibGljS2V5LnRvU3RyaW5nKClcclxuICAgIFxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gMS4gQ2hlY2sgbG9jYWxTdG9yYWdlIGNhY2hlIGZpcnN0IChmYXN0ZXN0KVxyXG4gICAgICBjb25zdCBjYWNoZWRQcm9maWxlID0gZ2V0UHJvZmlsZUZyb21Mb2NhbFN0b3JhZ2UoY2FjaGVLZXkpXHJcbiAgICAgIGlmIChjYWNoZWRQcm9maWxlICE9PSBudWxsKSB7XHJcbiAgICAgICAgLy8gQWxzbyB1cGRhdGUgbWVtb3J5IGNhY2hlXHJcbiAgICAgICAgcHJvZmlsZUNhY2hlLnNldChjYWNoZUtleSwgY2FjaGVkUHJvZmlsZSlcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHByb2ZpbGVDYWNoZS5kZWxldGUoY2FjaGVLZXkpLCBDQUNIRV9EVVJBVElPTilcclxuICAgICAgICByZXR1cm4gY2FjaGVkUHJvZmlsZVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyAyLiBDaGVjayBtZW1vcnkgY2FjaGVcclxuICAgICAgaWYgKHByb2ZpbGVDYWNoZS5oYXMoY2FjaGVLZXkpKSB7XHJcbiAgICAgICAgY29uc3QgY2FjaGVkID0gcHJvZmlsZUNhY2hlLmdldChjYWNoZUtleSlcclxuICAgICAgICByZXR1cm4gY2FjaGVkID8/IG51bGxcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gMy4gRmV0Y2ggZnJvbSBibG9ja2NoYWluIChzbG93ZXN0KVxyXG4gICAgICBjb25zb2xlLmxvZyhg8J+UjSBGZXRjaGluZyBwcm9maWxlIGZyb20gYmxvY2tjaGFpbiBmb3I6ICR7dXNlclB1YmxpY0tleS50b1N0cmluZygpLnNsaWNlKDAsIDgpfS4uLmApXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0UHJvZ3JhbUFjY291bnRzKFBST0dSQU1fSUQpXHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZyhg8J+TiiBGb3VuZCAke2FjY291bnRzLmxlbmd0aH0gcHJvZ3JhbSBhY2NvdW50cyB0byBzY2FuIGZvciBwcm9maWxlc2ApXHJcblxyXG4gICAgICBsZXQgcHJvZmlsZXNGb3VuZCA9IDBcclxuICAgICAgXHJcbiAgICAgIC8vIFNjYW4gdGhyb3VnaCBhY2NvdW50cyB0byBmaW5kIHVzZXIncyBwcm9maWxlXHJcbiAgICAgIGZvciAoY29uc3QgeyBhY2NvdW50LCBwdWJrZXkgfSBvZiBhY2NvdW50cykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBpZiAoYWNjb3VudC5kYXRhLmxlbmd0aCA9PT0gMCkgY29udGludWVcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gVHJ5IG1hbnVhbCBwYXJzaW5nIGZpcnN0XHJcbiAgICAgICAgICBjb25zdCBwcm9maWxlQWNjb3VudCA9IG1hbnVhbFBhcnNlUHJvZmlsZShhY2NvdW50LmRhdGEpXHJcbiAgICAgICAgICBpZiAoIXByb2ZpbGVBY2NvdW50KSBjb250aW51ZVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBwcm9maWxlc0ZvdW5kKytcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY29uc3QgYWNjb3VudE93bmVyID0gbmV3IFB1YmxpY0tleShwcm9maWxlQWNjb3VudC5vd25lcilcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBwcm9maWxlIGJlbG9uZ3MgdG8gdGhlIHVzZXIgd2UncmUgbG9va2luZyBmb3JcclxuICAgICAgICAgIGlmIChwcm9maWxlQWNjb3VudC5pc19pbml0aWFsaXplZCA9PT0gMSAmJiBhY2NvdW50T3duZXIuZXF1YWxzKHVzZXJQdWJsaWNLZXkpKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn46vIEZPVU5EIFBST0ZJTEUhIFVzZXJuYW1lOiBcIiR7cHJvZmlsZUFjY291bnQudXNlcm5hbWV9XCIgZm9yICR7dXNlclB1YmxpY0tleS50b1N0cmluZygpLnNsaWNlKDAsIDgpfWApXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5O4IFByb2ZpbGUgSW1hZ2UgVVJMOiBcIiR7cHJvZmlsZUFjY291bnQucHJvZmlsZV9pbWFnZX1cImApXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5a877iPIENvdmVyIEltYWdlIFVSTDogXCIke3Byb2ZpbGVBY2NvdW50LmNvdmVyX2ltYWdlfVwiYClcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYPCfk4ogUHJvZmlsZSBEYXRhOmAsIHtcclxuICAgICAgICAgICAgICB1c2VybmFtZTogcHJvZmlsZUFjY291bnQudXNlcm5hbWUsXHJcbiAgICAgICAgICAgICAgYmlvOiBwcm9maWxlQWNjb3VudC5iaW8sXHJcbiAgICAgICAgICAgICAgcHJvZmlsZUltYWdlOiBwcm9maWxlQWNjb3VudC5wcm9maWxlX2ltYWdlLFxyXG4gICAgICAgICAgICAgIGNvdmVySW1hZ2U6IHByb2ZpbGVBY2NvdW50LmNvdmVyX2ltYWdlLFxyXG4gICAgICAgICAgICAgIHBvc3RzQ291bnQ6IE51bWJlcihwcm9maWxlQWNjb3VudC5wb3N0c19jb3VudCksXHJcbiAgICAgICAgICAgICAgZm9sbG93ZXJzQ291bnQ6IE51bWJlcihwcm9maWxlQWNjb3VudC5mb2xsb3dlcnNfY291bnQpLFxyXG4gICAgICAgICAgICAgIGlzVmVyaWZpZWQ6IHByb2ZpbGVBY2NvdW50LmlzX3ZlcmlmaWVkID09PSAxXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIGNvbnN0IHByb2ZpbGUgPSBjb252ZXJ0UHJvZmlsZUFjY291bnQocHJvZmlsZUFjY291bnQpXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBDYWNoZSBpbiBib3RoIG1lbW9yeSBhbmQgbG9jYWxTdG9yYWdlXHJcbiAgICAgICAgICAgIHByb2ZpbGVDYWNoZS5zZXQoY2FjaGVLZXksIHByb2ZpbGUpXHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcHJvZmlsZUNhY2hlLmRlbGV0ZShjYWNoZUtleSksIENBQ0hFX0RVUkFUSU9OKVxyXG4gICAgICAgICAgICBzYXZlUHJvZmlsZVRvTG9jYWxTdG9yYWdlKGNhY2hlS2V5LCBwcm9maWxlKVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcmV0dXJuIHByb2ZpbGVcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgLy8gTm90IGEgcHJvZmlsZSBhY2NvdW50IG9yIHBhcnNpbmcgZmFpbGVkLCBjb250aW51ZVxyXG4gICAgICAgICAgY29udGludWVcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OKIFNjYW5uZWQgJHtwcm9maWxlc0ZvdW5kfSBwcm9maWxlcywgbm8gbWF0Y2ggZm91bmQgZm9yIHVzZXI6ICR7dXNlclB1YmxpY0tleS50b1N0cmluZygpLnNsaWNlKDAsIDgpfWApXHJcblxyXG4gICAgICAvLyBObyBwcm9maWxlIGZvdW5kIC0gY2FjaGUgbnVsbCByZXN1bHQgdG8gYXZvaWQgcmVwZWF0ZWQgc2NhbnNcclxuICAgICAgcHJvZmlsZUNhY2hlLnNldChjYWNoZUtleSwgbnVsbClcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiBwcm9maWxlQ2FjaGUuZGVsZXRlKGNhY2hlS2V5KSwgQ0FDSEVfRFVSQVRJT04pXHJcbiAgICAgIHNhdmVQcm9maWxlVG9Mb2NhbFN0b3JhZ2UoY2FjaGVLZXksIG51bGwpXHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gbnVsbFxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgcHJvZmlsZSBmb3IgJHt1c2VyUHVibGljS2V5LnRvU3RyaW5nKCkuc2xpY2UoMCwgOCl9OmAsIGVycm9yKVxyXG4gICAgICByZXR1cm4gbnVsbFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gR2V0IHByb2ZpbGUgYnkgdXNlcm5hbWUgKGZvciBzcGVjaWZpYyBsb29rdXBzKVxyXG4gIGNvbnN0IGdldFByb2ZpbGVCeVVzZXJuYW1lID0gYXN5bmMgKHVzZXJQdWJsaWNLZXk6IFB1YmxpY0tleSwgdXNlcm5hbWU6IHN0cmluZyk6IFByb21pc2U8UHJvZmlsZSB8IG51bGw+ID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHByb2ZpbGVQREEgPSBhd2FpdCBnZXRQcm9maWxlUERBKHVzZXJQdWJsaWNLZXksIHVzZXJuYW1lKVxyXG4gICAgICBjb25zdCBhY2NvdW50SW5mbyA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0QWNjb3VudEluZm8ocHJvZmlsZVBEQSlcclxuICAgICAgXHJcbiAgICAgIGlmICghYWNjb3VudEluZm8gfHwgIWFjY291bnRJbmZvLmRhdGEgfHwgYWNjb3VudEluZm8uZGF0YS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gbnVsbFxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBOb3cgdHJ5IG1hbnVhbCBwYXJzaW5nXHJcbiAgICAgIGNvbnN0IHByb2ZpbGVBY2NvdW50ID0gbWFudWFsUGFyc2VQcm9maWxlKGFjY291bnRJbmZvLmRhdGEpXHJcbiAgICAgIGlmIChwcm9maWxlQWNjb3VudCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGDinIUgU3VjY2Vzc2Z1bGx5IG1hbnVhbGx5IHBhcnNlZCBwcm9maWxlOmAsIHtcclxuICAgICAgICAgIHVzZXJuYW1lOiBwcm9maWxlQWNjb3VudC51c2VybmFtZSxcclxuICAgICAgICAgIGJpbzogcHJvZmlsZUFjY291bnQuYmlvLFxyXG4gICAgICAgICAgaXNJbml0aWFsaXplZDogcHJvZmlsZUFjY291bnQuaXNfaW5pdGlhbGl6ZWQgPT09IDEsXHJcbiAgICAgICAgICBvd25lcjogbmV3IFB1YmxpY0tleShwcm9maWxlQWNjb3VudC5vd25lcikudG9TdHJpbmcoKSxcclxuICAgICAgICAgIHByb2ZpbGVJbWFnZTogcHJvZmlsZUFjY291bnQucHJvZmlsZV9pbWFnZSxcclxuICAgICAgICAgIGNvdmVySW1hZ2U6IHByb2ZpbGVBY2NvdW50LmNvdmVyX2ltYWdlLFxyXG4gICAgICAgICAgcG9zdHNDb3VudDogTnVtYmVyKHByb2ZpbGVBY2NvdW50LnBvc3RzX2NvdW50KVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRQcm9maWxlQWNjb3VudChwcm9maWxlQWNjb3VudClcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhg4p2MIE1hbnVhbCBwYXJzaW5nIGZhaWxlZGApXHJcbiAgICAgICAgcmV0dXJuIG51bGxcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgcmV0dXJuIG51bGxcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEdldCBwb3N0cyAtIFJFQUwgSU1QTEVNRU5UQVRJT04gd2l0aCBtYW51YWwgcGFyc2luZyBhbmQgY2FjaGluZ1xyXG4gIGNvbnN0IGdldFBvc3RzID0gYXN5bmMgKCk6IFByb21pc2U8UG9zdFtdPiA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBDaGVjayBjYWNoZSBmaXJzdFxyXG4gICAgICBpZiAocG9zdHNDYWNoZSAmJiBEYXRlLm5vdygpIC0gcG9zdHNDYWNoZS50aW1lc3RhbXAgPCBQT1NUU19DQUNIRV9EVVJBVElPTikge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCfimqEgVXNpbmcgY2FjaGVkIHBvc3RzJylcclxuICAgICAgICByZXR1cm4gcG9zdHNDYWNoZS5wb3N0c1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zb2xlLmxvZygn8J+UjSBGZXRjaGluZyBwb3N0cyBmcm9tIGJsb2NrY2hhaW4uLi4nKVxyXG4gICAgICBcclxuICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBjb25uZWN0aW9uLmdldFByb2dyYW1BY2NvdW50cyhQUk9HUkFNX0lEKVxyXG4gICAgICBjb25zdCBwb3N0czogUG9zdFtdID0gW11cclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OKIFNjYW5uaW5nICR7YWNjb3VudHMubGVuZ3RofSBwcm9ncmFtIGFjY291bnRzIGZvciBwb3N0cy4uLmApXHJcblxyXG4gICAgICBmb3IgKGNvbnN0IHsgYWNjb3VudCwgcHVia2V5IH0gb2YgYWNjb3VudHMpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgaWYgKGFjY291bnQuZGF0YS5sZW5ndGggPT09IDApIGNvbnRpbnVlXHJcblxyXG4gICAgICAgICAgLy8gVHJ5IG1hbnVhbCBwb3N0IHBhcnNpbmcgZmlyc3RcclxuICAgICAgICAgIGNvbnN0IHBvc3RBY2NvdW50ID0gbWFudWFsUGFyc2VQb3N0KGFjY291bnQuZGF0YSlcclxuICAgICAgICAgIGlmIChwb3N0QWNjb3VudCAmJiBwb3N0QWNjb3VudC5pc19pbml0aWFsaXplZCA9PT0gMSAmJiBwb3N0QWNjb3VudC5jb250ZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvc3QgPSBjb252ZXJ0UG9zdEFjY291bnQocG9zdEFjY291bnQpXHJcbiAgICAgICAgICAgIHBvc3RzLnB1c2gocG9zdClcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYPCfk50gRm91bmQgcG9zdDogXCIke3Bvc3QuY29udGVudC5zdWJzdHJpbmcoMCwgNTApfS4uLlwiIGJ5ICR7cG9zdC5hdXRob3IudG9TdHJpbmcoKX1gKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAvLyBOb3QgYSBwb3N0IGFjY291bnQgb3IgcGFyc2luZyBmYWlsZWQsIGNvbnRpbnVlXHJcbiAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcG9zdHMuc29ydCgoYSwgYikgPT4gYi50aW1lc3RhbXAgLSBhLnRpbWVzdGFtcClcclxuICAgICAgY29uc29sZS5sb2coYOKchSBMb2FkZWQgJHtwb3N0cy5sZW5ndGh9IHBvc3RzIGZyb20gYmxvY2tjaGFpbmApXHJcbiAgICAgIFxyXG4gICAgICAvLyBDYWNoZSB0aGUgcmVzdWx0c1xyXG4gICAgICBwb3N0c0NhY2hlID0geyBwb3N0cywgdGltZXN0YW1wOiBEYXRlLm5vdygpIH1cclxuICAgICAgXHJcbiAgICAgIHJldHVybiBwb3N0c1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcG9zdHM6JywgZXJyb3IpXHJcbiAgICAgIHJldHVybiBbXVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQ3JlYXRlIHBvc3QgLSBSRUFMIElNUExFTUVOVEFUSU9OXHJcbiAgY29uc3QgY3JlYXRlUG9zdCA9IGFzeW5jIChjb250ZW50OiBzdHJpbmcsIGltYWdlczogc3RyaW5nW10gPSBbXSkgPT4ge1xyXG4gICAgaWYgKCFwdWJsaWNLZXkpIHRocm93IG5ldyBFcnJvcignV2FsbGV0IG5vdCBjb25uZWN0ZWQnKVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SNIENyZWF0aW5nIHBvc3Qgd2l0aCBjb250ZW50OicsIGNvbnRlbnQpXHJcbiAgICAgIFxyXG4gICAgICAvLyBDaGVjayBTT0wgYmFsYW5jZVxyXG4gICAgICBjb25zdCBiYWxhbmNlID0gYXdhaXQgY2hlY2tTT0xCYWxhbmNlKClcclxuICAgICAgaWYgKGJhbGFuY2UgPCAwLjA1KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN1ZmZpY2llbnQgU09MIGJhbGFuY2U6ICR7YmFsYW5jZX0uIFlvdSBuZWVkIGF0IGxlYXN0IDAuMDUgU09MIGZvciB0cmFuc2FjdGlvbiBmZWVzIGFuZCBhY2NvdW50IGNyZWF0aW9uLmApXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEdldCB1c2VyJ3MgcHJvZmlsZSBQREEgLSB3ZSBuZWVkIHRoaXMgZm9yIHRoZSBpbnN0cnVjdGlvblxyXG4gICAgICBjb25zdCB1c2VyUHJvZmlsZSA9IGF3YWl0IGdldFByb2ZpbGUocHVibGljS2V5KVxyXG4gICAgICBpZiAoIXVzZXJQcm9maWxlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBjcmVhdGUgYSBwcm9maWxlIGJlZm9yZSBwb3N0aW5nJylcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gR2V0IHVzZXIncyBjdXJyZW50IHBvc3QgY291bnQgdG8gZ2VuZXJhdGUgdGhlIGNvcnJlY3QgcG9zdCBJRFxyXG4gICAgICAvLyBUaGUgUnVzdCBjb250cmFjdCBpbmNyZW1lbnRzIHBvc3RzX2NvdW50IGZpcnN0LCB0aGVuIHVzZXMgdGhhdCBhcyB0aGUgcG9zdCBJRFxyXG4gICAgICBjb25zdCBwb3N0SWQgPSB1c2VyUHJvZmlsZS5wb3N0c0NvdW50ICsgMVxyXG4gICAgICBjb25zdCBwb3N0UERBID0gYXdhaXQgZ2V0UG9zdFBEQShwdWJsaWNLZXksIHBvc3RJZClcclxuICAgICAgY29uc29sZS5sb2coYPCfk40gUG9zdCBQREE6ICR7cG9zdFBEQS50b1N0cmluZygpfSBmb3IgcG9zdCBJRDogJHtwb3N0SWR9YClcclxuXHJcbiAgICAgIC8vIEdlbmVyYXRlIGEgbmV3IGtleXBhaXIgZm9yIHRoZSBwb3N0IGFjY291bnRcclxuICAgICAgLy8gVGhlIFJ1c3QgY29udHJhY3QgdXNlcyBpbnZva2Ugd2l0aCBzeXN0ZW1faW5zdHJ1Y3Rpb246OmNyZWF0ZV9hY2NvdW50XHJcbiAgICAgIC8vIFRoaXMgbWVhbnMgdGhlIHBvc3QgYWNjb3VudCBNVVNUIGJlIGEga2V5cGFpciB0aGF0IHNpZ25zIHRoZSB0cmFuc2FjdGlvblxyXG4gICAgICBjb25zdCBwb3N0S2V5cGFpciA9IEtleXBhaXIuZ2VuZXJhdGUoKVxyXG4gICAgICBjb25zb2xlLmxvZyhg8J+TjSBQb3N0IEFjY291bnQ6ICR7cG9zdEtleXBhaXIucHVibGljS2V5LnRvU3RyaW5nKCl9YClcclxuXHJcbiAgICAgIC8vIEdldCBwcm9maWxlIFBEQSBmb3IgdGhlIHVzZXIgKHdlIG5lZWQgdGhlIGFjdHVhbCB1c2VybmFtZSlcclxuICAgICAgLy8gVHJ5IHRvIGZpbmQgdGhlIHByb2ZpbGUgYWNjb3VudCBhbW9uZyBhbGwgcHJvZ3JhbSBhY2NvdW50c1xyXG4gICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0UHJvZ3JhbUFjY291bnRzKFBST0dSQU1fSUQpXHJcbiAgICAgIGxldCB1c2VyUHJvZmlsZVBEQTogUHVibGljS2V5IHwgbnVsbCA9IG51bGxcclxuICAgICAgXHJcbiAgICAgIGZvciAoY29uc3QgeyBhY2NvdW50LCBwdWJrZXkgfSBvZiBhY2NvdW50cykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCBwcm9maWxlQWNjb3VudCA9IG1hbnVhbFBhcnNlUHJvZmlsZShhY2NvdW50LmRhdGEpXHJcbiAgICAgICAgICBpZiAocHJvZmlsZUFjY291bnQgJiYgXHJcbiAgICAgICAgICAgICAgcHJvZmlsZUFjY291bnQuaXNfaW5pdGlhbGl6ZWQgPT09IDEgJiYgXHJcbiAgICAgICAgICAgICAgbmV3IFB1YmxpY0tleShwcm9maWxlQWNjb3VudC5vd25lcikuZXF1YWxzKHB1YmxpY0tleSkpIHtcclxuICAgICAgICAgICAgdXNlclByb2ZpbGVQREEgPSBwdWJrZXlcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYPCfk40gVXNlciBQcm9maWxlIFBEQTogJHt1c2VyUHJvZmlsZVBEQS50b1N0cmluZygpfWApXHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXVzZXJQcm9maWxlUERBKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCB5b3VyIHByb2ZpbGUgUERBLiBQbGVhc2UgcmVmcmVzaCBhbmQgdHJ5IGFnYWluLicpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGluc3RydWN0aW9uRGF0YSA9IG5ldyBDcmVhdGVQb3N0SW5zdHJ1Y3Rpb24oe1xyXG4gICAgICAgIGNvbnRlbnQsXHJcbiAgICAgICAgaW1hZ2VzLFxyXG4gICAgICB9KVxyXG5cclxuICAgICAgY29uc3QgY3JlYXRlUG9zdFZhcmlhbnQgPSBCdWZmZXIuZnJvbShbMl0pIC8vIENyZWF0ZVBvc3QgZW51bSBpbmRleFxyXG4gICAgICBjb25zdCBzZXJpYWxpemVkRGF0YSA9IHNlcmlhbGl6ZShjcmVhdGVQb3N0U2NoZW1hLCBpbnN0cnVjdGlvbkRhdGEpXHJcbiAgICAgIGNvbnN0IGZ1bGxJbnN0cnVjdGlvbkRhdGEgPSBCdWZmZXIuY29uY2F0KFtjcmVhdGVQb3N0VmFyaWFudCwgQnVmZmVyLmZyb20oc2VyaWFsaXplZERhdGEpXSlcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SiIEluc3RydWN0aW9uIGRhdGEgbGVuZ3RoOiAke2Z1bGxJbnN0cnVjdGlvbkRhdGEubGVuZ3RofSBieXRlc2ApXHJcblxyXG4gICAgICBjb25zdCBpbnN0cnVjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcclxuICAgICAgICBrZXlzOiBbXHJcbiAgICAgICAgICB7IHB1YmtleTogcHVibGljS2V5LCBpc1NpZ25lcjogdHJ1ZSwgaXNXcml0YWJsZTogdHJ1ZSB9LCAvLyBVc2VyIGFjY291bnQgKHBheWVyKVxyXG4gICAgICAgICAgeyBwdWJrZXk6IHBvc3RLZXlwYWlyLnB1YmxpY0tleSwgaXNTaWduZXI6IHRydWUsIGlzV3JpdGFibGU6IHRydWUgfSwgLy8gUG9zdCBhY2NvdW50IChtdXN0IGJlIHNpZ25lcilcclxuICAgICAgICAgIHsgcHVia2V5OiB1c2VyUHJvZmlsZVBEQSwgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiB0cnVlIH0sIC8vIFVzZXIgcHJvZmlsZSAoZm9yIHBvc3QgY291bnQpXHJcbiAgICAgICAgICB7IHB1YmtleTogU3lzdGVtUHJvZ3JhbS5wcm9ncmFtSWQsIGlzU2lnbmVyOiBmYWxzZSwgaXNXcml0YWJsZTogZmFsc2UgfSwgLy8gU3lzdGVtIHByb2dyYW1cclxuICAgICAgICBdLFxyXG4gICAgICAgIHByb2dyYW1JZDogUFJPR1JBTV9JRCxcclxuICAgICAgICBkYXRhOiBmdWxsSW5zdHJ1Y3Rpb25EYXRhLFxyXG4gICAgICB9KVxyXG5cclxuICAgICAgY29uc29sZS5sb2coJ/Cfk50gVHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gY3JlYXRlZCcpXHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SRIEtleXM6JywgaW5zdHJ1Y3Rpb24ua2V5cy5tYXAoayA9PiAoe1xyXG4gICAgICAgIHB1YmtleTogay5wdWJrZXkudG9TdHJpbmcoKSxcclxuICAgICAgICBpc1NpZ25lcjogay5pc1NpZ25lcixcclxuICAgICAgICBpc1dyaXRhYmxlOiBrLmlzV3JpdGFibGVcclxuICAgICAgfSkpKVxyXG5cclxuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoaW5zdHJ1Y3Rpb24pXHJcbiAgICAgIGNvbnN0IHsgYmxvY2toYXNoIH0gPSBhd2FpdCBjb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCgncHJvY2Vzc2VkJylcclxuICAgICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoXHJcbiAgICAgIHRyYW5zYWN0aW9uLmZlZVBheWVyID0gcHVibGljS2V5XHJcblxyXG4gICAgICBjb25zb2xlLmxvZygn8J+agCBTZW5kaW5nIHRyYW5zYWN0aW9uLi4uJylcclxuICAgICAgXHJcbiAgICAgIC8vIFNpZ24gdHJhbnNhY3Rpb24gYmVmb3JlIHNpbXVsYXRpb25cclxuICAgICAgdHJhbnNhY3Rpb24ucGFydGlhbFNpZ24ocG9zdEtleXBhaXIpXHJcbiAgICAgIFxyXG4gICAgICAvLyBTaW11bGF0ZSB0cmFuc2FjdGlvbiBcclxuICAgICAgY29uc3Qgc2ltdWxhdGlvbiA9IGF3YWl0IGNvbm5lY3Rpb24uc2ltdWxhdGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbilcclxuICAgICAgY29uc29sZS5sb2coJ/Cfjq8gVHJhbnNhY3Rpb24gc2ltdWxhdGlvbjonLCBzaW11bGF0aW9uKVxyXG4gICAgICBcclxuICAgICAgaWYgKHNpbXVsYXRpb24udmFsdWUuZXJyKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiBzaW11bGF0aW9uIGZhaWxlZDogJHtKU09OLnN0cmluZ2lmeShzaW11bGF0aW9uLnZhbHVlLmVycil9YClcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU2VuZCB0cmFuc2FjdGlvbiB3aXRoIHBvc3Qga2V5cGFpciBhcyBhZGRpdGlvbmFsIHNpZ25lclxyXG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIGNvbm5lY3Rpb24sIHtcclxuICAgICAgICBza2lwUHJlZmxpZ2h0OiBmYWxzZSxcclxuICAgICAgICBwcmVmbGlnaHRDb21taXRtZW50OiAncHJvY2Vzc2VkJyxcclxuICAgICAgICBtYXhSZXRyaWVzOiAzLFxyXG4gICAgICAgIHNpZ25lcnM6IFtwb3N0S2V5cGFpcl0sIC8vIFBvc3Qga2V5cGFpciBtdXN0IHNpZ24gdGhlIHRyYW5zYWN0aW9uXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhg8J+TiyBUcmFuc2FjdGlvbiBzaWduYXR1cmU6ICR7c2lnbmF0dXJlfWApXHJcbiAgICAgIFxyXG4gICAgICBhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbih7XHJcbiAgICAgICAgc2lnbmF0dXJlLFxyXG4gICAgICAgIGJsb2NraGFzaCxcclxuICAgICAgICBsYXN0VmFsaWRCbG9ja0hlaWdodDogKGF3YWl0IGNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2toYXNoKCkpLmxhc3RWYWxpZEJsb2NrSGVpZ2h0LFxyXG4gICAgICB9LCAncHJvY2Vzc2VkJylcclxuXHJcbiAgICAgIC8vIEludmFsaWRhdGUgY2FjaGUgYWZ0ZXIgcG9zdCBjcmVhdGlvbiAocHJvZmlsZSBwb3N0IGNvdW50IGNoYW5nZWQpXHJcbiAgICAgIGNsZWFyUHJvZmlsZUNhY2hlKHB1YmxpY0tleS50b1N0cmluZygpKVxyXG5cclxuICAgICAgY29uc29sZS5sb2coJ+KchSBQb3N0IGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5IScpXHJcbiAgICAgIHRvYXN0LnN1Y2Nlc3MoJ1Bvc3QgY3JlYXRlZCBzdWNjZXNzZnVsbHkhJylcclxuICAgICAgcmV0dXJuIHNpZ25hdHVyZVxyXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgUG9zdCBjcmVhdGlvbiBlcnJvcjonLCBlcnJvcilcclxuICAgICAgXHJcbiAgICAgIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnaW5zdWZmaWNpZW50IGZ1bmRzJykpIHtcclxuICAgICAgICBjb25zdCBiYWxhbmNlID0gYXdhaXQgY2hlY2tTT0xCYWxhbmNlKClcclxuICAgICAgICB0b2FzdC5lcnJvcihgSW5zdWZmaWNpZW50IFNPTDogJHtiYWxhbmNlLnRvRml4ZWQoNCl9IFNPTC4gTmVlZCBhdCBsZWFzdCAwLjA1IFNPTCBmb3IgZmVlcy5gKVxyXG4gICAgICB9IGVsc2UgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdzaW11bGF0aW9uIGZhaWxlZCcpKSB7XHJcbiAgICAgICAgdG9hc3QuZXJyb3IoJ1RyYW5zYWN0aW9uIHdvdWxkIGZhaWw6IENoZWNrIGFjY291bnQgc2V0dXAgYW5kIGJhbGFuY2UnKVxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1NpbXVsYXRpb24gZXJyb3IgZGV0YWlsczonLCBlcnJvci5tZXNzYWdlKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRvYXN0LmVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIHBvc3Q6ICR7ZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YClcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgdGhyb3cgZXJyb3JcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIExpa2UgcG9zdCAtIFJFQUwgSU1QTEVNRU5UQVRJT04gLSBGaXhlZCB0byBmaW5kIGFjdHVhbCBwb3N0IGFjY291bnRzXHJcbiAgY29uc3QgbGlrZVBvc3QgPSBhc3luYyAocG9zdElkOiBudW1iZXIsIHBvc3RBdXRob3I6IFB1YmxpY0tleSkgPT4ge1xyXG4gICAgaWYgKCFwdWJsaWNLZXkpIHRocm93IG5ldyBFcnJvcignV2FsbGV0IG5vdCBjb25uZWN0ZWQnKVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIEF0dGVtcHRpbmcgdG8gbGlrZSBwb3N0IElEICR7cG9zdElkfSBieSBhdXRob3IgJHtwb3N0QXV0aG9yLnRvU3RyaW5nKCkuc2xpY2UoMCwgOCl9Li4uYClcclxuICAgICAgXHJcbiAgICAgIC8vIENoZWNrIFNPTCBiYWxhbmNlIGZpcnN0XHJcbiAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBjaGVja1NPTEJhbGFuY2UoKVxyXG4gICAgICBjb25zb2xlLmxvZyhg8J+SsCBDdXJyZW50IFNPTCBiYWxhbmNlOiAke2JhbGFuY2V9YClcclxuICAgICAgaWYgKGJhbGFuY2UgPCAwLjAxKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN1ZmZpY2llbnQgU09MIGJhbGFuY2U6ICR7YmFsYW5jZX0uIE5lZWQgYXQgbGVhc3QgMC4wMSBTT0wgZm9yIHRyYW5zYWN0aW9uIGZlZXMuYClcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRmluZCB0aGUgYWN0dWFsIHBvc3QgYWNjb3VudCBieSBzY2FubmluZyBhbGwgcHJvZ3JhbSBhY2NvdW50c1xyXG4gICAgICAvLyBTaW5jZSBwb3N0cyBhcmUgc3RvcmVkIGF0IHJhbmRvbSBrZXlwYWlycywgbm90IFBEQXMsIHdlIG5lZWQgdG8gZmluZCB0aGUgcmlnaHQgb25lXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIFNlYXJjaGluZyBmb3IgcG9zdCBJRCAke3Bvc3RJZH0gYnkgYXV0aG9yICR7cG9zdEF1dGhvci50b1N0cmluZygpLnNsaWNlKDAsIDgpfS4uLmApXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0UHJvZ3JhbUFjY291bnRzKFBST0dSQU1fSUQpXHJcbiAgICAgIGxldCBwb3N0QWNjb3VudEFkZHJlc3M6IFB1YmxpY0tleSB8IG51bGwgPSBudWxsXHJcbiAgICAgIGxldCBwb3N0QWNjb3VudDogUG9zdEFjY291bnQgfCBudWxsID0gbnVsbFxyXG4gICAgICBcclxuICAgICAgZm9yIChjb25zdCB7IGFjY291bnQsIHB1YmtleSB9IG9mIGFjY291bnRzKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IHBhcnNlZFBvc3QgPSBtYW51YWxQYXJzZVBvc3QoYWNjb3VudC5kYXRhKVxyXG4gICAgICAgICAgaWYgKHBhcnNlZFBvc3QgJiYgXHJcbiAgICAgICAgICAgICAgcGFyc2VkUG9zdC5pc19pbml0aWFsaXplZCA9PT0gMSAmJiBcclxuICAgICAgICAgICAgICBOdW1iZXIocGFyc2VkUG9zdC5pZCkgPT09IHBvc3RJZCAmJlxyXG4gICAgICAgICAgICAgIG5ldyBQdWJsaWNLZXkocGFyc2VkUG9zdC5hdXRob3IpLmVxdWFscyhwb3N0QXV0aG9yKSkge1xyXG4gICAgICAgICAgICBwb3N0QWNjb3VudEFkZHJlc3MgPSBwdWJrZXlcclxuICAgICAgICAgICAgcG9zdEFjY291bnQgPSBwYXJzZWRQb3N0XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn46vIEZvdW5kIHBvc3QgSUQgJHtwb3N0SWR9IGF0IGFkZHJlc3M6ICR7cHVia2V5LnRvU3RyaW5nKCl9YClcclxuICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgLy8gTm90IGEgcG9zdCBhY2NvdW50LCBjb250aW51ZVxyXG4gICAgICAgICAgY29udGludWVcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghcG9zdEFjY291bnRBZGRyZXNzIHx8ICFwb3N0QWNjb3VudCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9zdCBJRCAke3Bvc3RJZH0gYnkgYXV0aG9yICR7cG9zdEF1dGhvci50b1N0cmluZygpLnNsaWNlKDAsIDgpfSBub3QgZm91bmQgb24gYmxvY2tjaGFpbmApXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OdIFBvc3QgZGF0YSB2ZXJpZmllZDogXCIke3Bvc3RBY2NvdW50LmNvbnRlbnQuc2xpY2UoMCwgMzApfS4uLlwiIHdpdGggJHtOdW1iZXIocG9zdEFjY291bnQubGlrZXMpfSBsaWtlc2ApXHJcblxyXG4gICAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSBuZXcgTGlrZVBvc3RJbnN0cnVjdGlvbih7XHJcbiAgICAgICAgcG9zdF9pZDogQmlnSW50KHBvc3RJZCksXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBjb25zdCBsaWtlUG9zdFZhcmlhbnQgPSBCdWZmZXIuZnJvbShbM10pIC8vIExpa2VQb3N0IGluc3RydWN0aW9uIHZhcmlhbnRcclxuICAgICAgY29uc3Qgc2VyaWFsaXplZERhdGEgPSBzZXJpYWxpemUobGlrZVBvc3RTY2hlbWEsIGluc3RydWN0aW9uRGF0YSlcclxuICAgICAgY29uc3QgZnVsbEluc3RydWN0aW9uRGF0YSA9IEJ1ZmZlci5jb25jYXQoW2xpa2VQb3N0VmFyaWFudCwgQnVmZmVyLmZyb20oc2VyaWFsaXplZERhdGEpXSlcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SiIEluc3RydWN0aW9uIGRhdGE6IHZhcmlhbnQgWzNdLCBzZXJpYWxpemVkIGxlbmd0aDogJHtzZXJpYWxpemVkRGF0YS5sZW5ndGh9LCB0b3RhbDogJHtmdWxsSW5zdHJ1Y3Rpb25EYXRhLmxlbmd0aH0gYnl0ZXNgKVxyXG5cclxuICAgICAgY29uc3QgaW5zdHJ1Y3Rpb24gPSBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XHJcbiAgICAgICAga2V5czogW1xyXG4gICAgICAgICAgeyBwdWJrZXk6IHB1YmxpY0tleSwgaXNTaWduZXI6IHRydWUsIGlzV3JpdGFibGU6IGZhbHNlIH0sIC8vIFVzZXIgYWNjb3VudCAobGlrZXIpXHJcbiAgICAgICAgICB7IHB1YmtleTogcG9zdEFjY291bnRBZGRyZXNzLCBpc1NpZ25lcjogZmFsc2UsIGlzV3JpdGFibGU6IHRydWUgfSwgLy8gQWN0dWFsIHBvc3QgYWNjb3VudCAodG8gdXBkYXRlIGxpa2VzKVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgcHJvZ3JhbUlkOiBQUk9HUkFNX0lELFxyXG4gICAgICAgIGRhdGE6IGZ1bGxJbnN0cnVjdGlvbkRhdGEsXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBjb25zb2xlLmxvZygn8J+UkSBUcmFuc2FjdGlvbiBhY2NvdW50czonKVxyXG4gICAgICBjb25zb2xlLmxvZyhgICBVc2VyIChsaWtlcik6ICR7cHVibGljS2V5LnRvU3RyaW5nKCl9IChzaWduZXIsIHJlYWRvbmx5KWApXHJcbiAgICAgIGNvbnNvbGUubG9nKGAgIFBvc3Q6ICR7cG9zdEFjY291bnRBZGRyZXNzLnRvU3RyaW5nKCl9IChub3Qgc2lnbmVyLCB3cml0YWJsZSlgKVxyXG4gICAgICBjb25zb2xlLmxvZyhgICBQcm9ncmFtOiAke1BST0dSQU1fSUQudG9TdHJpbmcoKX1gKVxyXG5cclxuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoaW5zdHJ1Y3Rpb24pXHJcbiAgICAgIGNvbnN0IHsgYmxvY2toYXNoIH0gPSBhd2FpdCBjb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCgncHJvY2Vzc2VkJylcclxuICAgICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoXHJcbiAgICAgIHRyYW5zYWN0aW9uLmZlZVBheWVyID0gcHVibGljS2V5XHJcblxyXG4gICAgICAvLyBTaW11bGF0ZSB0cmFuc2FjdGlvbiBiZWZvcmUgc2VuZGluZ1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+OryBTaW11bGF0aW5nIHRyYW5zYWN0aW9uLi4uJylcclxuICAgICAgY29uc3Qgc2ltdWxhdGlvbiA9IGF3YWl0IGNvbm5lY3Rpb24uc2ltdWxhdGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbilcclxuICAgICAgY29uc29sZS5sb2coJ/Cfk4ogU2ltdWxhdGlvbiByZXN1bHQ6Jywgc2ltdWxhdGlvbilcclxuICAgICAgXHJcbiAgICAgIGlmIChzaW11bGF0aW9uLnZhbHVlLmVycikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gc2ltdWxhdGlvbiBmYWlsZWQ6ICR7SlNPTi5zdHJpbmdpZnkoc2ltdWxhdGlvbi52YWx1ZS5lcnIpfWApXHJcbiAgICAgIH1cclxuICAgICAgY29uc29sZS5sb2coJ+KchSBUcmFuc2FjdGlvbiBzaW11bGF0aW9uIHN1Y2Nlc3NmdWwnKVxyXG5cclxuICAgICAgY29uc29sZS5sb2coJ/CfmoAgU2VuZGluZyB0cmFuc2FjdGlvbi4uLicpXHJcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgY29ubmVjdGlvbiwge1xyXG4gICAgICAgIHNraXBQcmVmbGlnaHQ6IGZhbHNlLFxyXG4gICAgICAgIHByZWZsaWdodENvbW1pdG1lbnQ6ICdwcm9jZXNzZWQnLFxyXG4gICAgICAgIG1heFJldHJpZXM6IDMsXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhg8J+TiyBUcmFuc2FjdGlvbiBzZW50IHdpdGggc2lnbmF0dXJlOiAke3NpZ25hdHVyZX1gKVxyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coJ+KPsyBDb25maXJtaW5nIHRyYW5zYWN0aW9uLi4uJylcclxuICAgICAgYXdhaXQgY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oe1xyXG4gICAgICAgIHNpZ25hdHVyZSxcclxuICAgICAgICBibG9ja2hhc2gsXHJcbiAgICAgICAgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IChhd2FpdCBjb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCgpKS5sYXN0VmFsaWRCbG9ja0hlaWdodCxcclxuICAgICAgfSwgJ3Byb2Nlc3NlZCcpXHJcblxyXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFRyYW5zYWN0aW9uIGNvbmZpcm1lZCEgUG9zdCBsaWtlZCBzdWNjZXNzZnVsbHkhJylcclxuICAgICAgdG9hc3Quc3VjY2VzcygnUG9zdCBsaWtlZCEnKVxyXG4gICAgICByZXR1cm4gc2lnbmF0dXJlXHJcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBMaWtlIHBvc3QgZXJyb3I6JywgZXJyb3IpXHJcbiAgICAgIFxyXG4gICAgICAvLyBNb3JlIHNwZWNpZmljIGVycm9yIG1lc3NhZ2VzXHJcbiAgICAgIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnaW5zdWZmaWNpZW50IGZ1bmRzJykpIHtcclxuICAgICAgICBjb25zdCBiYWxhbmNlID0gYXdhaXQgY2hlY2tTT0xCYWxhbmNlKClcclxuICAgICAgICB0b2FzdC5lcnJvcihgSW5zdWZmaWNpZW50IFNPTDogJHtiYWxhbmNlLnRvRml4ZWQoNCl9IFNPTC4gTmVlZCBhdCBsZWFzdCAwLjAxIFNPTCBmb3IgZmVlcy5gKVxyXG4gICAgICB9IGVsc2UgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdzaW11bGF0aW9uIGZhaWxlZCcpKSB7XHJcbiAgICAgICAgdG9hc3QuZXJyb3IoJ1RyYW5zYWN0aW9uIHdvdWxkIGZhaWw6IENoZWNrIHBvc3QgZXhpc3RzIGFuZCB3YWxsZXQgaGFzIHBlcm1pc3Npb24nKVxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1NpbXVsYXRpb24gZXJyb3IgZGV0YWlsczonLCBlcnJvci5tZXNzYWdlKVxyXG4gICAgICB9IGVsc2UgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdub3QgZm91bmQgb24gYmxvY2tjaGFpbicpKSB7XHJcbiAgICAgICAgdG9hc3QuZXJyb3IoJ1Bvc3Qgbm90IGZvdW5kIG9uIGJsb2NrY2hhaW4nKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRvYXN0LmVycm9yKGBGYWlsZWQgdG8gbGlrZSBwb3N0OiAke2Vycm9yLm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InfWApXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHRocm93IGVycm9yXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBDaGVjayBzcGVjaWZpYyBwcm9maWxlIFBEQSAtIGZvciBkZWJ1Z2dpbmcgcHJvZmlsZSBkZXRlY3Rpb24gaXNzdWVzXHJcbiAgY29uc3QgY2hlY2tQcm9maWxlQXRQREEgPSBhc3luYyAocGRhQWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+UjSBDaGVja2luZyBzcGVjaWZpYyBQREE6ICR7cGRhQWRkcmVzc31gKVxyXG4gICAgICBjb25zdCBwZGEgPSBuZXcgUHVibGljS2V5KHBkYUFkZHJlc3MpXHJcbiAgICAgIGNvbnN0IGFjY291bnRJbmZvID0gYXdhaXQgY29ubmVjdGlvbi5nZXRBY2NvdW50SW5mbyhwZGEpXHJcbiAgICAgIFxyXG4gICAgICBpZiAoIWFjY291bnRJbmZvKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYOKdjCBObyBhY2NvdW50IGZvdW5kIGF0IFBEQTogJHtwZGFBZGRyZXNzfWApXHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKGDinIUgQWNjb3VudCBleGlzdHMhIE93bmVyOiAke2FjY291bnRJbmZvLm93bmVyLnRvU3RyaW5nKCl9LCBTaXplOiAke2FjY291bnRJbmZvLmRhdGEubGVuZ3RofSBieXRlc2ApXHJcbiAgICAgIFxyXG4gICAgICAvLyBJbnNwZWN0IHJhdyBkYXRhXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIFJhdyBkYXRhIChmaXJzdCAxMDAgYnl0ZXMpOmAsIEFycmF5LmZyb20oYWNjb3VudEluZm8uZGF0YS5zbGljZSgwLCAxMDApKSlcclxuICAgICAgXHJcbiAgICAgIGlmIChhY2NvdW50SW5mby5vd25lci5lcXVhbHMoUFJPR1JBTV9JRCkpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEFjY291bnQgaXMgb3duZWQgYnkgb3VyIHByb2dyYW1gKVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAvLyBUcnkgbWFudWFsIHBhcnNpbmcgdG8gdW5kZXJzdGFuZCB0aGUgc3RydWN0dXJlXHJcbiAgICAgICAgICBsZXQgb2Zmc2V0ID0gMFxyXG4gICAgICAgICAgY29uc3QgaXNfaW5pdGlhbGl6ZWQgPSBhY2NvdW50SW5mby5kYXRhW29mZnNldF1cclxuICAgICAgICAgIG9mZnNldCArPSAxXHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TiiBpc19pbml0aWFsaXplZDogJHtpc19pbml0aWFsaXplZH1gKVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjb25zdCBvd25lciA9IGFjY291bnRJbmZvLmRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyAzMilcclxuICAgICAgICAgIG9mZnNldCArPSAzMlxyXG4gICAgICAgICAgY29uc29sZS5sb2coYPCfk4ogb3duZXI6ICR7bmV3IFB1YmxpY0tleShvd25lcikudG9TdHJpbmcoKX1gKVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBUcnkgdG8gcmVhZCB0aGUgdXNlcm5hbWUgbGVuZ3RoIChCb3JzaCBzdHJpbmcgZm9ybWF0OiA0IGJ5dGVzIGxlbmd0aCArIHN0cmluZylcclxuICAgICAgICAgIGNvbnN0IHVzZXJuYW1lTGVuZ3RoID0gYWNjb3VudEluZm8uZGF0YS5yZWFkVUludDMyTEUob2Zmc2V0KVxyXG4gICAgICAgICAgb2Zmc2V0ICs9IDRcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OKIHVzZXJuYW1lIGxlbmd0aDogJHt1c2VybmFtZUxlbmd0aH1gKVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAodXNlcm5hbWVMZW5ndGggPiAwICYmIHVzZXJuYW1lTGVuZ3RoIDwgMTAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHVzZXJuYW1lID0gYWNjb3VudEluZm8uZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIHVzZXJuYW1lTGVuZ3RoKS50b1N0cmluZygndXRmOCcpXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OKIHVzZXJuYW1lOiBcIiR7dXNlcm5hbWV9XCJgKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBOb3cgdHJ5IG1hbnVhbCBwYXJzaW5nXHJcbiAgICAgICAgICBjb25zdCBwcm9maWxlQWNjb3VudCA9IG1hbnVhbFBhcnNlUHJvZmlsZShhY2NvdW50SW5mby5kYXRhKVxyXG4gICAgICAgICAgaWYgKHByb2ZpbGVBY2NvdW50KSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgU3VjY2Vzc2Z1bGx5IG1hbnVhbGx5IHBhcnNlZCBwcm9maWxlOmAsIHtcclxuICAgICAgICAgICAgICB1c2VybmFtZTogcHJvZmlsZUFjY291bnQudXNlcm5hbWUsXHJcbiAgICAgICAgICAgICAgYmlvOiBwcm9maWxlQWNjb3VudC5iaW8sXHJcbiAgICAgICAgICAgICAgaXNJbml0aWFsaXplZDogcHJvZmlsZUFjY291bnQuaXNfaW5pdGlhbGl6ZWQgPT09IDEsXHJcbiAgICAgICAgICAgICAgb3duZXI6IG5ldyBQdWJsaWNLZXkocHJvZmlsZUFjY291bnQub3duZXIpLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgcHJvZmlsZUltYWdlOiBwcm9maWxlQWNjb3VudC5wcm9maWxlX2ltYWdlLFxyXG4gICAgICAgICAgICAgIGNvdmVySW1hZ2U6IHByb2ZpbGVBY2NvdW50LmNvdmVyX2ltYWdlLFxyXG4gICAgICAgICAgICAgIHBvc3RzQ291bnQ6IE51bWJlcihwcm9maWxlQWNjb3VudC5wb3N0c19jb3VudClcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinYwgTWFudWFsIHBhcnNpbmcgZmFpbGVkYClcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gQWxzbyB0cnkgQm9yc2ggZm9yIGNvbXBhcmlzb25cclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb2ZpbGVBY2NvdW50ID0gZGVzZXJpYWxpemUocHJvZmlsZUFjY291bnRTY2hlbWEsIFByb2ZpbGVBY2NvdW50LCBhY2NvdW50SW5mby5kYXRhKSBhcyBQcm9maWxlQWNjb3VudFxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEJvcnNoIGRlc2VyaWFsaXphdGlvbiBhbHNvIHdvcmtlZDpgLCB7XHJcbiAgICAgICAgICAgICAgdXNlcm5hbWU6IHByb2ZpbGVBY2NvdW50LnVzZXJuYW1lLFxyXG4gICAgICAgICAgICAgIGJpbzogcHJvZmlsZUFjY291bnQuYmlvLFxyXG4gICAgICAgICAgICAgIGlzSW5pdGlhbGl6ZWQ6IHByb2ZpbGVBY2NvdW50LmlzX2luaXRpYWxpemVkID09PSAxLFxyXG4gICAgICAgICAgICAgIG93bmVyOiBuZXcgUHVibGljS2V5KHByb2ZpbGVBY2NvdW50Lm93bmVyKS50b1N0cmluZygpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4p2MIEJvcnNoIGRlc2VyaWFsaXphdGlvbiBzdGlsbCBmYWlsczpgLCBlcnJvcilcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYOKdjCBFcnJvciBjaGVja2luZyBQREE6YCwgZXJyb3IpXHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGDinYwgQWNjb3VudCBpcyBvd25lZCBieSBkaWZmZXJlbnQgcHJvZ3JhbTogJHthY2NvdW50SW5mby5vd25lci50b1N0cmluZygpfWApXHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDinYwgRXJyb3IgY2hlY2tpbmcgUERBOmAsIGVycm9yKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gTWFudWFsIHByb2ZpbGUgcGFyc2VyIC0gYnlwYXNzZXMgQm9yc2ggZGVzZXJpYWxpemF0aW9uIGlzc3Vlc1xyXG4gIGNvbnN0IG1hbnVhbFBhcnNlUHJvZmlsZSA9IChkYXRhOiBCdWZmZXIpOiBQcm9maWxlQWNjb3VudCB8IG51bGwgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gQmFzaWMgdmFsaWRhdGlvbiAtIHByb2ZpbGVzIHNob3VsZCBoYXZlIGEgbWluaW11bSBzaXplXHJcbiAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDE1MCkgcmV0dXJuIG51bGwgLy8gUHJvZmlsZXMgbmVlZCBhdCBsZWFzdCAxNTAgYnl0ZXMgZm9yIGJhc2ljIHN0cnVjdHVyZVxyXG4gICAgICBcclxuICAgICAgbGV0IG9mZnNldCA9IDBcclxuICAgICAgXHJcbiAgICAgIC8vIFBhcnNlIGVhY2ggZmllbGQgbWFudWFsbHlcclxuICAgICAgY29uc3QgaXNfaW5pdGlhbGl6ZWQgPSBkYXRhW29mZnNldF1cclxuICAgICAgaWYgKGlzX2luaXRpYWxpemVkICE9PSAxKSByZXR1cm4gbnVsbCAvLyBNdXN0IGJlIGluaXRpYWxpemVkXHJcbiAgICAgIG9mZnNldCArPSAxXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBvd25lciA9IGRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyAzMilcclxuICAgICAgb2Zmc2V0ICs9IDMyXHJcbiAgICAgIFxyXG4gICAgICAvLyBWYWxpZGF0ZSB3ZSBoYXZlIGVub3VnaCBkYXRhIGZvciB1c2VybmFtZSBsZW5ndGhcclxuICAgICAgaWYgKG9mZnNldCArIDQgPiBkYXRhLmxlbmd0aCkgcmV0dXJuIG51bGxcclxuICAgICAgXHJcbiAgICAgIC8vIFN0cmluZyBmaWVsZHMgKHVzZXJuYW1lLCBiaW8sIHByb2ZpbGVfaW1hZ2UsIGNvdmVyX2ltYWdlKVxyXG4gICAgICBjb25zdCB1c2VybmFtZUxlbmd0aCA9IGRhdGEucmVhZFVJbnQzMkxFKG9mZnNldClcclxuICAgICAgb2Zmc2V0ICs9IDRcclxuICAgICAgXHJcbiAgICAgIC8vIFZhbGlkYXRlIHVzZXJuYW1lIGxlbmd0aCBpcyByZWFzb25hYmxlXHJcbiAgICAgIGlmICh1c2VybmFtZUxlbmd0aCA+IDEwMCB8fCB1c2VybmFtZUxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGxcclxuICAgICAgaWYgKG9mZnNldCArIHVzZXJuYW1lTGVuZ3RoID4gZGF0YS5sZW5ndGgpIHJldHVybiBudWxsXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCB1c2VybmFtZSA9IGRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB1c2VybmFtZUxlbmd0aCkudG9TdHJpbmcoJ3V0ZjgnKVxyXG4gICAgICBvZmZzZXQgKz0gdXNlcm5hbWVMZW5ndGhcclxuICAgICAgXHJcbiAgICAgIC8vIFZhbGlkYXRlIHdlIGhhdmUgZW5vdWdoIGRhdGEgZm9yIGJpbyBsZW5ndGhcclxuICAgICAgaWYgKG9mZnNldCArIDQgPiBkYXRhLmxlbmd0aCkgcmV0dXJuIG51bGxcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGJpb0xlbmd0aCA9IGRhdGEucmVhZFVJbnQzMkxFKG9mZnNldClcclxuICAgICAgb2Zmc2V0ICs9IDRcclxuICAgICAgXHJcbiAgICAgIC8vIFZhbGlkYXRlIGJpbyBsZW5ndGggaXMgcmVhc29uYWJsZVxyXG4gICAgICBpZiAoYmlvTGVuZ3RoID4gMTAwMCkgcmV0dXJuIG51bGxcclxuICAgICAgaWYgKG9mZnNldCArIGJpb0xlbmd0aCA+IGRhdGEubGVuZ3RoKSByZXR1cm4gbnVsbFxyXG4gICAgICBcclxuICAgICAgY29uc3QgYmlvID0gZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIGJpb0xlbmd0aCkudG9TdHJpbmcoJ3V0ZjgnKVxyXG4gICAgICBvZmZzZXQgKz0gYmlvTGVuZ3RoXHJcbiAgICAgIFxyXG4gICAgICAvLyBWYWxpZGF0ZSB3ZSBoYXZlIGVub3VnaCBkYXRhIGZvciBwcm9maWxlIGltYWdlIGxlbmd0aFxyXG4gICAgICBpZiAob2Zmc2V0ICsgNCA+IGRhdGEubGVuZ3RoKSByZXR1cm4gbnVsbFxyXG4gICAgICBcclxuICAgICAgY29uc3QgcHJvZmlsZUltYWdlTGVuZ3RoID0gZGF0YS5yZWFkVUludDMyTEUob2Zmc2V0KVxyXG4gICAgICBvZmZzZXQgKz0gNFxyXG4gICAgICBcclxuICAgICAgLy8gVmFsaWRhdGUgcHJvZmlsZSBpbWFnZSBsZW5ndGggaXMgcmVhc29uYWJsZVxyXG4gICAgICBpZiAocHJvZmlsZUltYWdlTGVuZ3RoID4gNTAwKSByZXR1cm4gbnVsbFxyXG4gICAgICBpZiAob2Zmc2V0ICsgcHJvZmlsZUltYWdlTGVuZ3RoID4gZGF0YS5sZW5ndGgpIHJldHVybiBudWxsXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBwcm9maWxlX2ltYWdlID0gZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIHByb2ZpbGVJbWFnZUxlbmd0aCkudG9TdHJpbmcoJ3V0ZjgnKVxyXG4gICAgICBvZmZzZXQgKz0gcHJvZmlsZUltYWdlTGVuZ3RoXHJcbiAgICAgIFxyXG4gICAgICAvLyBWYWxpZGF0ZSB3ZSBoYXZlIGVub3VnaCBkYXRhIGZvciBjb3ZlciBpbWFnZSBsZW5ndGhcclxuICAgICAgaWYgKG9mZnNldCArIDQgPiBkYXRhLmxlbmd0aCkgcmV0dXJuIG51bGxcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGNvdmVySW1hZ2VMZW5ndGggPSBkYXRhLnJlYWRVSW50MzJMRShvZmZzZXQpXHJcbiAgICAgIG9mZnNldCArPSA0XHJcbiAgICAgIFxyXG4gICAgICAvLyBWYWxpZGF0ZSBjb3ZlciBpbWFnZSBsZW5ndGggaXMgcmVhc29uYWJsZVxyXG4gICAgICBpZiAoY292ZXJJbWFnZUxlbmd0aCA+IDUwMCkgcmV0dXJuIG51bGxcclxuICAgICAgaWYgKG9mZnNldCArIGNvdmVySW1hZ2VMZW5ndGggPiBkYXRhLmxlbmd0aCkgcmV0dXJuIG51bGxcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGNvdmVyX2ltYWdlID0gZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIGNvdmVySW1hZ2VMZW5ndGgpLnRvU3RyaW5nKCd1dGY4JylcclxuICAgICAgb2Zmc2V0ICs9IGNvdmVySW1hZ2VMZW5ndGhcclxuICAgICAgXHJcbiAgICAgIC8vIFZhbGlkYXRlIHdlIGhhdmUgZW5vdWdoIGRhdGEgZm9yIGFsbCB0aGUgdTY0IGZpZWxkcyAoOCBieXRlcyBlYWNoICogNiBmaWVsZHMgPSA0OCBieXRlcylcclxuICAgICAgaWYgKG9mZnNldCArIDQ4ID4gZGF0YS5sZW5ndGgpIHJldHVybiBudWxsXHJcbiAgICAgIFxyXG4gICAgICAvLyB1NjQgZmllbGRzXHJcbiAgICAgIGNvbnN0IGNyZWF0ZWRfYXQgPSBkYXRhLnJlYWRCaWdVSW50NjRMRShvZmZzZXQpXHJcbiAgICAgIG9mZnNldCArPSA4XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBmb2xsb3dlcnNfY291bnQgPSBkYXRhLnJlYWRCaWdVSW50NjRMRShvZmZzZXQpXHJcbiAgICAgIG9mZnNldCArPSA4XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBmb2xsb3dpbmdfY291bnQgPSBkYXRhLnJlYWRCaWdVSW50NjRMRShvZmZzZXQpXHJcbiAgICAgIG9mZnNldCArPSA4XHJcbiAgICAgIFxyXG4gICAgICAvLyBpNjQgZmllbGRcclxuICAgICAgY29uc3QgdXNlcl9jcmVkaXRfcmF0aW5nID0gZGF0YS5yZWFkQmlnSW50NjRMRShvZmZzZXQpXHJcbiAgICAgIG9mZnNldCArPSA4XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBwb3N0c19jb3VudCA9IGRhdGEucmVhZEJpZ1VJbnQ2NExFKG9mZnNldClcclxuICAgICAgb2Zmc2V0ICs9IDhcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGxhc3RfcG9zdF90aW1lc3RhbXAgPSBkYXRhLnJlYWRCaWdVSW50NjRMRShvZmZzZXQpXHJcbiAgICAgIG9mZnNldCArPSA4XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBkYWlseV9wb3N0X2NvdW50ID0gZGF0YS5yZWFkQmlnVUludDY0TEUob2Zmc2V0KVxyXG4gICAgICBvZmZzZXQgKz0gOFxyXG4gICAgICBcclxuICAgICAgLy8gVmFsaWRhdGUgd2UgaGF2ZSBlbm91Z2ggZGF0YSBmb3IgdGhlIGZpbmFsIHU4IGZpZWxkXHJcbiAgICAgIGlmIChvZmZzZXQgKyAxID4gZGF0YS5sZW5ndGgpIHJldHVybiBudWxsXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBpc192ZXJpZmllZCA9IGRhdGFbb2Zmc2V0XVxyXG4gICAgICBvZmZzZXQgKz0gMVxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIG5ldyBQcm9maWxlQWNjb3VudCh7XHJcbiAgICAgICAgaXNfaW5pdGlhbGl6ZWQsXHJcbiAgICAgICAgb3duZXI6IG5ldyBVaW50OEFycmF5KG93bmVyKSxcclxuICAgICAgICB1c2VybmFtZSxcclxuICAgICAgICBiaW8sXHJcbiAgICAgICAgcHJvZmlsZV9pbWFnZSxcclxuICAgICAgICBjb3Zlcl9pbWFnZSxcclxuICAgICAgICBjcmVhdGVkX2F0LFxyXG4gICAgICAgIGZvbGxvd2Vyc19jb3VudCxcclxuICAgICAgICBmb2xsb3dpbmdfY291bnQsXHJcbiAgICAgICAgdXNlcl9jcmVkaXRfcmF0aW5nLFxyXG4gICAgICAgIHBvc3RzX2NvdW50LFxyXG4gICAgICAgIGxhc3RfcG9zdF90aW1lc3RhbXAsXHJcbiAgICAgICAgZGFpbHlfcG9zdF9jb3VudCxcclxuICAgICAgICBpc192ZXJpZmllZFxyXG4gICAgICB9KVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgLy8gU2lsZW50IGZhaWx1cmUgLSBub3QgYSBwcm9maWxlIGFjY291bnQgb3IgaW52YWxpZCBkYXRhXHJcbiAgICAgIHJldHVybiBudWxsXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBNYW51YWwgcG9zdCBwYXJzZXIgLSBieXBhc3NlcyBCb3JzaCBkZXNlcmlhbGl6YXRpb24gaXNzdWVzXHJcbiAgY29uc3QgbWFudWFsUGFyc2VQb3N0ID0gKGRhdGE6IEJ1ZmZlcik6IFBvc3RBY2NvdW50IHwgbnVsbCA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBRdWljayB2YWxpZGF0aW9uOiBwb3N0cyBzaG91bGQgaGF2ZSBzcGVjaWZpYyBzaXplIGFuZCBzdHJ1Y3R1cmVcclxuICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgMTAwKSByZXR1cm4gbnVsbCAvLyBQb3N0cyBzaG91bGQgYmUgbGFyZ2VyIHRoYW4gcHJvZmlsZXNcclxuICAgICAgXHJcbiAgICAgIGxldCBvZmZzZXQgPSAwXHJcbiAgICAgIFxyXG4gICAgICAvLyBQYXJzZSBlYWNoIGZpZWxkIG1hbnVhbGx5XHJcbiAgICAgIGNvbnN0IGlzX2luaXRpYWxpemVkID0gZGF0YVtvZmZzZXRdXHJcbiAgICAgIGlmIChpc19pbml0aWFsaXplZCAhPT0gMSkgcmV0dXJuIG51bGwgLy8gTXVzdCBiZSBpbml0aWFsaXplZFxyXG4gICAgICBvZmZzZXQgKz0gMVxyXG4gICAgICBcclxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBsb29rcyBsaWtlIGEgcG9zdCB2cyBwcm9maWxlIGJ5IGV4YW1pbmluZyB0aGUgc3RydWN0dXJlXHJcbiAgICAgIC8vIFBvc3RzIHN0YXJ0IHdpdGg6IHU4IChpbml0KSwgdTY0IChpZCksIFszMl11OCAoYXV0aG9yKSwgc3RyaW5nIChjb250ZW50KVxyXG4gICAgICAvLyBQcm9maWxlcyBzdGFydCB3aXRoOiB1OCAoaW5pdCksIFszMl11OCAob3duZXIpLCBzdHJpbmcgKHVzZXJuYW1lKVxyXG4gICAgICBcclxuICAgICAgY29uc3QgaWQgPSBkYXRhLnJlYWRCaWdVSW50NjRMRShvZmZzZXQpXHJcbiAgICAgIG9mZnNldCArPSA4XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBhdXRob3IgPSBkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgMzIpXHJcbiAgICAgIG9mZnNldCArPSAzMlxyXG4gICAgICBcclxuICAgICAgY29uc3QgY29udGVudExlbmd0aCA9IGRhdGEucmVhZFVJbnQzMkxFKG9mZnNldClcclxuICAgICAgb2Zmc2V0ICs9IDRcclxuICAgICAgXHJcbiAgICAgIC8vIFZhbGlkYXRlIGNvbnRlbnQgbGVuZ3RoIGlzIHJlYXNvbmFibGUgKG5vdCB0b28gbGFyZ2UpXHJcbiAgICAgIGlmIChjb250ZW50TGVuZ3RoID4gMTAwMDAgfHwgY29udGVudExlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGxcclxuICAgICAgaWYgKG9mZnNldCArIGNvbnRlbnRMZW5ndGggPiBkYXRhLmxlbmd0aCkgcmV0dXJuIG51bGxcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgY29udGVudExlbmd0aCkudG9TdHJpbmcoJ3V0ZjgnKVxyXG4gICAgICBvZmZzZXQgKz0gY29udGVudExlbmd0aFxyXG4gICAgICBcclxuICAgICAgLy8gRW5zdXJlIHdlIGhhdmUgZW5vdWdoIHJlbWFpbmluZyBkYXRhIGZvciB0aGUgcmVzdCBvZiB0aGUgcG9zdCBzdHJ1Y3R1cmVcclxuICAgICAgaWYgKG9mZnNldCArIDQwID4gZGF0YS5sZW5ndGgpIHJldHVybiBudWxsIC8vIE5lZWQgYXQgbGVhc3QgNDAgbW9yZSBieXRlcyBmb3IgdGltZXN0YW1wcyBhbmQgY291bnRzXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCB0aW1lc3RhbXAgPSBkYXRhLnJlYWRCaWdVSW50NjRMRShvZmZzZXQpXHJcbiAgICAgIG9mZnNldCArPSA4XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBsaWtlcyA9IGRhdGEucmVhZEJpZ1VJbnQ2NExFKG9mZnNldClcclxuICAgICAgb2Zmc2V0ICs9IDhcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGNvbW1lbnRzID0gZGF0YS5yZWFkQmlnVUludDY0TEUob2Zmc2V0KVxyXG4gICAgICBvZmZzZXQgKz0gOFxyXG4gICAgICBcclxuICAgICAgY29uc3QgbWlycm9ycyA9IGRhdGEucmVhZEJpZ1VJbnQ2NExFKG9mZnNldClcclxuICAgICAgb2Zmc2V0ICs9IDhcclxuICAgICAgXHJcbiAgICAgIC8vIFBhcnNlIGltYWdlcyBhcnJheSBsZW5ndGhcclxuICAgICAgaWYgKG9mZnNldCArIDQgPiBkYXRhLmxlbmd0aCkgcmV0dXJuIG51bGxcclxuICAgICAgY29uc3QgaW1hZ2VzTGVuZ3RoID0gZGF0YS5yZWFkVUludDMyTEUob2Zmc2V0KVxyXG4gICAgICBvZmZzZXQgKz0gNFxyXG4gICAgICBjb25zdCBpbWFnZXM6IHN0cmluZ1tdID0gW11cclxuICAgICAgXHJcbiAgICAgIC8vIFBhcnNlIGltYWdlcyBhcnJheSAtIGVhY2ggaW1hZ2UgaXMgYSBsZW5ndGgtcHJlZml4ZWQgc3RyaW5nXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW1hZ2VzTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAob2Zmc2V0ICsgNCA+IGRhdGEubGVuZ3RoKSByZXR1cm4gbnVsbFxyXG4gICAgICAgIGNvbnN0IGltYWdlTGVuZ3RoID0gZGF0YS5yZWFkVUludDMyTEUob2Zmc2V0KVxyXG4gICAgICAgIG9mZnNldCArPSA0XHJcbiAgICAgICAgaWYgKG9mZnNldCArIGltYWdlTGVuZ3RoID4gZGF0YS5sZW5ndGgpIHJldHVybiBudWxsXHJcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgaW1hZ2VMZW5ndGgpLnRvU3RyaW5nKCd1dGY4JylcclxuICAgICAgICBvZmZzZXQgKz0gaW1hZ2VMZW5ndGhcclxuICAgICAgICBpbWFnZXMucHVzaChpbWFnZSlcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gRW5zdXJlIHdlIGhhdmUgZW5vdWdoIGRhdGEgZm9yIHJhdGluZyBhbmQga2lsbCB6b25lXHJcbiAgICAgIGlmIChvZmZzZXQgKyAyID4gZGF0YS5sZW5ndGgpIHJldHVybiBudWxsXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCByYXRpbmcgPSBkYXRhW29mZnNldF1cclxuICAgICAgb2Zmc2V0ICs9IDFcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGluX2tpbGxfem9uZSA9IGRhdGFbb2Zmc2V0XVxyXG4gICAgICBvZmZzZXQgKz0gMVxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIG5ldyBQb3N0QWNjb3VudCh7XHJcbiAgICAgICAgaXNfaW5pdGlhbGl6ZWQsXHJcbiAgICAgICAgaWQsXHJcbiAgICAgICAgYXV0aG9yOiBuZXcgVWludDhBcnJheShhdXRob3IpLFxyXG4gICAgICAgIGNvbnRlbnQsXHJcbiAgICAgICAgdGltZXN0YW1wLFxyXG4gICAgICAgIGxpa2VzLFxyXG4gICAgICAgIGNvbW1lbnRzLFxyXG4gICAgICAgIG1pcnJvcnMsXHJcbiAgICAgICAgaW1hZ2VzLFxyXG4gICAgICAgIHJhdGluZyxcclxuICAgICAgICBpbl9raWxsX3pvbmVcclxuICAgICAgfSlcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIC8vIFNpbGVudCBmYWlsdXJlIC0gbm90IGEgcG9zdCBhY2NvdW50XHJcbiAgICAgIHJldHVybiBudWxsXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBDb252ZXJ0IENvbW11bml0eUFjY291bnQgdG8gQ29tbXVuaXR5IGludGVyZmFjZVxyXG4gIGNvbnN0IGNvbnZlcnRDb21tdW5pdHlBY2NvdW50ID0gKGNvbW11bml0eUFjY291bnQ6IENvbW11bml0eUFjY291bnQpOiBDb21tdW5pdHkgPT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgaXNJbml0aWFsaXplZDogY29tbXVuaXR5QWNjb3VudC5pc19pbml0aWFsaXplZCA9PT0gMSxcclxuICAgICAgaWQ6IE51bWJlcihjb21tdW5pdHlBY2NvdW50LmlkKSxcclxuICAgICAgY3JlYXRvcjogbmV3IFB1YmxpY0tleShjb21tdW5pdHlBY2NvdW50LmNyZWF0b3IpLFxyXG4gICAgICBuYW1lOiBjb21tdW5pdHlBY2NvdW50Lm5hbWUsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiBjb21tdW5pdHlBY2NvdW50LmRlc2NyaXB0aW9uLFxyXG4gICAgICBhdmF0YXI6IGNvbW11bml0eUFjY291bnQuYXZhdGFyLFxyXG4gICAgICBydWxlczogY29tbXVuaXR5QWNjb3VudC5ydWxlcyxcclxuICAgICAgbWVtYmVyQ291bnQ6IE51bWJlcihjb21tdW5pdHlBY2NvdW50Lm1lbWJlcl9jb3VudCksXHJcbiAgICAgIGNyZWF0ZWRBdDogTnVtYmVyKGNvbW11bml0eUFjY291bnQuY3JlYXRlZF9hdCkgKiAxMDAwLCAvLyBDb252ZXJ0IHNlY29uZHMgdG8gbWlsbGlzZWNvbmRzXHJcbiAgICAgIGlzUHJpdmF0ZTogY29tbXVuaXR5QWNjb3VudC5pc19wcml2YXRlID09PSAxLFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQ3JlYXRlIENvbW11bml0eVxyXG4gIGNvbnN0IGNyZWF0ZUNvbW11bml0eSA9IGFzeW5jIChcclxuICAgIG5hbWU6IHN0cmluZyxcclxuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmcsXHJcbiAgICBhdmF0YXI6IHN0cmluZyxcclxuICAgIHJ1bGVzOiBzdHJpbmdbXSA9IFtdXHJcbiAgKSA9PiB7XHJcbiAgICBpZiAoIXB1YmxpY0tleSkgdGhyb3cgbmV3IEVycm9yKCdXYWxsZXQgbm90IGNvbm5lY3RlZCcpXHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ/Cfj5jvuI8gQ3JlYXRpbmcgY29tbXVuaXR5OicsIG5hbWUpXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBiYWxhbmNlID0gYXdhaXQgY2hlY2tTT0xCYWxhbmNlKClcclxuICAgICAgaWYgKGJhbGFuY2UgPCAwLjA1KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN1ZmZpY2llbnQgU09MIGJhbGFuY2U6ICR7YmFsYW5jZX0uIE5lZWQgYXQgbGVhc3QgMC4wNSBTT0wuYClcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gR2VuZXJhdGUgYSBrZXlwYWlyIGZvciB0aGUgY29tbXVuaXR5IGFjY291bnRcclxuICAgICAgY29uc3QgY29tbXVuaXR5S2V5cGFpciA9IEtleXBhaXIuZ2VuZXJhdGUoKVxyXG4gICAgICBjb25zb2xlLmxvZyhg8J+TjSBDb21tdW5pdHkgQWNjb3VudDogJHtjb21tdW5pdHlLZXlwYWlyLnB1YmxpY0tleS50b1N0cmluZygpfWApXHJcblxyXG4gICAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSBuZXcgQ3JlYXRlQ29tbXVuaXR5SW5zdHJ1Y3Rpb24oe1xyXG4gICAgICAgIG5hbWUsXHJcbiAgICAgICAgZGVzY3JpcHRpb24sXHJcbiAgICAgICAgYXZhdGFyLFxyXG4gICAgICAgIHJ1bGVzLFxyXG4gICAgICB9KVxyXG5cclxuICAgICAgY29uc3QgY3JlYXRlQ29tbXVuaXR5VmFyaWFudCA9IEJ1ZmZlci5mcm9tKFs3XSkgLy8gQ3JlYXRlQ29tbXVuaXR5IGVudW0gaW5kZXhcclxuICAgICAgY29uc3Qgc2VyaWFsaXplZERhdGEgPSBzZXJpYWxpemUoY3JlYXRlQ29tbXVuaXR5U2NoZW1hLCBpbnN0cnVjdGlvbkRhdGEpXHJcbiAgICAgIGNvbnN0IGZ1bGxJbnN0cnVjdGlvbkRhdGEgPSBCdWZmZXIuY29uY2F0KFtjcmVhdGVDb21tdW5pdHlWYXJpYW50LCBCdWZmZXIuZnJvbShzZXJpYWxpemVkRGF0YSldKVxyXG5cclxuICAgICAgY29uc3QgaW5zdHJ1Y3Rpb24gPSBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XHJcbiAgICAgICAga2V5czogW1xyXG4gICAgICAgICAgeyBwdWJrZXk6IHB1YmxpY0tleSwgaXNTaWduZXI6IHRydWUsIGlzV3JpdGFibGU6IHRydWUgfSwgLy8gQ3JlYXRvciBhY2NvdW50XHJcbiAgICAgICAgICB7IHB1YmtleTogY29tbXVuaXR5S2V5cGFpci5wdWJsaWNLZXksIGlzU2lnbmVyOiB0cnVlLCBpc1dyaXRhYmxlOiB0cnVlIH0sIC8vIENvbW11bml0eSBhY2NvdW50XHJcbiAgICAgICAgICB7IHB1YmtleTogU3lzdGVtUHJvZ3JhbS5wcm9ncmFtSWQsIGlzU2lnbmVyOiBmYWxzZSwgaXNXcml0YWJsZTogZmFsc2UgfSwgLy8gU3lzdGVtIHByb2dyYW1cclxuICAgICAgICBdLFxyXG4gICAgICAgIHByb2dyYW1JZDogUFJPR1JBTV9JRCxcclxuICAgICAgICBkYXRhOiBmdWxsSW5zdHJ1Y3Rpb25EYXRhLFxyXG4gICAgICB9KVxyXG5cclxuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoaW5zdHJ1Y3Rpb24pXHJcbiAgICAgIGNvbnN0IHsgYmxvY2toYXNoIH0gPSBhd2FpdCBjb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCgncHJvY2Vzc2VkJylcclxuICAgICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoXHJcbiAgICAgIHRyYW5zYWN0aW9uLmZlZVBheWVyID0gcHVibGljS2V5XHJcblxyXG4gICAgICAvLyBTaWduIHdpdGggY29tbXVuaXR5IGtleXBhaXJcclxuICAgICAgdHJhbnNhY3Rpb24ucGFydGlhbFNpZ24oY29tbXVuaXR5S2V5cGFpcilcclxuXHJcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgY29ubmVjdGlvbiwge1xyXG4gICAgICAgIHNraXBQcmVmbGlnaHQ6IGZhbHNlLFxyXG4gICAgICAgIHByZWZsaWdodENvbW1pdG1lbnQ6ICdwcm9jZXNzZWQnLFxyXG4gICAgICAgIG1heFJldHJpZXM6IDMsXHJcbiAgICAgICAgc2lnbmVyczogW2NvbW11bml0eUtleXBhaXJdLFxyXG4gICAgICB9KVxyXG5cclxuICAgICAgYXdhaXQgY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oe1xyXG4gICAgICAgIHNpZ25hdHVyZSxcclxuICAgICAgICBibG9ja2hhc2gsXHJcbiAgICAgICAgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IChhd2FpdCBjb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCgpKS5sYXN0VmFsaWRCbG9ja0hlaWdodCxcclxuICAgICAgfSwgJ3Byb2Nlc3NlZCcpXHJcblxyXG4gICAgICBjb25zb2xlLmxvZygn4pyFIENvbW11bml0eSBjcmVhdGVkIHN1Y2Nlc3NmdWxseSEnKVxyXG4gICAgICB0b2FzdC5zdWNjZXNzKGBDb21tdW5pdHkgXCIke25hbWV9XCIgY3JlYXRlZCBzdWNjZXNzZnVsbHkhYClcclxuICAgICAgcmV0dXJuIHNpZ25hdHVyZVxyXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgQ29tbXVuaXR5IGNyZWF0aW9uIGVycm9yOicsIGVycm9yKVxyXG4gICAgICB0b2FzdC5lcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBjb21tdW5pdHk6ICR7ZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YClcclxuICAgICAgdGhyb3cgZXJyb3JcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEZvbGxvdyBQcm9maWxlXHJcbiAgY29uc3QgZm9sbG93UHJvZmlsZSA9IGFzeW5jIChwcm9maWxlUHVibGljS2V5OiBQdWJsaWNLZXkpID0+IHtcclxuICAgIGlmICghcHVibGljS2V5KSB0aHJvdyBuZXcgRXJyb3IoJ1dhbGxldCBub3QgY29ubmVjdGVkJylcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+RpSBGb2xsb3dpbmcgcHJvZmlsZTonLCBwcm9maWxlUHVibGljS2V5LnRvU3RyaW5nKCkpXHJcblxyXG4gICAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSBuZXcgRm9sbG93UHJvZmlsZUluc3RydWN0aW9uKHtcclxuICAgICAgICBwcm9maWxlX2lkOiBwcm9maWxlUHVibGljS2V5LFxyXG4gICAgICB9KVxyXG5cclxuICAgICAgY29uc3QgZm9sbG93UHJvZmlsZVZhcmlhbnQgPSBCdWZmZXIuZnJvbShbNV0pIC8vIEZvbGxvd1Byb2ZpbGUgZW51bSBpbmRleFxyXG4gICAgICBjb25zdCBzZXJpYWxpemVkRGF0YSA9IHNlcmlhbGl6ZShmb2xsb3dQcm9maWxlU2NoZW1hLCBpbnN0cnVjdGlvbkRhdGEpXHJcbiAgICAgIGNvbnN0IGZ1bGxJbnN0cnVjdGlvbkRhdGEgPSBCdWZmZXIuY29uY2F0KFtmb2xsb3dQcm9maWxlVmFyaWFudCwgQnVmZmVyLmZyb20oc2VyaWFsaXplZERhdGEpXSlcclxuXHJcbiAgICAgIGNvbnN0IGluc3RydWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xyXG4gICAgICAgIGtleXM6IFtcclxuICAgICAgICAgIHsgcHVia2V5OiBwdWJsaWNLZXksIGlzU2lnbmVyOiB0cnVlLCBpc1dyaXRhYmxlOiBmYWxzZSB9LCAvLyBGb2xsb3dlciBhY2NvdW50XHJcbiAgICAgICAgICB7IHB1YmtleTogcHJvZmlsZVB1YmxpY0tleSwgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiB0cnVlIH0sIC8vIFByb2ZpbGUgdG8gZm9sbG93XHJcbiAgICAgICAgXSxcclxuICAgICAgICBwcm9ncmFtSWQ6IFBST0dSQU1fSUQsXHJcbiAgICAgICAgZGF0YTogZnVsbEluc3RydWN0aW9uRGF0YSxcclxuICAgICAgfSlcclxuXHJcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKGluc3RydWN0aW9uKVxyXG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIGNvbm5lY3Rpb24pXHJcblxyXG4gICAgICBhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbihzaWduYXR1cmUsICdwcm9jZXNzZWQnKVxyXG4gICAgICB0b2FzdC5zdWNjZXNzKCdQcm9maWxlIGZvbGxvd2VkIScpXHJcbiAgICAgIHJldHVybiBzaWduYXR1cmVcclxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRm9sbG93IGVycm9yOicsIGVycm9yKVxyXG4gICAgICB0b2FzdC5lcnJvcignRmFpbGVkIHRvIGZvbGxvdyBwcm9maWxlJylcclxuICAgICAgdGhyb3cgZXJyb3JcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFVuZm9sbG93IFByb2ZpbGVcclxuICBjb25zdCB1bmZvbGxvd1Byb2ZpbGUgPSBhc3luYyAocHJvZmlsZVB1YmxpY0tleTogUHVibGljS2V5KSA9PiB7XHJcbiAgICBpZiAoIXB1YmxpY0tleSkgdGhyb3cgbmV3IEVycm9yKCdXYWxsZXQgbm90IGNvbm5lY3RlZCcpXHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ/CfkaUgVW5mb2xsb3dpbmcgcHJvZmlsZTonLCBwcm9maWxlUHVibGljS2V5LnRvU3RyaW5nKCkpXHJcblxyXG4gICAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSBuZXcgRm9sbG93UHJvZmlsZUluc3RydWN0aW9uKHtcclxuICAgICAgICBwcm9maWxlX2lkOiBwcm9maWxlUHVibGljS2V5LFxyXG4gICAgICB9KVxyXG5cclxuICAgICAgY29uc3QgdW5mb2xsb3dQcm9maWxlVmFyaWFudCA9IEJ1ZmZlci5mcm9tKFs2XSkgLy8gVW5mb2xsb3dQcm9maWxlIGVudW0gaW5kZXhcclxuICAgICAgY29uc3Qgc2VyaWFsaXplZERhdGEgPSBzZXJpYWxpemUoZm9sbG93UHJvZmlsZVNjaGVtYSwgaW5zdHJ1Y3Rpb25EYXRhKVxyXG4gICAgICBjb25zdCBmdWxsSW5zdHJ1Y3Rpb25EYXRhID0gQnVmZmVyLmNvbmNhdChbdW5mb2xsb3dQcm9maWxlVmFyaWFudCwgQnVmZmVyLmZyb20oc2VyaWFsaXplZERhdGEpXSlcclxuXHJcbiAgICAgIGNvbnN0IGluc3RydWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xyXG4gICAgICAgIGtleXM6IFtcclxuICAgICAgICAgIHsgcHVia2V5OiBwdWJsaWNLZXksIGlzU2lnbmVyOiB0cnVlLCBpc1dyaXRhYmxlOiBmYWxzZSB9LCAvLyBGb2xsb3dlciBhY2NvdW50XHJcbiAgICAgICAgICB7IHB1YmtleTogcHJvZmlsZVB1YmxpY0tleSwgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiB0cnVlIH0sIC8vIFByb2ZpbGUgdG8gdW5mb2xsb3dcclxuICAgICAgICBdLFxyXG4gICAgICAgIHByb2dyYW1JZDogUFJPR1JBTV9JRCxcclxuICAgICAgICBkYXRhOiBmdWxsSW5zdHJ1Y3Rpb25EYXRhLFxyXG4gICAgICB9KVxyXG5cclxuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoaW5zdHJ1Y3Rpb24pXHJcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgY29ubmVjdGlvbilcclxuXHJcbiAgICAgIGF3YWl0IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHNpZ25hdHVyZSwgJ3Byb2Nlc3NlZCcpXHJcbiAgICAgIHRvYXN0LnN1Y2Nlc3MoJ1Byb2ZpbGUgdW5mb2xsb3dlZCEnKVxyXG4gICAgICByZXR1cm4gc2lnbmF0dXJlXHJcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuZm9sbG93IGVycm9yOicsIGVycm9yKVxyXG4gICAgICB0b2FzdC5lcnJvcignRmFpbGVkIHRvIHVuZm9sbG93IHByb2ZpbGUnKVxyXG4gICAgICB0aHJvdyBlcnJvclxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gVXBkYXRlIFByb2ZpbGVcclxuICBjb25zdCB1cGRhdGVQcm9maWxlID0gYXN5bmMgKFxyXG4gICAgdXNlcm5hbWU6IHN0cmluZyxcclxuICAgIGJpbzogc3RyaW5nLFxyXG4gICAgcHJvZmlsZUltYWdlOiBzdHJpbmcsXHJcbiAgICBjb3ZlckltYWdlOiBzdHJpbmdcclxuICApID0+IHtcclxuICAgIGlmICghcHVibGljS2V5KSB0aHJvdyBuZXcgRXJyb3IoJ1dhbGxldCBub3QgY29ubmVjdGVkJylcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+UhCBVcGRhdGluZyBwcm9maWxlOicsIHVzZXJuYW1lKVxyXG4gICAgICBcclxuICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0gbmV3IENyZWF0ZVByb2ZpbGVJbnN0cnVjdGlvbih7XHJcbiAgICAgICAgdXNlcm5hbWUsXHJcbiAgICAgICAgYmlvLFxyXG4gICAgICAgIHByb2ZpbGVfaW1hZ2U6IHByb2ZpbGVJbWFnZSxcclxuICAgICAgICBjb3Zlcl9pbWFnZTogY292ZXJJbWFnZSxcclxuICAgICAgfSlcclxuXHJcbiAgICAgIGNvbnN0IHVwZGF0ZVByb2ZpbGVWYXJpYW50ID0gQnVmZmVyLmZyb20oWzFdKSAvLyBVcGRhdGVQcm9maWxlIGVudW0gaW5kZXggKHNhbWUgYXMgQ3JlYXRlUHJvZmlsZSlcclxuICAgICAgY29uc3Qgc2VyaWFsaXplZERhdGEgPSBzZXJpYWxpemUoY3JlYXRlUHJvZmlsZVNjaGVtYSwgaW5zdHJ1Y3Rpb25EYXRhKVxyXG4gICAgICBjb25zdCBmdWxsSW5zdHJ1Y3Rpb25EYXRhID0gQnVmZmVyLmNvbmNhdChbdXBkYXRlUHJvZmlsZVZhcmlhbnQsIEJ1ZmZlci5mcm9tKHNlcmlhbGl6ZWREYXRhKV0pXHJcblxyXG4gICAgICBjb25zdCBpbnN0cnVjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcclxuICAgICAgICBrZXlzOiBbXHJcbiAgICAgICAgICB7IHB1YmtleTogcHVibGljS2V5LCBpc1NpZ25lcjogdHJ1ZSwgaXNXcml0YWJsZTogdHJ1ZSB9LCAvLyBQcm9maWxlIG93bmVyIGFjY291bnRcclxuICAgICAgICBdLFxyXG4gICAgICAgIHByb2dyYW1JZDogUFJPR1JBTV9JRCxcclxuICAgICAgICBkYXRhOiBmdWxsSW5zdHJ1Y3Rpb25EYXRhLFxyXG4gICAgICB9KVxyXG5cclxuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoaW5zdHJ1Y3Rpb24pXHJcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgY29ubmVjdGlvbilcclxuXHJcbiAgICAgIGF3YWl0IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHNpZ25hdHVyZSwgJ3Byb2Nlc3NlZCcpXHJcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgUHJvZmlsZSB1cGRhdGVkIHN1Y2Nlc3NmdWxseSEnKVxyXG4gICAgICBcclxuICAgICAgLy8gQ2xlYXIgY2FjaGUgdG8gZm9yY2UgcmVmcmVzaFxyXG4gICAgICBwcm9maWxlQ2FjaGUuZGVsZXRlKHB1YmxpY0tleS50b1N0cmluZygpKVxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHNpZ25hdHVyZVxyXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgVXBkYXRlIHByb2ZpbGUgZXJyb3I6JywgZXJyb3IpXHJcbiAgICAgIHRocm93IGVycm9yXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBVdGlsaXR5IGZ1bmN0aW9uIHRvIHByZWxvYWQgcHJvZmlsZSBvbiB3YWxsZXQgY29ubmVjdGlvblxyXG4gIGNvbnN0IHByZWxvYWRQcm9maWxlID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgaWYgKCFwdWJsaWNLZXkpIHJldHVyblxyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygn8J+agCBQcmVsb2FkaW5nIHByb2ZpbGUgb24gd2FsbGV0IGNvbm5lY3Rpb24uLi4nKVxyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgZ2V0UHJvZmlsZShwdWJsaWNLZXkpXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBwcmVsb2FkIHByb2ZpbGU6JywgZXJyb3IpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgY3JlYXRlUHJvZmlsZSxcclxuICAgIGNyZWF0ZVBvc3QsXHJcbiAgICBsaWtlUG9zdCxcclxuICAgIGdldFByb2ZpbGUsXHJcbiAgICBnZXRQcm9maWxlQnlVc2VybmFtZSxcclxuICAgIGdldFBvc3RzLFxyXG4gICAgZ2V0UHJvZmlsZVBEQSxcclxuICAgIGdldFBvc3RQREEsXHJcbiAgICBjaGVja1Byb2ZpbGVBdFBEQSxcclxuICAgIHByZWxvYWRQcm9maWxlLFxyXG4gICAgY2xlYXJQcm9maWxlQ2FjaGUsXHJcbiAgICBjcmVhdGVDb21tdW5pdHksXHJcbiAgICBmb2xsb3dQcm9maWxlLFxyXG4gICAgdW5mb2xsb3dQcm9maWxlLFxyXG4gICAgdXBkYXRlUHJvZmlsZSxcclxuICB9XHJcbn0iXSwibmFtZXMiOlsidXNlQ29ubmVjdGlvbiIsInVzZVdhbGxldCIsIlB1YmxpY0tleSIsIlRyYW5zYWN0aW9uIiwiVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiIsIlN5c3RlbVByb2dyYW0iLCJMQU1QT1JUU19QRVJfU09MIiwiS2V5cGFpciIsInNlcmlhbGl6ZSIsImRlc2VyaWFsaXplIiwidG9hc3QiLCJjb25maWciLCJQUk9HUkFNX0lEIiwic29sYW5hIiwicHJvZ3JhbUlkIiwiREVCVUdfTU9ERSIsInByb2Nlc3MiLCJDb250cmFjdEluc3RydWN0aW9uIiwiUG9zdFJhdGluZyIsIkNyZWF0ZVByb2ZpbGVJbnN0cnVjdGlvbiIsImNvbnN0cnVjdG9yIiwiZmllbGRzIiwidXNlcm5hbWUiLCJiaW8iLCJwcm9maWxlX2ltYWdlIiwiY292ZXJfaW1hZ2UiLCJDcmVhdGVQb3N0SW5zdHJ1Y3Rpb24iLCJjb250ZW50IiwiaW1hZ2VzIiwiTGlrZVBvc3RJbnN0cnVjdGlvbiIsInBvc3RfaWQiLCJQcm9maWxlQWNjb3VudCIsImlzX2luaXRpYWxpemVkIiwib3duZXIiLCJjcmVhdGVkX2F0IiwiZm9sbG93ZXJzX2NvdW50IiwiZm9sbG93aW5nX2NvdW50IiwidXNlcl9jcmVkaXRfcmF0aW5nIiwicG9zdHNfY291bnQiLCJsYXN0X3Bvc3RfdGltZXN0YW1wIiwiZGFpbHlfcG9zdF9jb3VudCIsImlzX3ZlcmlmaWVkIiwiUG9zdEFjY291bnQiLCJpZCIsImF1dGhvciIsInRpbWVzdGFtcCIsImxpa2VzIiwiY29tbWVudHMiLCJtaXJyb3JzIiwicmF0aW5nIiwiaW5fa2lsbF96b25lIiwiY3JlYXRlUHJvZmlsZVNjaGVtYSIsIk1hcCIsImtpbmQiLCJjcmVhdGVQb3N0U2NoZW1hIiwibGlrZVBvc3RTY2hlbWEiLCJwcm9maWxlQWNjb3VudFNjaGVtYSIsInBvc3RBY2NvdW50U2NoZW1hIiwiQ29tbXVuaXR5QWNjb3VudCIsImNyZWF0b3IiLCJuYW1lIiwiZGVzY3JpcHRpb24iLCJhdmF0YXIiLCJydWxlcyIsIm1lbWJlcl9jb3VudCIsImlzX3ByaXZhdGUiLCJDcmVhdGVDb21tdW5pdHlJbnN0cnVjdGlvbiIsIkZvbGxvd1Byb2ZpbGVJbnN0cnVjdGlvbiIsInByb2ZpbGVfaWQiLCJ0b0J1ZmZlciIsImNyZWF0ZUNvbW11bml0eVNjaGVtYSIsImZvbGxvd1Byb2ZpbGVTY2hlbWEiLCJjb21tdW5pdHlBY2NvdW50U2NoZW1hIiwicHJvZmlsZUNhY2hlIiwiQ0FDSEVfRFVSQVRJT04iLCJwb3N0c0NhY2hlIiwiUE9TVFNfQ0FDSEVfRFVSQVRJT04iLCJMT0NBTFNUT1JBR0VfQ0FDSEVfUFJFRklYIiwiTE9DQUxTVE9SQUdFX0NBQ0hFX0RVUkFUSU9OIiwic2F2ZVByb2ZpbGVUb0xvY2FsU3RvcmFnZSIsIndhbGxldEFkZHJlc3MiLCJwcm9maWxlIiwiY2FjaGVLZXkiLCJjYWNoZURhdGEiLCJEYXRlIiwibm93IiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJjb25zb2xlIiwibG9nIiwic2xpY2UiLCJlcnJvciIsIndhcm4iLCJnZXRQcm9maWxlRnJvbUxvY2FsU3RvcmFnZSIsImNhY2hlZCIsImdldEl0ZW0iLCJwYXJzZSIsInJlbW92ZUl0ZW0iLCJjbGVhclByb2ZpbGVDYWNoZSIsImRlbGV0ZSIsImNsZWFyIiwia2V5cyIsIk9iamVjdCIsImZvckVhY2giLCJrZXkiLCJzdGFydHNXaXRoIiwidXNlQmxvY2tzUHJvZ3JhbSIsImNvbm5lY3Rpb24iLCJwdWJsaWNLZXkiLCJzZW5kVHJhbnNhY3Rpb24iLCJnZXRQcm9maWxlUERBIiwidXNlclB1YmxpY0tleSIsInByb2ZpbGVQREEiLCJmaW5kUHJvZ3JhbUFkZHJlc3MiLCJCdWZmZXIiLCJmcm9tIiwiZ2V0UG9zdFBEQSIsInBvc3RJZCIsInBvc3RQREEiLCJ0b1N0cmluZyIsImNoZWNrUHJvZ3JhbUV4aXN0cyIsInByb2dyYW1JbmZvIiwiZ2V0QWNjb3VudEluZm8iLCJleGVjdXRhYmxlIiwiY2hlY2tTT0xCYWxhbmNlIiwiYmFsYW5jZSIsImdldEJhbGFuY2UiLCJjb252ZXJ0UHJvZmlsZUFjY291bnQiLCJwcm9maWxlQWNjb3VudCIsImNhbGN1bGF0ZVVDUiIsInBvc3RzQ291bnQiLCJOdW1iZXIiLCJmb2xsb3dlcnNDb3VudCIsImZvbGxvd2luZ0NvdW50IiwidWNyIiwicG9zdHNTY29yZSIsIk1hdGgiLCJtaW4iLCJmb2xsb3dlcnNTY29yZSIsInJhdGlvQm9udXMiLCJyYXRpbyIsImFjY291bnRBZ2UiLCJkYXlzT2xkIiwiYWdlQm9udXMiLCJ2ZXJpZmljYXRpb25Cb251cyIsImxhc3RQb3N0QWdlIiwiZGF5c1NpbmNlTGFzdFBvc3QiLCJhY3Rpdml0eUJvbnVzIiwiaXNJbml0aWFsaXplZCIsInByb2ZpbGVJbWFnZSIsImNvdmVySW1hZ2UiLCJjcmVhdGVkQXQiLCJ1c2VyQ3JlZGl0UmF0aW5nIiwibGFzdFBvc3RUaW1lc3RhbXAiLCJkYWlseVBvc3RDb3VudCIsImlzVmVyaWZpZWQiLCJjb252ZXJ0UG9zdEFjY291bnQiLCJwb3N0QWNjb3VudCIsImluS2lsbFpvbmUiLCJjcmVhdGVQcm9maWxlIiwiRXJyb3IiLCJwcm9ncmFtRXhpc3RzIiwibmV0d29yayIsImluc3RydWN0aW9uRGF0YSIsImNyZWF0ZVByb2ZpbGVWYXJpYW50Iiwic2VyaWFsaXplZERhdGEiLCJmdWxsSW5zdHJ1Y3Rpb25EYXRhIiwiY29uY2F0IiwiaW5zdHJ1Y3Rpb24iLCJwdWJrZXkiLCJpc1NpZ25lciIsImlzV3JpdGFibGUiLCJkYXRhIiwidHJhbnNhY3Rpb24iLCJhZGQiLCJibG9ja2hhc2giLCJnZXRMYXRlc3RCbG9ja2hhc2giLCJyZWNlbnRCbG9ja2hhc2giLCJmZWVQYXllciIsInNpbXVsYXRpb24iLCJzaW11bGF0ZVRyYW5zYWN0aW9uIiwidmFsdWUiLCJlcnIiLCJzaWduYXR1cmUiLCJza2lwUHJlZmxpZ2h0IiwicHJlZmxpZ2h0Q29tbWl0bWVudCIsIm1heFJldHJpZXMiLCJjb25maXJtVHJhbnNhY3Rpb24iLCJsYXN0VmFsaWRCbG9ja0hlaWdodCIsInN1Y2Nlc3MiLCJtZXNzYWdlIiwiZ2V0UHJvZmlsZSIsImNhY2hlZFByb2ZpbGUiLCJzZXQiLCJzZXRUaW1lb3V0IiwiaGFzIiwiZ2V0IiwiYWNjb3VudHMiLCJnZXRQcm9ncmFtQWNjb3VudHMiLCJsZW5ndGgiLCJwcm9maWxlc0ZvdW5kIiwiYWNjb3VudCIsIm1hbnVhbFBhcnNlUHJvZmlsZSIsImFjY291bnRPd25lciIsImVxdWFscyIsImdldFByb2ZpbGVCeVVzZXJuYW1lIiwiYWNjb3VudEluZm8iLCJnZXRQb3N0cyIsInBvc3RzIiwibWFudWFsUGFyc2VQb3N0IiwicG9zdCIsInB1c2giLCJzdWJzdHJpbmciLCJzb3J0IiwiYSIsImIiLCJjcmVhdGVQb3N0IiwidXNlclByb2ZpbGUiLCJwb3N0S2V5cGFpciIsImdlbmVyYXRlIiwidXNlclByb2ZpbGVQREEiLCJjcmVhdGVQb3N0VmFyaWFudCIsIm1hcCIsImsiLCJwYXJ0aWFsU2lnbiIsInNpZ25lcnMiLCJpbmNsdWRlcyIsInRvRml4ZWQiLCJsaWtlUG9zdCIsInBvc3RBdXRob3IiLCJwb3N0QWNjb3VudEFkZHJlc3MiLCJwYXJzZWRQb3N0IiwiQmlnSW50IiwibGlrZVBvc3RWYXJpYW50IiwiY2hlY2tQcm9maWxlQXRQREEiLCJwZGFBZGRyZXNzIiwicGRhIiwiQXJyYXkiLCJvZmZzZXQiLCJ1c2VybmFtZUxlbmd0aCIsInJlYWRVSW50MzJMRSIsImJpb0xlbmd0aCIsInByb2ZpbGVJbWFnZUxlbmd0aCIsImNvdmVySW1hZ2VMZW5ndGgiLCJyZWFkQmlnVUludDY0TEUiLCJyZWFkQmlnSW50NjRMRSIsIlVpbnQ4QXJyYXkiLCJjb250ZW50TGVuZ3RoIiwiaW1hZ2VzTGVuZ3RoIiwiaSIsImltYWdlTGVuZ3RoIiwiaW1hZ2UiLCJjb252ZXJ0Q29tbXVuaXR5QWNjb3VudCIsImNvbW11bml0eUFjY291bnQiLCJtZW1iZXJDb3VudCIsImlzUHJpdmF0ZSIsImNyZWF0ZUNvbW11bml0eSIsImNvbW11bml0eUtleXBhaXIiLCJjcmVhdGVDb21tdW5pdHlWYXJpYW50IiwiZm9sbG93UHJvZmlsZSIsInByb2ZpbGVQdWJsaWNLZXkiLCJmb2xsb3dQcm9maWxlVmFyaWFudCIsInVuZm9sbG93UHJvZmlsZSIsInVuZm9sbG93UHJvZmlsZVZhcmlhbnQiLCJ1cGRhdGVQcm9maWxlIiwidXBkYXRlUHJvZmlsZVZhcmlhbnQiLCJwcmVsb2FkUHJvZmlsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useBlocksProgram.ts\n"));

/***/ })

});