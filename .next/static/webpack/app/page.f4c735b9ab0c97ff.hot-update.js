"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/useBlocksProgram.ts":
/*!***********************************!*\
  !*** ./hooks/useBlocksProgram.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PostRating: function() { return /* binding */ PostRating; },\n/* harmony export */   useBlocksProgram: function() { return /* binding */ useBlocksProgram; }\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/wallet-adapter-react */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/useConnection.js\");\n/* harmony import */ var _solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @solana/wallet-adapter-react */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/useWallet.js\");\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n/* harmony import */ var borsh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! borsh */ \"(app-pages-browser)/./node_modules/borsh/lib/index.js\");\n/* harmony import */ var borsh__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(borsh__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_hot_toast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-hot-toast */ \"(app-pages-browser)/./node_modules/react-hot-toast/dist/index.mjs\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/config */ \"(app-pages-browser)/./config/index.ts\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\n\n\n\n// Your deployed program ID - configured from environment\nconst PROGRAM_ID = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(_config__WEBPACK_IMPORTED_MODULE_3__.config.solana.programId);\n// Add debug mode for testing without actual blockchain transactions\nconst DEBUG_MODE = \"development\" === \"development\";\nvar ContractInstruction;\n// Instruction enum matching your Rust contract\n(function(ContractInstruction) {\n    ContractInstruction[ContractInstruction[\"CreateProfile\"] = 0] = \"CreateProfile\";\n    ContractInstruction[ContractInstruction[\"UpdateProfile\"] = 1] = \"UpdateProfile\";\n    ContractInstruction[ContractInstruction[\"CreatePost\"] = 2] = \"CreatePost\";\n    ContractInstruction[ContractInstruction[\"LikePost\"] = 3] = \"LikePost\";\n    ContractInstruction[ContractInstruction[\"CommentOnPost\"] = 4] = \"CommentOnPost\";\n    ContractInstruction[ContractInstruction[\"FollowProfile\"] = 5] = \"FollowProfile\";\n    ContractInstruction[ContractInstruction[\"UnfollowProfile\"] = 6] = \"UnfollowProfile\";\n    ContractInstruction[ContractInstruction[\"CreateCommunity\"] = 7] = \"CreateCommunity\";\n    ContractInstruction[ContractInstruction[\"JoinCommunity\"] = 8] = \"JoinCommunity\";\n})(ContractInstruction || (ContractInstruction = {}));\nvar PostRating;\n(function(PostRating) {\n    PostRating[PostRating[\"None\"] = 0] = \"None\";\n    PostRating[PostRating[\"Bronze\"] = 1] = \"Bronze\";\n    PostRating[PostRating[\"Silver\"] = 2] = \"Silver\";\n    PostRating[PostRating[\"Gold\"] = 3] = \"Gold\";\n    PostRating[PostRating[\"Platinum\"] = 4] = \"Platinum\";\n    PostRating[PostRating[\"Diamond\"] = 5] = \"Diamond\";\n    PostRating[PostRating[\"Ace\"] = 6] = \"Ace\";\n    PostRating[PostRating[\"Conqueror\"] = 7] = \"Conqueror\";\n})(PostRating || (PostRating = {}));\n// Create Profile instruction data class\nclass CreateProfileInstruction {\n    constructor(fields){\n        this.username = fields.username;\n        this.bio = fields.bio;\n        this.profile_image = fields.profile_image;\n        this.cover_image = fields.cover_image;\n    }\n}\n// Create Post instruction data class\nclass CreatePostInstruction {\n    constructor(fields){\n        this.content = fields.content;\n        this.images = fields.images;\n    }\n}\n// Like Post instruction data class\nclass LikePostInstruction {\n    constructor(fields){\n        this.post_id = fields.post_id;\n    }\n}\n// Comment On Post instruction data class\nclass CommentOnPostInstruction {\n    constructor(fields){\n        this.content = fields.content;\n        this.parent_id = fields.parent_id;\n    }\n}\n// Bookmark Post instruction data class\nclass BookmarkPostInstruction {\n    constructor(fields){\n        this.post_id = fields.post_id;\n    }\n}\n// Profile struct for deserialization - matching Rust exactly\nclass ProfileAccount {\n    constructor(fields){\n        this.is_initialized = fields.is_initialized;\n        this.owner = fields.owner;\n        this.username = fields.username;\n        this.bio = fields.bio;\n        this.profile_image = fields.profile_image;\n        this.cover_image = fields.cover_image;\n        this.created_at = fields.created_at;\n        this.followers_count = fields.followers_count;\n        this.following_count = fields.following_count;\n        this.user_credit_rating = fields.user_credit_rating;\n        this.posts_count = fields.posts_count;\n        this.last_post_timestamp = fields.last_post_timestamp;\n        this.daily_post_count = fields.daily_post_count;\n        this.is_verified = fields.is_verified;\n    }\n}\n// Post struct for deserialization - matching Rust exactly\nclass PostAccount {\n    constructor(fields){\n        this.is_initialized = fields.is_initialized;\n        this.id = fields.id;\n        this.author = fields.author;\n        this.content = fields.content;\n        this.timestamp = fields.timestamp;\n        this.likes = fields.likes;\n        this.comments = fields.comments;\n        this.mirrors = fields.mirrors;\n        this.images = fields.images;\n        this.rating = fields.rating;\n        this.in_kill_zone = fields.in_kill_zone;\n    }\n}\n// Borsh schemas\nconst createProfileSchema = new Map([\n    [\n        CreateProfileInstruction,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"username\",\n                    \"string\"\n                ],\n                [\n                    \"bio\",\n                    \"string\"\n                ],\n                [\n                    \"profile_image\",\n                    \"string\"\n                ],\n                [\n                    \"cover_image\",\n                    \"string\"\n                ]\n            ]\n        }\n    ]\n]);\nconst createPostSchema = new Map([\n    [\n        CreatePostInstruction,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"content\",\n                    \"string\"\n                ],\n                [\n                    \"images\",\n                    [\n                        \"string\"\n                    ]\n                ]\n            ]\n        }\n    ]\n]);\nconst likePostSchema = new Map([\n    [\n        LikePostInstruction,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"post_id\",\n                    \"u64\"\n                ]\n            ]\n        }\n    ]\n]);\nconst commentOnPostSchema = new Map([\n    [\n        CommentOnPostInstruction,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"content\",\n                    \"string\"\n                ],\n                [\n                    \"parent_id\",\n                    \"u64\"\n                ]\n            ]\n        }\n    ]\n]);\nconst bookmarkPostSchema = new Map([\n    [\n        BookmarkPostInstruction,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"post_id\",\n                    \"u64\"\n                ]\n            ]\n        }\n    ]\n]);\nconst profileAccountSchema = new Map([\n    [\n        ProfileAccount,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"is_initialized\",\n                    \"u8\"\n                ],\n                [\n                    \"owner\",\n                    [\n                        32\n                    ]\n                ],\n                [\n                    \"username\",\n                    \"string\"\n                ],\n                [\n                    \"bio\",\n                    \"string\"\n                ],\n                [\n                    \"profile_image\",\n                    \"string\"\n                ],\n                [\n                    \"cover_image\",\n                    \"string\"\n                ],\n                [\n                    \"created_at\",\n                    \"u64\"\n                ],\n                [\n                    \"followers_count\",\n                    \"u64\"\n                ],\n                [\n                    \"following_count\",\n                    \"u64\"\n                ],\n                [\n                    \"user_credit_rating\",\n                    \"i64\"\n                ],\n                [\n                    \"posts_count\",\n                    \"u64\"\n                ],\n                [\n                    \"last_post_timestamp\",\n                    \"u64\"\n                ],\n                [\n                    \"daily_post_count\",\n                    \"u64\"\n                ],\n                [\n                    \"is_verified\",\n                    \"u8\"\n                ]\n            ]\n        }\n    ]\n]);\nconst postAccountSchema = new Map([\n    [\n        PostAccount,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"is_initialized\",\n                    \"u8\"\n                ],\n                [\n                    \"id\",\n                    \"u64\"\n                ],\n                [\n                    \"author\",\n                    [\n                        32\n                    ]\n                ],\n                [\n                    \"content\",\n                    \"string\"\n                ],\n                [\n                    \"timestamp\",\n                    \"u64\"\n                ],\n                [\n                    \"likes\",\n                    \"u64\"\n                ],\n                [\n                    \"comments\",\n                    \"u64\"\n                ],\n                [\n                    \"mirrors\",\n                    \"u64\"\n                ],\n                [\n                    \"images\",\n                    [\n                        \"string\"\n                    ]\n                ],\n                [\n                    \"rating\",\n                    \"u8\"\n                ],\n                [\n                    \"in_kill_zone\",\n                    \"u8\"\n                ]\n            ]\n        }\n    ]\n]);\n// Community struct for deserialization\nclass CommunityAccount {\n    constructor(fields){\n        this.is_initialized = fields.is_initialized;\n        this.id = fields.id;\n        this.creator = fields.creator;\n        this.name = fields.name;\n        this.description = fields.description;\n        this.avatar = fields.avatar;\n        this.rules = fields.rules;\n        this.member_count = fields.member_count;\n        this.created_at = fields.created_at;\n        this.is_private = fields.is_private;\n    }\n}\n// Create Community instruction\nclass CreateCommunityInstruction {\n    constructor(fields){\n        this.name = fields.name;\n        this.description = fields.description;\n        this.avatar = fields.avatar;\n        this.rules = fields.rules;\n    }\n}\n// Follow Profile instruction\nclass FollowProfileInstruction {\n    constructor(fields){\n        this.profile_id = fields.profile_id.toBuffer();\n    }\n}\nconst createCommunitySchema = new Map([\n    [\n        CreateCommunityInstruction,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"name\",\n                    \"string\"\n                ],\n                [\n                    \"description\",\n                    \"string\"\n                ],\n                [\n                    \"avatar\",\n                    \"string\"\n                ],\n                [\n                    \"rules\",\n                    [\n                        \"string\"\n                    ]\n                ]\n            ]\n        }\n    ]\n]);\nconst followProfileSchema = new Map([\n    [\n        FollowProfileInstruction,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"profile_id\",\n                    [\n                        32\n                    ]\n                ]\n            ]\n        }\n    ]\n]);\nconst communityAccountSchema = new Map([\n    [\n        CommunityAccount,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"is_initialized\",\n                    \"u8\"\n                ],\n                [\n                    \"id\",\n                    \"u64\"\n                ],\n                [\n                    \"creator\",\n                    [\n                        32\n                    ]\n                ],\n                [\n                    \"name\",\n                    \"string\"\n                ],\n                [\n                    \"description\",\n                    \"string\"\n                ],\n                [\n                    \"avatar\",\n                    \"string\"\n                ],\n                [\n                    \"rules\",\n                    [\n                        \"string\"\n                    ]\n                ],\n                [\n                    \"member_count\",\n                    \"u64\"\n                ],\n                [\n                    \"created_at\",\n                    \"u64\"\n                ],\n                [\n                    \"is_private\",\n                    \"u8\"\n                ]\n            ]\n        }\n    ]\n]);\n// Cache for profile lookups to avoid repeated blockchain calls\nconst profileCache = new Map();\nconst CACHE_DURATION = 60000 // 1 minute for memory cache (increased from 30 seconds)\n;\n// Posts cache\nlet postsCache = null;\nconst POSTS_CACHE_DURATION = 30000 // 30 seconds for posts cache (increased from 10 seconds)\n;\n// localStorage cache configuration - Updated to support multiple profiles\nconst LOCALSTORAGE_CACHE_PREFIX = \"blocks_profile_\";\nconst LOCALSTORAGE_CACHE_DURATION = 10 * 60 * 1000 // 10 minutes for localStorage cache (increased from 5 minutes)\n;\n// localStorage cache utilities - Updated to support multiple profiles\nconst saveProfileToLocalStorage = (walletAddress, profile)=>{\n    try {\n        const cacheKey = \"\".concat(LOCALSTORAGE_CACHE_PREFIX).concat(walletAddress);\n        const cacheData = {\n            profile,\n            timestamp: Date.now(),\n            walletAddress\n        };\n        localStorage.setItem(cacheKey, JSON.stringify(cacheData));\n        console.log(\"\\uD83D\\uDCBE Profile cached to localStorage for \".concat(walletAddress.slice(0, 8)));\n    } catch (error) {\n        console.warn(\"Failed to save profile to localStorage:\", error);\n    }\n};\nconst getProfileFromLocalStorage = (walletAddress)=>{\n    try {\n        const cacheKey = \"\".concat(LOCALSTORAGE_CACHE_PREFIX).concat(walletAddress);\n        const cached = localStorage.getItem(cacheKey);\n        if (!cached) return null;\n        const cacheData = JSON.parse(cached);\n        // Check if cache is expired\n        if (Date.now() - cacheData.timestamp > LOCALSTORAGE_CACHE_DURATION) {\n            console.log(\"⏰ Cache expired for \".concat(walletAddress.slice(0, 8), \", clearing\"));\n            localStorage.removeItem(cacheKey);\n            return null;\n        }\n        console.log(\"⚡ Using cached profile from localStorage for \".concat(walletAddress.slice(0, 8)));\n        return cacheData.profile;\n    } catch (error) {\n        console.warn(\"Failed to read profile from localStorage:\", error);\n        const cacheKey = \"\".concat(LOCALSTORAGE_CACHE_PREFIX).concat(walletAddress);\n        localStorage.removeItem(cacheKey);\n        return null;\n    }\n};\nconst clearProfileCache = (walletAddress)=>{\n    // Clear memory cache\n    if (walletAddress) {\n        profileCache.delete(walletAddress);\n        // Clear localStorage cache for specific user\n        const cacheKey = \"\".concat(LOCALSTORAGE_CACHE_PREFIX).concat(walletAddress);\n        localStorage.removeItem(cacheKey);\n    } else {\n        profileCache.clear();\n        // Clear all localStorage profile caches\n        const keys = Object.keys(localStorage);\n        keys.forEach((key)=>{\n            if (key.startsWith(LOCALSTORAGE_CACHE_PREFIX)) {\n                localStorage.removeItem(key);\n            }\n        });\n    }\n    // Clear posts cache\n    postsCache = null;\n    console.log(\"\\uD83D\\uDDD1️ Profile and posts cache cleared\");\n};\nfunction useBlocksProgram() {\n    const { connection } = (0,_solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_4__.useConnection)();\n    const { publicKey, sendTransaction } = (0,_solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_5__.useWallet)();\n    // Get profile PDA\n    const getProfilePDA = async (userPublicKey, username)=>{\n        const [profilePDA] = await _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey.findProgramAddress([\n            userPublicKey.toBuffer(),\n            Buffer.from(\"profile\"),\n            Buffer.from(username)\n        ], PROGRAM_ID);\n        return profilePDA;\n    };\n    // Get post PDA\n    const getPostPDA = async (userPublicKey, postId)=>{\n        const [postPDA] = await _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey.findProgramAddress([\n            userPublicKey.toBuffer(),\n            Buffer.from(\"post\"),\n            Buffer.from(postId.toString())\n        ], PROGRAM_ID);\n        return postPDA;\n    };\n    // Helper function to check if program exists\n    const checkProgramExists = async ()=>{\n        try {\n            const programInfo = await connection.getAccountInfo(PROGRAM_ID);\n            return programInfo !== null && programInfo.executable;\n        } catch (error) {\n            console.error(\"Error checking program existence:\", error);\n            return false;\n        }\n    };\n    // Helper function to check SOL balance\n    const checkSOLBalance = async ()=>{\n        if (!publicKey) return 0;\n        try {\n            const balance = await connection.getBalance(publicKey);\n            return balance / _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.LAMPORTS_PER_SOL;\n        } catch (error) {\n            console.error(\"Error checking SOL balance:\", error);\n            return 0;\n        }\n    };\n    // Convert ProfileAccount to Profile interface\n    const convertProfileAccount = (profileAccount)=>{\n        // Calculate UCR based on activity\n        const calculateUCR = (profile)=>{\n            const postsCount = Number(profile.posts_count);\n            const followersCount = Number(profile.followers_count);\n            const followingCount = Number(profile.following_count);\n            // Base UCR calculation algorithm\n            let ucr = 1.0 // Start with base rating\n            ;\n            // Posts factor (0.1 points per post, max 2.0 points)\n            const postsScore = Math.min(postsCount * 0.1, 2.0);\n            // Followers factor (0.05 points per follower, max 1.5 points)\n            const followersScore = Math.min(followersCount * 0.05, 1.5);\n            // Following/followers ratio (healthy ratio = bonus)\n            let ratioBonus = 0;\n            if (followersCount > 0 && followingCount > 0) {\n                const ratio = followersCount / followingCount;\n                if (ratio >= 0.5 && ratio <= 2.0) {\n                    ratioBonus = 0.3;\n                }\n            }\n            // Account age factor (older accounts get bonus)\n            const accountAge = Date.now() - Number(profile.created_at) * 1000;\n            const daysOld = accountAge / (1000 * 60 * 60 * 24);\n            const ageBonus = Math.min(daysOld / 30 * 0.2, 1.0) // 0.2 points per month, max 1.0\n            ;\n            // Verification bonus\n            const verificationBonus = profile.is_verified === 1 ? 0.5 : 0;\n            // Activity factor (posting regularly)\n            const lastPostAge = Date.now() - Number(profile.last_post_timestamp) * 1000;\n            const daysSinceLastPost = lastPostAge / (1000 * 60 * 60 * 24);\n            const activityBonus = daysSinceLastPost < 7 ? 0.3 : daysSinceLastPost < 30 ? 0.1 : 0;\n            ucr = ucr + postsScore + followersScore + ratioBonus + ageBonus + verificationBonus + activityBonus;\n            // Cap at 5.0 max\n            return Math.min(ucr, 5.0);\n        };\n        return {\n            isInitialized: profileAccount.is_initialized === 1,\n            owner: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(profileAccount.owner),\n            username: profileAccount.username,\n            bio: profileAccount.bio,\n            profileImage: profileAccount.profile_image,\n            coverImage: profileAccount.cover_image,\n            createdAt: Number(profileAccount.created_at) * 1000,\n            followersCount: Number(profileAccount.followers_count),\n            followingCount: Number(profileAccount.following_count),\n            userCreditRating: calculateUCR(profileAccount),\n            postsCount: Number(profileAccount.posts_count),\n            lastPostTimestamp: Number(profileAccount.last_post_timestamp) * 1000,\n            dailyPostCount: Number(profileAccount.daily_post_count),\n            isVerified: profileAccount.is_verified === 1\n        };\n    };\n    // Convert PostAccount to Post interface\n    const convertPostAccount = (postAccount)=>{\n        return {\n            isInitialized: postAccount.is_initialized === 1,\n            id: Number(postAccount.id),\n            author: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(postAccount.author),\n            content: postAccount.content,\n            timestamp: Number(postAccount.timestamp) * 1000,\n            likes: Number(postAccount.likes),\n            comments: Number(postAccount.comments),\n            mirrors: Number(postAccount.mirrors),\n            images: postAccount.images,\n            rating: postAccount.rating,\n            inKillZone: postAccount.in_kill_zone === 1\n        };\n    };\n    // Create user profile - REAL IMPLEMENTATION\n    const createProfile = async (username, bio, profileImage, coverImage)=>{\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83D\\uDD0D Running pre-flight checks...\");\n            const balance = await checkSOLBalance();\n            console.log(\"\\uD83D\\uDCB0 SOL Balance: \".concat(balance));\n            if (balance < 0.1) {\n                throw new Error(\"Insufficient SOL balance: \".concat(balance, \". You need at least 0.1 SOL for transaction fees and account creation.\"));\n            }\n            const programExists = await checkProgramExists();\n            console.log(\"\\uD83D\\uDCCB Program exists: \".concat(programExists));\n            if (!programExists) {\n                throw new Error(\"Program not found at address: \".concat(PROGRAM_ID.toString(), \". Make sure the program is deployed on \").concat(_config__WEBPACK_IMPORTED_MODULE_3__.config.solana.network, \".\"));\n            }\n            console.log(\"✅ Pre-flight checks passed\");\n            const profilePDA = await getProfilePDA(publicKey, username);\n            console.log(\"\\uD83D\\uDCCD Profile PDA: \".concat(profilePDA.toString()));\n            const instructionData = new CreateProfileInstruction({\n                username,\n                bio,\n                profile_image: profileImage,\n                cover_image: coverImage\n            });\n            const createProfileVariant = Buffer.from([\n                0\n            ]);\n            const serializedData = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.serialize)(createProfileSchema, instructionData);\n            const fullInstructionData = Buffer.concat([\n                createProfileVariant,\n                Buffer.from(serializedData)\n            ]);\n            const instruction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: profilePDA,\n                        isSigner: false,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.SystemProgram.programId,\n                        isSigner: false,\n                        isWritable: false\n                    }\n                ],\n                programId: PROGRAM_ID,\n                data: fullInstructionData\n            });\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction().add(instruction);\n            const { blockhash } = await connection.getLatestBlockhash(\"processed\");\n            transaction.recentBlockhash = blockhash;\n            transaction.feePayer = publicKey;\n            const simulation = await connection.simulateTransaction(transaction);\n            if (simulation.value.err) {\n                throw new Error(\"Transaction simulation failed: \".concat(JSON.stringify(simulation.value.err)));\n            }\n            const signature = await sendTransaction(transaction, connection, {\n                skipPreflight: false,\n                preflightCommitment: \"processed\",\n                maxRetries: 3\n            });\n            await connection.confirmTransaction({\n                signature,\n                blockhash,\n                lastValidBlockHeight: (await connection.getLatestBlockhash()).lastValidBlockHeight\n            }, \"processed\");\n            // Invalidate cache after profile creation\n            clearProfileCache(publicKey.toString());\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.success(\"Profile created successfully!\");\n            return signature;\n        } catch (error) {\n            console.error(\"❌ Profile creation error:\", error);\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Transaction failed: \".concat(error.message || \"Unknown error\"));\n            throw error;\n        }\n    };\n    // Production-ready profile detection with localStorage caching - Improved for multiple users\n    const getProfile = async (userPublicKey)=>{\n        const cacheKey = userPublicKey.toString();\n        try {\n            // 1. Check localStorage cache first (fastest)\n            const cachedProfile = getProfileFromLocalStorage(cacheKey);\n            if (cachedProfile !== null) {\n                // Also update memory cache\n                profileCache.set(cacheKey, cachedProfile);\n                setTimeout(()=>profileCache.delete(cacheKey), CACHE_DURATION);\n                return cachedProfile;\n            }\n            // 2. Check memory cache\n            if (profileCache.has(cacheKey)) {\n                const cached = profileCache.get(cacheKey);\n                return cached !== null && cached !== void 0 ? cached : null;\n            }\n            // 3. Fetch from blockchain (slowest)\n            console.log(\"\\uD83D\\uDD0D Fetching profile from blockchain for: \".concat(userPublicKey.toString().slice(0, 8), \"...\"));\n            const accounts = await connection.getProgramAccounts(PROGRAM_ID);\n            console.log(\"\\uD83D\\uDCCA Found \".concat(accounts.length, \" program accounts to scan for profiles\"));\n            let profilesFound = 0;\n            // Scan through accounts to find user's profile\n            for (const { account, pubkey } of accounts){\n                try {\n                    if (account.data.length === 0) continue;\n                    // Try manual parsing first\n                    const profileAccount = manualParseProfile(account.data);\n                    if (!profileAccount) continue;\n                    profilesFound++;\n                    const accountOwner = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(profileAccount.owner);\n                    // Check if this profile belongs to the user we're looking for\n                    if (profileAccount.is_initialized === 1 && accountOwner.equals(userPublicKey)) {\n                        console.log('\\uD83C\\uDFAF FOUND PROFILE! Username: \"'.concat(profileAccount.username, '\" for ').concat(userPublicKey.toString().slice(0, 8)));\n                        console.log('\\uD83D\\uDCF8 Profile Image URL: \"'.concat(profileAccount.profile_image, '\"'));\n                        console.log('\\uD83D\\uDDBC️ Cover Image URL: \"'.concat(profileAccount.cover_image, '\"'));\n                        console.log(\"\\uD83D\\uDCCA Profile Data:\", {\n                            username: profileAccount.username,\n                            bio: profileAccount.bio,\n                            profileImage: profileAccount.profile_image,\n                            coverImage: profileAccount.cover_image,\n                            postsCount: Number(profileAccount.posts_count),\n                            followersCount: Number(profileAccount.followers_count),\n                            isVerified: profileAccount.is_verified === 1\n                        });\n                        const profile = convertProfileAccount(profileAccount);\n                        // Cache in both memory and localStorage\n                        profileCache.set(cacheKey, profile);\n                        setTimeout(()=>profileCache.delete(cacheKey), CACHE_DURATION);\n                        saveProfileToLocalStorage(cacheKey, profile);\n                        return profile;\n                    }\n                } catch (error) {\n                    continue;\n                }\n            }\n            console.log(\"\\uD83D\\uDCCA Scanned \".concat(profilesFound, \" profiles, no match found for user: \").concat(userPublicKey.toString().slice(0, 8)));\n            // No profile found - cache null result to avoid repeated scans\n            profileCache.set(cacheKey, null);\n            setTimeout(()=>profileCache.delete(cacheKey), CACHE_DURATION);\n            saveProfileToLocalStorage(cacheKey, null);\n            return null;\n        } catch (error) {\n            console.error(\"Error fetching profile for \".concat(userPublicKey.toString().slice(0, 8), \":\"), error);\n            return null;\n        }\n    };\n    // Get profile by username (for specific lookups)\n    const getProfileByUsername = async (userPublicKey, username)=>{\n        try {\n            const profilePDA = await getProfilePDA(userPublicKey, username);\n            const accountInfo = await connection.getAccountInfo(profilePDA);\n            if (!accountInfo || !accountInfo.data || accountInfo.data.length === 0) {\n                return null;\n            }\n            // Now try manual parsing\n            const profileAccount = manualParseProfile(accountInfo.data);\n            if (profileAccount) {\n                console.log(\"✅ Successfully manually parsed profile:\", {\n                    username: profileAccount.username,\n                    bio: profileAccount.bio,\n                    isInitialized: profileAccount.is_initialized === 1,\n                    owner: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(profileAccount.owner).toString(),\n                    profileImage: profileAccount.profile_image,\n                    coverImage: profileAccount.cover_image,\n                    postsCount: Number(profileAccount.posts_count)\n                });\n                return convertProfileAccount(profileAccount);\n            } else {\n                console.log(\"❌ Manual parsing failed\");\n                return null;\n            }\n        } catch (error) {\n            return null;\n        }\n    };\n    // Get posts - REAL IMPLEMENTATION with manual parsing and caching\n    const getPosts = async ()=>{\n        try {\n            // Check cache first\n            if (postsCache && Date.now() - postsCache.timestamp < POSTS_CACHE_DURATION) {\n                console.log(\"⚡ Using cached posts\");\n                return postsCache.posts;\n            }\n            console.log(\"\\uD83D\\uDD0D Fetching posts from blockchain...\");\n            const accounts = await connection.getProgramAccounts(PROGRAM_ID);\n            const posts = [];\n            console.log(\"\\uD83D\\uDCCA Scanning \".concat(accounts.length, \" program accounts for posts...\"));\n            for (const { account, pubkey } of accounts){\n                try {\n                    if (account.data.length === 0) continue;\n                    // Try manual post parsing first\n                    const postAccount = manualParsePost(account.data);\n                    if (postAccount && postAccount.is_initialized === 1 && postAccount.content) {\n                        const post = convertPostAccount(postAccount);\n                        // Only include top-level posts (not comments) in the main feed\n                        // Comments will be fetched separately for each post\n                        if (!post.isComment) {\n                            posts.push(post);\n                            console.log('\\uD83D\\uDCDD Found post: \"'.concat(post.content.substring(0, 50), '...\" by ').concat(post.author.toString()));\n                        }\n                    }\n                } catch (error) {\n                    continue;\n                }\n            }\n            posts.sort((a, b)=>b.timestamp - a.timestamp);\n            console.log(\"✅ Loaded \".concat(posts.length, \" posts from blockchain\"));\n            // Cache the results\n            postsCache = {\n                posts,\n                timestamp: Date.now()\n            };\n            return posts;\n        } catch (error) {\n            console.error(\"Error fetching posts:\", error);\n            return [];\n        }\n    };\n    // Get comments for a specific post\n    const getCommentsForPost = async (postId)=>{\n        try {\n            console.log(\"\\uD83D\\uDD0D Fetching comments for post ID \".concat(postId, \"...\"));\n            // For now, use localStorage to track comments since the Rust contract\n            // doesn't properly store parent-child relationships\n            const commentsKey = \"comments_\".concat(postId);\n            const storedComments = localStorage.getItem(commentsKey);\n            if (storedComments) {\n                const commentIds = JSON.parse(storedComments);\n                console.log(\"\\uD83D\\uDCDD Found \".concat(commentIds.length, \" stored comment IDs for post \").concat(postId));\n                // Get all posts and filter to comments\n                const accounts = await connection.getProgramAccounts(PROGRAM_ID);\n                const comments = [];\n                for (const { account, pubkey } of accounts){\n                    try {\n                        if (account.data.length === 0) continue;\n                        const postAccount = manualParsePost(account.data);\n                        if (postAccount && postAccount.is_initialized === 1 && postAccount.content) {\n                            const post = convertPostAccount(postAccount);\n                            // Check if this post ID is in our comment list\n                            if (commentIds.includes(post.id)) {\n                                comments.push({\n                                    ...post,\n                                    isComment: true,\n                                    parentId: postId\n                                });\n                            }\n                        }\n                    } catch (error) {\n                        continue;\n                    }\n                }\n                comments.sort((a, b)=>a.timestamp - b.timestamp);\n                console.log(\"✅ Loaded \".concat(comments.length, \" comments for post \").concat(postId));\n                return comments;\n            }\n            console.log(\"\\uD83D\\uDCDD No comments found for post \".concat(postId));\n            return [];\n        } catch (error) {\n            console.error(\"Error fetching comments:\", error);\n            return [];\n        }\n    };\n    // Store comment relationship in localStorage\n    const storeCommentRelationship = (parentPostId, commentPostId)=>{\n        try {\n            const commentsKey = \"comments_\".concat(parentPostId);\n            const existingComments = localStorage.getItem(commentsKey);\n            const commentIds = existingComments ? JSON.parse(existingComments) : [];\n            if (!commentIds.includes(commentPostId)) {\n                commentIds.push(commentPostId);\n                localStorage.setItem(commentsKey, JSON.stringify(commentIds));\n                console.log(\"\\uD83D\\uDCBE Stored comment relationship: post \".concat(commentPostId, \" is comment on post \").concat(parentPostId));\n            }\n        } catch (error) {\n            console.error(\"Failed to store comment relationship:\", error);\n        }\n    };\n    // Create post - REAL IMPLEMENTATION\n    const createPost = async function(content) {\n        let images = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83D\\uDD0D Creating post with content:\", content);\n            // Check SOL balance\n            const balance = await checkSOLBalance();\n            if (balance < 0.05) {\n                throw new Error(\"Insufficient SOL balance: \".concat(balance, \". You need at least 0.05 SOL for transaction fees and account creation.\"));\n            }\n            // Get user's profile PDA - we need this for the instruction\n            const userProfile = await getProfile(publicKey);\n            if (!userProfile) {\n                throw new Error(\"You must create a profile before posting\");\n            }\n            // Get user's current post count to generate the correct post ID\n            // The Rust contract increments posts_count first, then uses that as the post ID\n            const postId = userProfile.postsCount + 1;\n            const postPDA = await getPostPDA(publicKey, postId);\n            console.log(\"\\uD83D\\uDCCD Post PDA: \".concat(postPDA.toString(), \" for post ID: \").concat(postId));\n            // Generate a new keypair for the post account\n            // The Rust contract uses invoke with system_instruction::create_account\n            // This means the post account MUST be a keypair that signs the transaction\n            const postKeypair = _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Keypair.generate();\n            console.log(\"\\uD83D\\uDCCD Post Account: \".concat(postKeypair.publicKey.toString()));\n            // Get profile PDA for the user (we need the actual username)\n            // Try to find the profile account among all program accounts\n            const accounts = await connection.getProgramAccounts(PROGRAM_ID);\n            let userProfilePDA = null;\n            for (const { account, pubkey } of accounts){\n                try {\n                    const profileAccount = manualParseProfile(account.data);\n                    if (profileAccount && profileAccount.is_initialized === 1 && new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(profileAccount.owner).equals(publicKey)) {\n                        userProfilePDA = pubkey;\n                        console.log(\"\\uD83D\\uDCCD User Profile PDA: \".concat(userProfilePDA.toString()));\n                        break;\n                    }\n                } catch (error) {\n                    continue;\n                }\n            }\n            if (!userProfilePDA) {\n                throw new Error(\"Could not find your profile PDA. Please refresh and try again.\");\n            }\n            const instructionData = new CreatePostInstruction({\n                content,\n                images\n            });\n            const createPostVariant = Buffer.from([\n                2\n            ]) // CreatePost enum index\n            ;\n            const serializedData = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.serialize)(createPostSchema, instructionData);\n            const fullInstructionData = Buffer.concat([\n                createPostVariant,\n                Buffer.from(serializedData)\n            ]);\n            console.log(\"\\uD83D\\uDD22 Instruction data length: \".concat(fullInstructionData.length, \" bytes\"));\n            const instruction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: postKeypair.publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: userProfilePDA,\n                        isSigner: false,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.SystemProgram.programId,\n                        isSigner: false,\n                        isWritable: false\n                    }\n                ],\n                programId: PROGRAM_ID,\n                data: fullInstructionData\n            });\n            console.log(\"\\uD83D\\uDCDD Transaction instruction created\");\n            console.log(\"\\uD83D\\uDD11 Keys:\", instruction.keys.map((k)=>({\n                    pubkey: k.pubkey.toString(),\n                    isSigner: k.isSigner,\n                    isWritable: k.isWritable\n                })));\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction().add(instruction);\n            const { blockhash } = await connection.getLatestBlockhash(\"processed\");\n            transaction.recentBlockhash = blockhash;\n            transaction.feePayer = publicKey;\n            console.log(\"\\uD83D\\uDE80 Sending transaction...\");\n            // Sign transaction before simulation\n            transaction.partialSign(postKeypair);\n            // Simulate transaction \n            const simulation = await connection.simulateTransaction(transaction);\n            console.log(\"\\uD83C\\uDFAF Transaction simulation:\", simulation);\n            if (simulation.value.err) {\n                throw new Error(\"Transaction simulation failed: \".concat(JSON.stringify(simulation.value.err)));\n            }\n            // Send transaction with post keypair as additional signer\n            const signature = await sendTransaction(transaction, connection, {\n                skipPreflight: false,\n                preflightCommitment: \"processed\",\n                maxRetries: 3,\n                signers: [\n                    postKeypair\n                ]\n            });\n            console.log(\"\\uD83D\\uDCCB Transaction signature: \".concat(signature));\n            await connection.confirmTransaction({\n                signature,\n                blockhash,\n                lastValidBlockHeight: (await connection.getLatestBlockhash()).lastValidBlockHeight\n            }, \"processed\");\n            // Invalidate cache after post creation (profile post count changed)\n            clearProfileCache(publicKey.toString());\n            postsCache = null // Also clear posts cache to show new post immediately\n            ;\n            console.log(\"✅ Post created successfully!\");\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.success(\"Post created successfully!\");\n            return signature;\n        } catch (error) {\n            var _error_message, _error_message1;\n            console.error(\"❌ Post creation error:\", error);\n            if ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"insufficient funds\")) {\n                const balance = await checkSOLBalance();\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Insufficient SOL: \".concat(balance.toFixed(4), \" SOL. Need at least 0.05 SOL for fees.\"));\n            } else if ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes(\"simulation failed\")) {\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Transaction would fail: Check account setup and balance\");\n                console.error(\"Simulation error details:\", error.message);\n            } else {\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Failed to create post: \".concat(error.message || \"Unknown error\"));\n            }\n            throw error;\n        }\n    };\n    // Like post - REAL IMPLEMENTATION - Fixed to find actual post accounts\n    const likePost = async (postId, postAuthor)=>{\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83D\\uDD0D Attempting to like post ID \".concat(postId, \" by author \").concat(postAuthor.toString().slice(0, 8), \"...\"));\n            // Check SOL balance first\n            const balance = await checkSOLBalance();\n            console.log(\"\\uD83D\\uDCB0 Current SOL balance: \".concat(balance));\n            if (balance < 0.01) {\n                throw new Error(\"Insufficient SOL balance: \".concat(balance, \". Need at least 0.01 SOL for transaction fees.\"));\n            }\n            // Find the actual post account and author's profile account by scanning all program accounts\n            console.log(\"\\uD83D\\uDD0D Searching for post ID \".concat(postId, \" by author \").concat(postAuthor.toString().slice(0, 8), \"...\"));\n            const accounts = await connection.getProgramAccounts(PROGRAM_ID);\n            let postAccountAddress = null;\n            let postAccount = null;\n            let authorProfileAddress = null;\n            // First pass: find the post account\n            for (const { account, pubkey } of accounts){\n                try {\n                    const parsedPost = manualParsePost(account.data);\n                    if (parsedPost && parsedPost.is_initialized === 1 && Number(parsedPost.id) === postId && new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(parsedPost.author).equals(postAuthor)) {\n                        postAccountAddress = pubkey;\n                        postAccount = parsedPost;\n                        console.log(\"\\uD83C\\uDFAF Found post ID \".concat(postId, \" at address: \").concat(pubkey.toString()));\n                        break;\n                    }\n                } catch (error) {\n                    continue;\n                }\n            }\n            if (!postAccountAddress || !postAccount) {\n                throw new Error(\"Post ID \".concat(postId, \" by author \").concat(postAuthor.toString().slice(0, 8), \" not found on blockchain\"));\n            }\n            // Second pass: find the author's profile account\n            console.log(\"\\uD83D\\uDD0D Searching for author's profile: \".concat(postAuthor.toString().slice(0, 8), \"...\"));\n            for (const { account, pubkey } of accounts){\n                try {\n                    const parsedProfile = manualParseProfile(account.data);\n                    if (parsedProfile && parsedProfile.is_initialized === 1 && new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(parsedProfile.owner).equals(postAuthor)) {\n                        authorProfileAddress = pubkey;\n                        console.log(\"✅ Found author profile account: \".concat(pubkey.toString()));\n                        break;\n                    }\n                } catch (error) {\n                    continue;\n                }\n            }\n            if (!authorProfileAddress) {\n                throw new Error(\"Author's profile not found for \".concat(postAuthor.toString().slice(0, 8)));\n            }\n            console.log('\\uD83D\\uDCDD Post data verified: \"'.concat(postAccount.content.slice(0, 30), '...\" with ').concat(Number(postAccount.likes), \" likes\"));\n            const instructionData = new LikePostInstruction({\n                post_id: BigInt(postId)\n            });\n            const likePostVariant = Buffer.from([\n                3\n            ]) // LikePost instruction variant\n            ;\n            const serializedData = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.serialize)(likePostSchema, instructionData);\n            const fullInstructionData = Buffer.concat([\n                likePostVariant,\n                Buffer.from(serializedData)\n            ]);\n            console.log(\"\\uD83D\\uDD22 Instruction data: variant [3], serialized length: \".concat(serializedData.length, \", total: \").concat(fullInstructionData.length, \" bytes\"));\n            const instruction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: publicKey,\n                        isSigner: true,\n                        isWritable: false\n                    },\n                    {\n                        pubkey: postAccountAddress,\n                        isSigner: false,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: authorProfileAddress,\n                        isSigner: false,\n                        isWritable: true\n                    }\n                ],\n                programId: PROGRAM_ID,\n                data: fullInstructionData\n            });\n            console.log(\"\\uD83D\\uDD11 Transaction accounts:\");\n            console.log(\"  User (liker): \".concat(publicKey.toString(), \" (signer, readonly)\"));\n            console.log(\"  Post: \".concat(postAccountAddress.toString(), \" (not signer, writable)\"));\n            console.log(\"  Author Profile: \".concat(authorProfileAddress.toString(), \" (not signer, writable)\"));\n            console.log(\"  Program: \".concat(PROGRAM_ID.toString()));\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction().add(instruction);\n            const { blockhash } = await connection.getLatestBlockhash(\"processed\");\n            transaction.recentBlockhash = blockhash;\n            transaction.feePayer = publicKey;\n            // Simulate transaction before sending\n            console.log(\"\\uD83C\\uDFAF Simulating transaction...\");\n            const simulation = await connection.simulateTransaction(transaction);\n            console.log(\"\\uD83D\\uDCCA Simulation result:\", simulation);\n            if (simulation.value.err) {\n                throw new Error(\"Transaction simulation failed: \".concat(JSON.stringify(simulation.value.err)));\n            }\n            console.log(\"✅ Transaction simulation successful\");\n            console.log(\"\\uD83D\\uDE80 Sending transaction...\");\n            const signature = await sendTransaction(transaction, connection, {\n                skipPreflight: false,\n                preflightCommitment: \"processed\",\n                maxRetries: 3\n            });\n            console.log(\"\\uD83D\\uDCCB Transaction sent with signature: \".concat(signature));\n            console.log(\"⏳ Confirming transaction...\");\n            await connection.confirmTransaction({\n                signature,\n                blockhash,\n                lastValidBlockHeight: (await connection.getLatestBlockhash()).lastValidBlockHeight\n            }, \"processed\");\n            console.log(\"✅ Transaction confirmed! Post liked successfully!\");\n            // Clear posts cache to force refresh\n            postsCache = null;\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.success(\"Post liked!\");\n            return signature;\n        } catch (error) {\n            var _error_message, _error_message1, _error_message2;\n            console.error(\"❌ Like post error:\", error);\n            // More specific error messages\n            if ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"insufficient funds\")) {\n                const balance = await checkSOLBalance();\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Insufficient SOL: \".concat(balance.toFixed(4), \" SOL. Need at least 0.01 SOL for fees.\"));\n            } else if ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes(\"simulation failed\")) {\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Transaction would fail: Check post exists and wallet has permission\");\n                console.error(\"Simulation error details:\", error.message);\n            } else if ((_error_message2 = error.message) === null || _error_message2 === void 0 ? void 0 : _error_message2.includes(\"not found on blockchain\")) {\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Post not found on blockchain\");\n            } else {\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Failed to like post: \".concat(error.message || \"Unknown error\"));\n            }\n            throw error;\n        }\n    };\n    // Check specific profile PDA - for debugging profile detection issues\n    const checkProfileAtPDA = async (pdaAddress)=>{\n        try {\n            console.log(\"\\uD83D\\uDD0D Checking specific PDA: \".concat(pdaAddress));\n            const pda = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(pdaAddress);\n            const accountInfo = await connection.getAccountInfo(pda);\n            if (!accountInfo) {\n                console.log(\"❌ No account found at PDA: \".concat(pdaAddress));\n                return;\n            }\n            console.log(\"✅ Account exists! Owner: \".concat(accountInfo.owner.toString(), \", Size: \").concat(accountInfo.data.length, \" bytes\"));\n            // Inspect raw data\n            console.log(\"\\uD83D\\uDD0D Raw data (first 100 bytes):\", Array.from(accountInfo.data.slice(0, 100)));\n            if (accountInfo.owner.equals(PROGRAM_ID)) {\n                console.log(\"✅ Account is owned by our program\");\n                try {\n                    // Try manual parsing to understand the structure\n                    let offset = 0;\n                    const is_initialized = accountInfo.data[offset];\n                    offset += 1;\n                    console.log(\"\\uD83D\\uDCCA is_initialized: \".concat(is_initialized));\n                    const owner = accountInfo.data.slice(offset, offset + 32);\n                    offset += 32;\n                    console.log(\"\\uD83D\\uDCCA owner: \".concat(new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(owner).toString()));\n                    // Try to read the username length (Borsh string format: 4 bytes length + string)\n                    const usernameLength = accountInfo.data.readUInt32LE(offset);\n                    offset += 4;\n                    console.log(\"\\uD83D\\uDCCA username length: \".concat(usernameLength));\n                    if (usernameLength > 0 && usernameLength < 100) {\n                        const username = accountInfo.data.slice(offset, offset + usernameLength).toString(\"utf8\");\n                        console.log('\\uD83D\\uDCCA username: \"'.concat(username, '\"'));\n                    }\n                    // Now try manual parsing\n                    const profileAccount = manualParseProfile(accountInfo.data);\n                    if (profileAccount) {\n                        console.log(\"✅ Successfully manually parsed profile:\", {\n                            username: profileAccount.username,\n                            bio: profileAccount.bio,\n                            isInitialized: profileAccount.is_initialized === 1,\n                            owner: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(profileAccount.owner).toString(),\n                            profileImage: profileAccount.profile_image,\n                            coverImage: profileAccount.cover_image,\n                            postsCount: Number(profileAccount.posts_count)\n                        });\n                    } else {\n                        console.log(\"❌ Manual parsing failed\");\n                    }\n                    // Also try Borsh for comparison\n                    try {\n                        const profileAccount = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.deserialize)(profileAccountSchema, ProfileAccount, accountInfo.data);\n                        console.log(\"✅ Borsh deserialization also worked:\", {\n                            username: profileAccount.username,\n                            bio: profileAccount.bio,\n                            isInitialized: profileAccount.is_initialized === 1,\n                            owner: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(profileAccount.owner).toString()\n                        });\n                    } catch (error) {\n                        console.log(\"❌ Borsh deserialization still fails:\", error);\n                    }\n                } catch (error) {\n                    console.log(\"❌ Error checking PDA:\", error);\n                }\n            } else {\n                console.log(\"❌ Account is owned by different program: \".concat(accountInfo.owner.toString()));\n            }\n        } catch (error) {\n            console.log(\"❌ Error checking PDA:\", error);\n        }\n    };\n    // Manual profile parser - bypasses Borsh deserialization issues\n    const manualParseProfile = (data)=>{\n        try {\n            // Basic validation - profiles should have a minimum size\n            if (data.length < 150) return null // Profiles need at least 150 bytes for basic structure\n            ;\n            let offset = 0;\n            // Parse each field manually\n            const is_initialized = data[offset];\n            if (is_initialized !== 1) return null // Must be initialized\n            ;\n            offset += 1;\n            const owner = data.slice(offset, offset + 32);\n            offset += 32;\n            // Validate we have enough data for username length\n            if (offset + 4 > data.length) return null;\n            // String fields (username, bio, profile_image, cover_image)\n            const usernameLength = data.readUInt32LE(offset);\n            offset += 4;\n            // Validate username length is reasonable\n            if (usernameLength > 100 || usernameLength === 0) return null;\n            if (offset + usernameLength > data.length) return null;\n            const username = data.slice(offset, offset + usernameLength).toString(\"utf8\");\n            offset += usernameLength;\n            // Validate we have enough data for bio length\n            if (offset + 4 > data.length) return null;\n            const bioLength = data.readUInt32LE(offset);\n            offset += 4;\n            // Validate bio length is reasonable\n            if (bioLength > 1000) return null;\n            if (offset + bioLength > data.length) return null;\n            const bio = data.slice(offset, offset + bioLength).toString(\"utf8\");\n            offset += bioLength;\n            // Validate we have enough data for profile image length\n            if (offset + 4 > data.length) return null;\n            const profileImageLength = data.readUInt32LE(offset);\n            offset += 4;\n            // Validate profile image length is reasonable\n            if (profileImageLength > 500) return null;\n            if (offset + profileImageLength > data.length) return null;\n            const profile_image = data.slice(offset, offset + profileImageLength).toString(\"utf8\");\n            offset += profileImageLength;\n            // Validate we have enough data for cover image length\n            if (offset + 4 > data.length) return null;\n            const coverImageLength = data.readUInt32LE(offset);\n            offset += 4;\n            // Validate cover image length is reasonable\n            if (coverImageLength > 500) return null;\n            if (offset + coverImageLength > data.length) return null;\n            const cover_image = data.slice(offset, offset + coverImageLength).toString(\"utf8\");\n            offset += coverImageLength;\n            // Validate we have enough data for all the u64 fields (8 bytes each * 6 fields = 48 bytes)\n            if (offset + 48 > data.length) return null;\n            // u64 fields\n            const created_at = data.readBigUInt64LE(offset);\n            offset += 8;\n            const followers_count = data.readBigUInt64LE(offset);\n            offset += 8;\n            const following_count = data.readBigUInt64LE(offset);\n            offset += 8;\n            // i64 field\n            const user_credit_rating = data.readBigInt64LE(offset);\n            offset += 8;\n            const posts_count = data.readBigUInt64LE(offset);\n            offset += 8;\n            const last_post_timestamp = data.readBigUInt64LE(offset);\n            offset += 8;\n            const daily_post_count = data.readBigUInt64LE(offset);\n            offset += 8;\n            // Validate we have enough data for the final u8 field\n            if (offset + 1 > data.length) return null;\n            const is_verified = data[offset];\n            offset += 1;\n            return new ProfileAccount({\n                is_initialized,\n                owner: new Uint8Array(owner),\n                username,\n                bio,\n                profile_image,\n                cover_image,\n                created_at,\n                followers_count,\n                following_count,\n                user_credit_rating,\n                posts_count,\n                last_post_timestamp,\n                daily_post_count,\n                is_verified\n            });\n        } catch (error) {\n            // Silent failure - not a profile account or invalid data\n            return null;\n        }\n    };\n    // Manual post parser - bypasses Borsh deserialization issues\n    const manualParsePost = (data)=>{\n        try {\n            // Quick validation: posts should have specific size and structure\n            if (data.length < 100) return null // Posts should be larger than profiles\n            ;\n            let offset = 0;\n            // Parse each field manually\n            const is_initialized = data[offset];\n            if (is_initialized !== 1) return null // Must be initialized\n            ;\n            offset += 1;\n            // Check if this looks like a post vs profile by examining the structure\n            // Posts start with: u8 (init), u64 (id), [32]u8 (author), string (content)\n            // Profiles start with: u8 (init), [32]u8 (owner), string (username)\n            const id = data.readBigUInt64LE(offset);\n            offset += 8;\n            const author = data.slice(offset, offset + 32);\n            offset += 32;\n            const contentLength = data.readUInt32LE(offset);\n            offset += 4;\n            // Validate content length is reasonable (not too large)\n            if (contentLength > 10000 || contentLength === 0) return null;\n            if (offset + contentLength > data.length) return null;\n            const content = data.slice(offset, offset + contentLength).toString(\"utf8\");\n            offset += contentLength;\n            // Ensure we have enough remaining data for the rest of the post structure\n            if (offset + 40 > data.length) return null // Need at least 40 more bytes for timestamps and counts\n            ;\n            const timestamp = data.readBigUInt64LE(offset);\n            offset += 8;\n            const likes = data.readBigUInt64LE(offset);\n            offset += 8;\n            const comments = data.readBigUInt64LE(offset);\n            offset += 8;\n            const mirrors = data.readBigUInt64LE(offset);\n            offset += 8;\n            // Parse images array length\n            if (offset + 4 > data.length) return null;\n            const imagesLength = data.readUInt32LE(offset);\n            offset += 4;\n            const images = [];\n            // Parse images array - each image is a length-prefixed string\n            for(let i = 0; i < imagesLength; i++){\n                if (offset + 4 > data.length) return null;\n                const imageLength = data.readUInt32LE(offset);\n                offset += 4;\n                if (offset + imageLength > data.length) return null;\n                const image = data.slice(offset, offset + imageLength).toString(\"utf8\");\n                offset += imageLength;\n                images.push(image);\n            }\n            // Ensure we have enough data for rating and kill zone\n            if (offset + 2 > data.length) return null;\n            const rating = data[offset];\n            offset += 1;\n            const in_kill_zone = data[offset];\n            offset += 1;\n            return new PostAccount({\n                is_initialized,\n                id,\n                author: new Uint8Array(author),\n                content,\n                timestamp,\n                likes,\n                comments,\n                mirrors,\n                images,\n                rating,\n                in_kill_zone\n            });\n        } catch (error) {\n            // Silent failure - not a post account\n            return null;\n        }\n    };\n    // Convert CommunityAccount to Community interface\n    const convertCommunityAccount = (communityAccount)=>{\n        return {\n            isInitialized: communityAccount.is_initialized === 1,\n            id: Number(communityAccount.id),\n            creator: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(communityAccount.creator),\n            name: communityAccount.name,\n            description: communityAccount.description,\n            avatar: communityAccount.avatar,\n            rules: communityAccount.rules,\n            memberCount: Number(communityAccount.member_count),\n            createdAt: Number(communityAccount.created_at) * 1000,\n            isPrivate: communityAccount.is_private === 1\n        };\n    };\n    // Create Community\n    const createCommunity = async function(name, description, avatar) {\n        let rules = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83C\\uDFD8️ Creating community:\", name);\n            const balance = await checkSOLBalance();\n            if (balance < 0.05) {\n                throw new Error(\"Insufficient SOL balance: \".concat(balance, \". Need at least 0.05 SOL.\"));\n            }\n            // Generate a keypair for the community account\n            const communityKeypair = _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Keypair.generate();\n            console.log(\"\\uD83D\\uDCCD Community Account: \".concat(communityKeypair.publicKey.toString()));\n            const instructionData = new CreateCommunityInstruction({\n                name,\n                description,\n                avatar,\n                rules\n            });\n            const createCommunityVariant = Buffer.from([\n                7\n            ]) // CreateCommunity enum index\n            ;\n            const serializedData = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.serialize)(createCommunitySchema, instructionData);\n            const fullInstructionData = Buffer.concat([\n                createCommunityVariant,\n                Buffer.from(serializedData)\n            ]);\n            const instruction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: communityKeypair.publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.SystemProgram.programId,\n                        isSigner: false,\n                        isWritable: false\n                    }\n                ],\n                programId: PROGRAM_ID,\n                data: fullInstructionData\n            });\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction().add(instruction);\n            const { blockhash } = await connection.getLatestBlockhash(\"processed\");\n            transaction.recentBlockhash = blockhash;\n            transaction.feePayer = publicKey;\n            // Sign with community keypair\n            transaction.partialSign(communityKeypair);\n            const signature = await sendTransaction(transaction, connection, {\n                skipPreflight: false,\n                preflightCommitment: \"processed\",\n                maxRetries: 3,\n                signers: [\n                    communityKeypair\n                ]\n            });\n            await connection.confirmTransaction({\n                signature,\n                blockhash,\n                lastValidBlockHeight: (await connection.getLatestBlockhash()).lastValidBlockHeight\n            }, \"processed\");\n            console.log(\"✅ Community created successfully!\");\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.success('Community \"'.concat(name, '\" created successfully!'));\n            return signature;\n        } catch (error) {\n            console.error(\"❌ Community creation error:\", error);\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Failed to create community: \".concat(error.message || \"Unknown error\"));\n            throw error;\n        }\n    };\n    // Follow Profile\n    const followProfile = async (profilePublicKey)=>{\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83D\\uDC65 Following profile:\", profilePublicKey.toString());\n            // Find the follower's profile account (current user's profile)\n            console.log(\"\\uD83D\\uDD0D Searching for follower profile: \".concat(publicKey.toString().slice(0, 8), \"...\"));\n            const accounts = await connection.getProgramAccounts(PROGRAM_ID);\n            let followerProfileAddress = null;\n            for (const { account, pubkey } of accounts){\n                try {\n                    const parsedProfile = manualParseProfile(account.data);\n                    if (parsedProfile && parsedProfile.is_initialized === 1 && new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(parsedProfile.owner).equals(publicKey)) {\n                        followerProfileAddress = pubkey;\n                        console.log(\"✅ Found follower profile account: \".concat(pubkey.toString()));\n                        break;\n                    }\n                } catch (error) {\n                    continue;\n                }\n            }\n            if (!followerProfileAddress) {\n                throw new Error(\"You must create a profile before following others\");\n            }\n            const instructionData = new FollowProfileInstruction({\n                profile_id: profilePublicKey\n            });\n            const followProfileVariant = Buffer.from([\n                5\n            ]) // FollowProfile enum index\n            ;\n            const serializedData = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.serialize)(followProfileSchema, instructionData);\n            const fullInstructionData = Buffer.concat([\n                followProfileVariant,\n                Buffer.from(serializedData)\n            ]);\n            const instruction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: publicKey,\n                        isSigner: true,\n                        isWritable: false\n                    },\n                    {\n                        pubkey: profilePublicKey,\n                        isSigner: false,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: followerProfileAddress,\n                        isSigner: false,\n                        isWritable: true\n                    }\n                ],\n                programId: PROGRAM_ID,\n                data: fullInstructionData\n            });\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction().add(instruction);\n            const signature = await sendTransaction(transaction, connection);\n            await connection.confirmTransaction(signature, \"processed\");\n            // Clear profile cache to force refresh of follower counts\n            clearProfileCache();\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.success(\"Profile followed!\");\n            return signature;\n        } catch (error) {\n            console.error(\"Follow error:\", error);\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Failed to follow profile\");\n            throw error;\n        }\n    };\n    // Unfollow Profile\n    const unfollowProfile = async (profilePublicKey)=>{\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83D\\uDC65 Unfollowing profile:\", profilePublicKey.toString());\n            // Find the follower's profile account (current user's profile)\n            console.log(\"\\uD83D\\uDD0D Searching for follower profile: \".concat(publicKey.toString().slice(0, 8), \"...\"));\n            const accounts = await connection.getProgramAccounts(PROGRAM_ID);\n            let followerProfileAddress = null;\n            for (const { account, pubkey } of accounts){\n                try {\n                    const parsedProfile = manualParseProfile(account.data);\n                    if (parsedProfile && parsedProfile.is_initialized === 1 && new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(parsedProfile.owner).equals(publicKey)) {\n                        followerProfileAddress = pubkey;\n                        console.log(\"✅ Found follower profile account: \".concat(pubkey.toString()));\n                        break;\n                    }\n                } catch (error) {\n                    continue;\n                }\n            }\n            if (!followerProfileAddress) {\n                throw new Error(\"You must create a profile before unfollowing others\");\n            }\n            const instructionData = new FollowProfileInstruction({\n                profile_id: profilePublicKey\n            });\n            const unfollowProfileVariant = Buffer.from([\n                6\n            ]) // UnfollowProfile enum index\n            ;\n            const serializedData = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.serialize)(followProfileSchema, instructionData);\n            const fullInstructionData = Buffer.concat([\n                unfollowProfileVariant,\n                Buffer.from(serializedData)\n            ]);\n            const instruction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: publicKey,\n                        isSigner: true,\n                        isWritable: false\n                    },\n                    {\n                        pubkey: profilePublicKey,\n                        isSigner: false,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: followerProfileAddress,\n                        isSigner: false,\n                        isWritable: true\n                    }\n                ],\n                programId: PROGRAM_ID,\n                data: fullInstructionData\n            });\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction().add(instruction);\n            const signature = await sendTransaction(transaction, connection);\n            await connection.confirmTransaction(signature, \"processed\");\n            // Clear profile cache to force refresh of follower counts\n            clearProfileCache();\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.success(\"Profile unfollowed!\");\n            return signature;\n        } catch (error) {\n            console.error(\"Unfollow error:\", error);\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Failed to unfollow profile\");\n            throw error;\n        }\n    };\n    // Update Profile\n    const updateProfile = async (username, bio, profileImage, coverImage)=>{\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83D\\uDD04 Updating profile:\", username);\n            const instructionData = new CreateProfileInstruction({\n                username,\n                bio,\n                profile_image: profileImage,\n                cover_image: coverImage\n            });\n            const updateProfileVariant = Buffer.from([\n                1\n            ]) // UpdateProfile enum index (same as CreateProfile)\n            ;\n            const serializedData = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.serialize)(createProfileSchema, instructionData);\n            const fullInstructionData = Buffer.concat([\n                updateProfileVariant,\n                Buffer.from(serializedData)\n            ]);\n            const instruction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    }\n                ],\n                programId: PROGRAM_ID,\n                data: fullInstructionData\n            });\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction().add(instruction);\n            const signature = await sendTransaction(transaction, connection);\n            await connection.confirmTransaction(signature, \"processed\");\n            console.log(\"✅ Profile updated successfully!\");\n            // Clear cache to force refresh\n            profileCache.delete(publicKey.toString());\n            return signature;\n        } catch (error) {\n            console.error(\"❌ Update profile error:\", error);\n            throw error;\n        }\n    };\n    // Comment on Post\n    const commentOnPost = async (postId, content, postAuthor)=>{\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83D\\uDCAC Commenting on post ID \".concat(postId, \"...\"));\n            // Check SOL balance first\n            const balance = await checkSOLBalance();\n            if (balance < 0.01) {\n                throw new Error(\"Insufficient SOL balance: \".concat(balance, \". Need at least 0.01 SOL for transaction fees.\"));\n            }\n            // Find the actual post account by scanning all program accounts\n            console.log(\"\\uD83D\\uDD0D Searching for post ID \".concat(postId, \" by author \").concat(postAuthor.toString().slice(0, 8), \"...\"));\n            const accounts = await connection.getProgramAccounts(PROGRAM_ID);\n            let postAddress = null;\n            let userProfileAddress = null;\n            // First pass: find the post account\n            for (const { account, pubkey } of accounts){\n                try {\n                    const parsedPost = manualParsePost(account.data);\n                    if (parsedPost && parsedPost.is_initialized === 1 && Number(parsedPost.id) === postId && new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(parsedPost.author).equals(postAuthor)) {\n                        postAddress = pubkey;\n                        console.log(\"✅ Found post account: \".concat(pubkey.toString()));\n                        break;\n                    }\n                } catch (error) {\n                    continue;\n                }\n            }\n            if (!postAddress) {\n                throw new Error(\"Post with ID \".concat(postId, \" not found\"));\n            }\n            // Second pass: find the commenter's profile account\n            console.log(\"\\uD83D\\uDD0D Searching for commenter profile: \".concat(publicKey.toString().slice(0, 8), \"...\"));\n            for (const { account, pubkey } of accounts){\n                try {\n                    const parsedProfile = manualParseProfile(account.data);\n                    if (parsedProfile && parsedProfile.is_initialized === 1 && new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(parsedProfile.owner).equals(publicKey)) {\n                        userProfileAddress = pubkey;\n                        console.log(\"✅ Found commenter profile account: \".concat(pubkey.toString()));\n                        break;\n                    }\n                } catch (error) {\n                    continue;\n                }\n            }\n            if (!userProfileAddress) {\n                throw new Error(\"You must create a profile before commenting\");\n            }\n            // Generate a new keypair for the comment account\n            const commentKeypair = _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Keypair.generate();\n            console.log(\"\\uD83D\\uDCCD Comment Account: \".concat(commentKeypair.publicKey.toString()));\n            const instructionData = new CommentOnPostInstruction({\n                content,\n                parent_id: BigInt(postId)\n            });\n            const commentVariant = Buffer.from([\n                4\n            ]) // CommentOnPost enum index\n            ;\n            const serializedData = (0,borsh__WEBPACK_IMPORTED_MODULE_1__.serialize)(commentOnPostSchema, instructionData);\n            const fullInstructionData = Buffer.concat([\n                commentVariant,\n                Buffer.from(serializedData)\n            ]);\n            const instruction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: commentKeypair.publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: postAddress,\n                        isSigner: false,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: userProfileAddress,\n                        isSigner: false,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.SystemProgram.programId,\n                        isSigner: false,\n                        isWritable: false\n                    }\n                ],\n                programId: PROGRAM_ID,\n                data: fullInstructionData\n            });\n            const transaction = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction().add(instruction);\n            const { blockhash } = await connection.getLatestBlockhash(\"processed\");\n            transaction.recentBlockhash = blockhash;\n            transaction.feePayer = publicKey;\n            // Sign with comment keypair\n            transaction.partialSign(commentKeypair);\n            console.log(\"\\uD83C\\uDFAF Simulating transaction...\");\n            const simulation = await connection.simulateTransaction(transaction);\n            console.log(\"\\uD83D\\uDCCA Simulation result:\", simulation);\n            if (simulation.value.err) {\n                console.error(\"❌ Simulation failed:\", simulation.value.err);\n                throw new Error(\"Transaction simulation failed: \".concat(JSON.stringify(simulation.value.err)));\n            }\n            const signature = await sendTransaction(transaction, connection, {\n                skipPreflight: false,\n                preflightCommitment: \"processed\",\n                maxRetries: 3,\n                signers: [\n                    commentKeypair\n                ]\n            });\n            await connection.confirmTransaction({\n                signature,\n                blockhash,\n                lastValidBlockHeight: (await connection.getLatestBlockhash()).lastValidBlockHeight\n            }, \"processed\");\n            console.log(\"✅ Comment posted successfully!\");\n            // Store the comment relationship in localStorage\n            // We need to get the comment's post ID from the user's profile\n            const userProfile = await getProfile(publicKey);\n            if (userProfile) {\n                storeCommentRelationship(postId, userProfile.postsCount);\n            }\n            // Clear posts cache to force refresh\n            postsCache = null;\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.success(\"Comment posted!\");\n            return signature;\n        } catch (error) {\n            console.error(\"❌ Comment post error:\", error);\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Failed to comment: \".concat(error.message || \"Unknown error\"));\n            throw error;\n        }\n    };\n    // Bookmark Post (using localStorage since we don't have bookmark functionality)\n    const bookmarkPost = async (postId)=>{\n        if (!publicKey) throw new Error(\"Wallet not connected\");\n        try {\n            console.log(\"\\uD83D\\uDD16 Bookmarking post ID \".concat(postId, \"...\"));\n            const bookmarksKey = \"bookmarks_\".concat(publicKey.toString());\n            const existingBookmarks = localStorage.getItem(bookmarksKey);\n            const bookmarks = existingBookmarks ? JSON.parse(existingBookmarks) : [];\n            if (bookmarks.includes(postId)) {\n                // Remove bookmark\n                const updatedBookmarks = bookmarks.filter((id)=>id !== postId);\n                localStorage.setItem(bookmarksKey, JSON.stringify(updatedBookmarks));\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.success(\"Bookmark removed!\");\n            } else {\n                // Add bookmark\n                bookmarks.push(postId);\n                localStorage.setItem(bookmarksKey, JSON.stringify(bookmarks));\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.success(\"Post bookmarked!\");\n            }\n            return \"bookmarked\";\n        } catch (error) {\n            console.error(\"❌ Bookmark error:\", error);\n            react_hot_toast__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Failed to bookmark post\");\n            throw error;\n        }\n    };\n    // Get user bookmarks\n    const getUserBookmarks = ()=>{\n        if (!publicKey) return [];\n        try {\n            const bookmarksKey = \"bookmarks_\".concat(publicKey.toString());\n            const existingBookmarks = localStorage.getItem(bookmarksKey);\n            return existingBookmarks ? JSON.parse(existingBookmarks) : [];\n        } catch (error) {\n            console.error(\"Failed to get bookmarks:\", error);\n            return [];\n        }\n    };\n    // Check if post is bookmarked\n    const isPostBookmarked = (postId)=>{\n        const bookmarks = getUserBookmarks();\n        return bookmarks.includes(postId);\n    };\n    // Utility function to preload profile on wallet connection\n    const preloadProfile = async ()=>{\n        if (!publicKey) return;\n        console.log(\"\\uD83D\\uDE80 Preloading profile on wallet connection...\");\n        try {\n            await getProfile(publicKey);\n        } catch (error) {\n            console.warn(\"Failed to preload profile:\", error);\n        }\n    };\n    // Force refresh all data - clears all caches\n    const refreshData = ()=>{\n        console.log(\"\\uD83D\\uDD04 Force refreshing all data...\");\n        clearProfileCache();\n        postsCache = null;\n    };\n    return {\n        createProfile,\n        createPost,\n        likePost,\n        getProfile,\n        getProfileByUsername,\n        getPosts,\n        getProfilePDA,\n        getPostPDA,\n        checkProfileAtPDA,\n        preloadProfile,\n        clearProfileCache,\n        refreshData,\n        createCommunity,\n        followProfile,\n        unfollowProfile,\n        updateProfile,\n        commentOnPost,\n        bookmarkPost,\n        getUserBookmarks,\n        isPostBookmarked,\n        getCommentsForPost,\n        storeCommentRelationship\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZUJsb2Nrc1Byb2dyYW0udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUF1RTtBQUNtRDtBQUM1RTtBQUNQO0FBQ047QUFFakMseURBQXlEO0FBQ3pELE1BQU1ZLGFBQWEsSUFBSVYsc0RBQVNBLENBQUNTLDJDQUFNQSxDQUFDRSxNQUFNLENBQUNDLFNBQVM7QUFFeEQsb0VBQW9FO0FBQ3BFLE1BQU1DLGFBQWFDLGtCQUF5Qjs7QUFFNUMsK0NBQStDO1VBQzFDQzs7Ozs7Ozs7OztHQUFBQSx3QkFBQUE7O1VBYU9DOzs7Ozs7Ozs7R0FBQUEsZUFBQUE7QUFXWix3Q0FBd0M7QUFDeEMsTUFBTUM7SUFNSkMsWUFBWUMsTUFLWCxDQUFFO1FBQ0QsSUFBSSxDQUFDQyxRQUFRLEdBQUdELE9BQU9DLFFBQVE7UUFDL0IsSUFBSSxDQUFDQyxHQUFHLEdBQUdGLE9BQU9FLEdBQUc7UUFDckIsSUFBSSxDQUFDQyxhQUFhLEdBQUdILE9BQU9HLGFBQWE7UUFDekMsSUFBSSxDQUFDQyxXQUFXLEdBQUdKLE9BQU9JLFdBQVc7SUFDdkM7QUFDRjtBQUVBLHFDQUFxQztBQUNyQyxNQUFNQztJQUlKTixZQUFZQyxNQUdYLENBQUU7UUFDRCxJQUFJLENBQUNNLE9BQU8sR0FBR04sT0FBT00sT0FBTztRQUM3QixJQUFJLENBQUNDLE1BQU0sR0FBR1AsT0FBT08sTUFBTTtJQUM3QjtBQUNGO0FBRUEsbUNBQW1DO0FBQ25DLE1BQU1DO0lBR0pULFlBQVlDLE1BRVgsQ0FBRTtRQUNELElBQUksQ0FBQ1MsT0FBTyxHQUFHVCxPQUFPUyxPQUFPO0lBQy9CO0FBQ0Y7QUFFQSx5Q0FBeUM7QUFDekMsTUFBTUM7SUFJSlgsWUFBWUMsTUFHWCxDQUFFO1FBQ0QsSUFBSSxDQUFDTSxPQUFPLEdBQUdOLE9BQU9NLE9BQU87UUFDN0IsSUFBSSxDQUFDSyxTQUFTLEdBQUdYLE9BQU9XLFNBQVM7SUFDbkM7QUFDRjtBQUVBLHVDQUF1QztBQUN2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L19OX0UvLi9ob29rcy91c2VCbG9ja3NQcm9ncmFtLnRzPzVlOGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlQ29ubmVjdGlvbiwgdXNlV2FsbGV0IH0gZnJvbSAnQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdCdcclxuaW1wb3J0IHsgUHVibGljS2V5LCBUcmFuc2FjdGlvbiwgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiwgU3lzdGVtUHJvZ3JhbSwgTEFNUE9SVFNfUEVSX1NPTCwgS2V5cGFpciB9IGZyb20gJ0Bzb2xhbmEvd2ViMy5qcydcclxuaW1wb3J0IHsgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSB9IGZyb20gJ2JvcnNoJ1xyXG5pbXBvcnQgeyB0b2FzdCB9IGZyb20gJ3JlYWN0LWhvdC10b2FzdCdcclxuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnQC9jb25maWcnXHJcblxyXG4vLyBZb3VyIGRlcGxveWVkIHByb2dyYW0gSUQgLSBjb25maWd1cmVkIGZyb20gZW52aXJvbm1lbnRcclxuY29uc3QgUFJPR1JBTV9JRCA9IG5ldyBQdWJsaWNLZXkoY29uZmlnLnNvbGFuYS5wcm9ncmFtSWQpXHJcblxyXG4vLyBBZGQgZGVidWcgbW9kZSBmb3IgdGVzdGluZyB3aXRob3V0IGFjdHVhbCBibG9ja2NoYWluIHRyYW5zYWN0aW9uc1xyXG5jb25zdCBERUJVR19NT0RFID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCdcclxuXHJcbi8vIEluc3RydWN0aW9uIGVudW0gbWF0Y2hpbmcgeW91ciBSdXN0IGNvbnRyYWN0XHJcbmVudW0gQ29udHJhY3RJbnN0cnVjdGlvbiB7XHJcbiAgQ3JlYXRlUHJvZmlsZSA9IDAsXHJcbiAgVXBkYXRlUHJvZmlsZSA9IDEsXHJcbiAgQ3JlYXRlUG9zdCA9IDIsXHJcbiAgTGlrZVBvc3QgPSAzLFxyXG4gIENvbW1lbnRPblBvc3QgPSA0LFxyXG4gIEZvbGxvd1Byb2ZpbGUgPSA1LFxyXG4gIFVuZm9sbG93UHJvZmlsZSA9IDYsXHJcbiAgQ3JlYXRlQ29tbXVuaXR5ID0gNyxcclxuICBKb2luQ29tbXVuaXR5ID0gOCxcclxufVxyXG5cclxuLy8gUG9zdFJhdGluZyBlbnVtIG1hdGNoaW5nIFJ1c3QgY29udHJhY3RcclxuZXhwb3J0IGVudW0gUG9zdFJhdGluZyB7XHJcbiAgTm9uZSA9IDAsXHJcbiAgQnJvbnplID0gMSxcclxuICBTaWx2ZXIgPSAyLFxyXG4gIEdvbGQgPSAzLFxyXG4gIFBsYXRpbnVtID0gNCxcclxuICBEaWFtb25kID0gNSxcclxuICBBY2UgPSA2LFxyXG4gIENvbnF1ZXJvciA9IDcsXHJcbn1cclxuXHJcbi8vIENyZWF0ZSBQcm9maWxlIGluc3RydWN0aW9uIGRhdGEgY2xhc3NcclxuY2xhc3MgQ3JlYXRlUHJvZmlsZUluc3RydWN0aW9uIHtcclxuICB1c2VybmFtZTogc3RyaW5nXHJcbiAgYmlvOiBzdHJpbmdcclxuICBwcm9maWxlX2ltYWdlOiBzdHJpbmdcclxuICBjb3Zlcl9pbWFnZTogc3RyaW5nXHJcblxyXG4gIGNvbnN0cnVjdG9yKGZpZWxkczoge1xyXG4gICAgdXNlcm5hbWU6IHN0cmluZ1xyXG4gICAgYmlvOiBzdHJpbmdcclxuICAgIHByb2ZpbGVfaW1hZ2U6IHN0cmluZ1xyXG4gICAgY292ZXJfaW1hZ2U6IHN0cmluZ1xyXG4gIH0pIHtcclxuICAgIHRoaXMudXNlcm5hbWUgPSBmaWVsZHMudXNlcm5hbWVcclxuICAgIHRoaXMuYmlvID0gZmllbGRzLmJpb1xyXG4gICAgdGhpcy5wcm9maWxlX2ltYWdlID0gZmllbGRzLnByb2ZpbGVfaW1hZ2VcclxuICAgIHRoaXMuY292ZXJfaW1hZ2UgPSBmaWVsZHMuY292ZXJfaW1hZ2VcclxuICB9XHJcbn1cclxuXHJcbi8vIENyZWF0ZSBQb3N0IGluc3RydWN0aW9uIGRhdGEgY2xhc3NcclxuY2xhc3MgQ3JlYXRlUG9zdEluc3RydWN0aW9uIHtcclxuICBjb250ZW50OiBzdHJpbmdcclxuICBpbWFnZXM6IHN0cmluZ1tdXHJcblxyXG4gIGNvbnN0cnVjdG9yKGZpZWxkczoge1xyXG4gICAgY29udGVudDogc3RyaW5nXHJcbiAgICBpbWFnZXM6IHN0cmluZ1tdXHJcbiAgfSkge1xyXG4gICAgdGhpcy5jb250ZW50ID0gZmllbGRzLmNvbnRlbnRcclxuICAgIHRoaXMuaW1hZ2VzID0gZmllbGRzLmltYWdlc1xyXG4gIH1cclxufVxyXG5cclxuLy8gTGlrZSBQb3N0IGluc3RydWN0aW9uIGRhdGEgY2xhc3NcclxuY2xhc3MgTGlrZVBvc3RJbnN0cnVjdGlvbiB7XHJcbiAgcG9zdF9pZDogYmlnaW50XHJcblxyXG4gIGNvbnN0cnVjdG9yKGZpZWxkczoge1xyXG4gICAgcG9zdF9pZDogYmlnaW50XHJcbiAgfSkge1xyXG4gICAgdGhpcy5wb3N0X2lkID0gZmllbGRzLnBvc3RfaWRcclxuICB9XHJcbn1cclxuXHJcbi8vIENvbW1lbnQgT24gUG9zdCBpbnN0cnVjdGlvbiBkYXRhIGNsYXNzXHJcbmNsYXNzIENvbW1lbnRPblBvc3RJbnN0cnVjdGlvbiB7XHJcbiAgY29udGVudDogc3RyaW5nXHJcbiAgcGFyZW50X2lkOiBiaWdpbnRcclxuXHJcbiAgY29uc3RydWN0b3IoZmllbGRzOiB7XHJcbiAgICBjb250ZW50OiBzdHJpbmdcclxuICAgIHBhcmVudF9pZDogYmlnaW50XHJcbiAgfSkge1xyXG4gICAgdGhpcy5jb250ZW50ID0gZmllbGRzLmNvbnRlbnRcclxuICAgIHRoaXMucGFyZW50X2lkID0gZmllbGRzLnBhcmVudF9pZFxyXG4gIH1cclxufVxyXG5cclxuLy8gQm9va21hcmsgUG9zdCBpbnN0cnVjdGlvbiBkYXRhIGNsYXNzXHJcbmNsYXNzIEJvb2ttYXJrUG9zdEluc3RydWN0aW9uIHtcclxuICBwb3N0X2lkOiBiaWdpbnRcclxuXHJcbiAgY29uc3RydWN0b3IoZmllbGRzOiB7XHJcbiAgICBwb3N0X2lkOiBiaWdpbnRcclxuICB9KSB7XHJcbiAgICB0aGlzLnBvc3RfaWQgPSBmaWVsZHMucG9zdF9pZFxyXG4gIH1cclxufVxyXG5cclxuLy8gUHJvZmlsZSBzdHJ1Y3QgZm9yIGRlc2VyaWFsaXphdGlvbiAtIG1hdGNoaW5nIFJ1c3QgZXhhY3RseVxyXG5jbGFzcyBQcm9maWxlQWNjb3VudCB7XHJcbiAgaXNfaW5pdGlhbGl6ZWQ6IG51bWJlciAgLy8gdTggZnJvbSBSdXN0IGJvb2xcclxuICBvd25lcjogVWludDhBcnJheVxyXG4gIHVzZXJuYW1lOiBzdHJpbmdcclxuICBiaW86IHN0cmluZ1xyXG4gIHByb2ZpbGVfaW1hZ2U6IHN0cmluZ1xyXG4gIGNvdmVyX2ltYWdlOiBzdHJpbmdcclxuICBjcmVhdGVkX2F0OiBiaWdpbnRcclxuICBmb2xsb3dlcnNfY291bnQ6IGJpZ2ludFxyXG4gIGZvbGxvd2luZ19jb3VudDogYmlnaW50XHJcbiAgdXNlcl9jcmVkaXRfcmF0aW5nOiBiaWdpbnRcclxuICBwb3N0c19jb3VudDogYmlnaW50XHJcbiAgbGFzdF9wb3N0X3RpbWVzdGFtcDogYmlnaW50XHJcbiAgZGFpbHlfcG9zdF9jb3VudDogYmlnaW50XHJcbiAgaXNfdmVyaWZpZWQ6IG51bWJlciAgLy8gdTggZnJvbSBSdXN0IGJvb2xcclxuXHJcbiAgY29uc3RydWN0b3IoZmllbGRzOiBhbnkpIHtcclxuICAgIHRoaXMuaXNfaW5pdGlhbGl6ZWQgPSBmaWVsZHMuaXNfaW5pdGlhbGl6ZWRcclxuICAgIHRoaXMub3duZXIgPSBmaWVsZHMub3duZXJcclxuICAgIHRoaXMudXNlcm5hbWUgPSBmaWVsZHMudXNlcm5hbWVcclxuICAgIHRoaXMuYmlvID0gZmllbGRzLmJpb1xyXG4gICAgdGhpcy5wcm9maWxlX2ltYWdlID0gZmllbGRzLnByb2ZpbGVfaW1hZ2VcclxuICAgIHRoaXMuY292ZXJfaW1hZ2UgPSBmaWVsZHMuY292ZXJfaW1hZ2VcclxuICAgIHRoaXMuY3JlYXRlZF9hdCA9IGZpZWxkcy5jcmVhdGVkX2F0XHJcbiAgICB0aGlzLmZvbGxvd2Vyc19jb3VudCA9IGZpZWxkcy5mb2xsb3dlcnNfY291bnRcclxuICAgIHRoaXMuZm9sbG93aW5nX2NvdW50ID0gZmllbGRzLmZvbGxvd2luZ19jb3VudFxyXG4gICAgdGhpcy51c2VyX2NyZWRpdF9yYXRpbmcgPSBmaWVsZHMudXNlcl9jcmVkaXRfcmF0aW5nXHJcbiAgICB0aGlzLnBvc3RzX2NvdW50ID0gZmllbGRzLnBvc3RzX2NvdW50XHJcbiAgICB0aGlzLmxhc3RfcG9zdF90aW1lc3RhbXAgPSBmaWVsZHMubGFzdF9wb3N0X3RpbWVzdGFtcFxyXG4gICAgdGhpcy5kYWlseV9wb3N0X2NvdW50ID0gZmllbGRzLmRhaWx5X3Bvc3RfY291bnRcclxuICAgIHRoaXMuaXNfdmVyaWZpZWQgPSBmaWVsZHMuaXNfdmVyaWZpZWRcclxuICB9XHJcbn1cclxuXHJcbi8vIFBvc3Qgc3RydWN0IGZvciBkZXNlcmlhbGl6YXRpb24gLSBtYXRjaGluZyBSdXN0IGV4YWN0bHlcclxuY2xhc3MgUG9zdEFjY291bnQge1xyXG4gIGlzX2luaXRpYWxpemVkOiBudW1iZXIgIC8vIHU4IGZyb20gUnVzdCBib29sXHJcbiAgaWQ6IGJpZ2ludFxyXG4gIGF1dGhvcjogVWludDhBcnJheVxyXG4gIGNvbnRlbnQ6IHN0cmluZ1xyXG4gIHRpbWVzdGFtcDogYmlnaW50XHJcbiAgbGlrZXM6IGJpZ2ludFxyXG4gIGNvbW1lbnRzOiBiaWdpbnRcclxuICBtaXJyb3JzOiBiaWdpbnRcclxuICBpbWFnZXM6IHN0cmluZ1tdXHJcbiAgcmF0aW5nOiBudW1iZXJcclxuICBpbl9raWxsX3pvbmU6IG51bWJlciAgLy8gdTggZnJvbSBSdXN0IGJvb2xcclxuXHJcbiAgY29uc3RydWN0b3IoZmllbGRzOiBhbnkpIHtcclxuICAgIHRoaXMuaXNfaW5pdGlhbGl6ZWQgPSBmaWVsZHMuaXNfaW5pdGlhbGl6ZWRcclxuICAgIHRoaXMuaWQgPSBmaWVsZHMuaWRcclxuICAgIHRoaXMuYXV0aG9yID0gZmllbGRzLmF1dGhvclxyXG4gICAgdGhpcy5jb250ZW50ID0gZmllbGRzLmNvbnRlbnRcclxuICAgIHRoaXMudGltZXN0YW1wID0gZmllbGRzLnRpbWVzdGFtcFxyXG4gICAgdGhpcy5saWtlcyA9IGZpZWxkcy5saWtlc1xyXG4gICAgdGhpcy5jb21tZW50cyA9IGZpZWxkcy5jb21tZW50c1xyXG4gICAgdGhpcy5taXJyb3JzID0gZmllbGRzLm1pcnJvcnNcclxuICAgIHRoaXMuaW1hZ2VzID0gZmllbGRzLmltYWdlc1xyXG4gICAgdGhpcy5yYXRpbmcgPSBmaWVsZHMucmF0aW5nXHJcbiAgICB0aGlzLmluX2tpbGxfem9uZSA9IGZpZWxkcy5pbl9raWxsX3pvbmVcclxuICB9XHJcbn1cclxuXHJcbi8vIEJvcnNoIHNjaGVtYXNcclxuY29uc3QgY3JlYXRlUHJvZmlsZVNjaGVtYSA9IG5ldyBNYXAoW1xyXG4gIFtDcmVhdGVQcm9maWxlSW5zdHJ1Y3Rpb24sIHtcclxuICAgIGtpbmQ6ICdzdHJ1Y3QnLFxyXG4gICAgZmllbGRzOiBbXHJcbiAgICAgIFsndXNlcm5hbWUnLCAnc3RyaW5nJ10sXHJcbiAgICAgIFsnYmlvJywgJ3N0cmluZyddLFxyXG4gICAgICBbJ3Byb2ZpbGVfaW1hZ2UnLCAnc3RyaW5nJ10sXHJcbiAgICAgIFsnY292ZXJfaW1hZ2UnLCAnc3RyaW5nJ10sXHJcbiAgICBdLFxyXG4gIH1dLFxyXG5dKVxyXG5cclxuY29uc3QgY3JlYXRlUG9zdFNjaGVtYSA9IG5ldyBNYXAoW1xyXG4gIFtDcmVhdGVQb3N0SW5zdHJ1Y3Rpb24sIHtcclxuICAgIGtpbmQ6ICdzdHJ1Y3QnLFxyXG4gICAgZmllbGRzOiBbXHJcbiAgICAgIFsnY29udGVudCcsICdzdHJpbmcnXSxcclxuICAgICAgWydpbWFnZXMnLCBbJ3N0cmluZyddXSxcclxuICAgIF0sXHJcbiAgfV0sXHJcbl0pXHJcblxyXG5jb25zdCBsaWtlUG9zdFNjaGVtYSA9IG5ldyBNYXAoW1xyXG4gIFtMaWtlUG9zdEluc3RydWN0aW9uLCB7XHJcbiAgICBraW5kOiAnc3RydWN0JyxcclxuICAgIGZpZWxkczogW1xyXG4gICAgICBbJ3Bvc3RfaWQnLCAndTY0J10sXHJcbiAgICBdLFxyXG4gIH1dLFxyXG5dKVxyXG5cclxuY29uc3QgY29tbWVudE9uUG9zdFNjaGVtYSA9IG5ldyBNYXAoW1xyXG4gIFtDb21tZW50T25Qb3N0SW5zdHJ1Y3Rpb24sIHtcclxuICAgIGtpbmQ6ICdzdHJ1Y3QnLFxyXG4gICAgZmllbGRzOiBbXHJcbiAgICAgIFsnY29udGVudCcsICdzdHJpbmcnXSxcclxuICAgICAgWydwYXJlbnRfaWQnLCAndTY0J10sXHJcbiAgICBdLFxyXG4gIH1dLFxyXG5dKVxyXG5cclxuY29uc3QgYm9va21hcmtQb3N0U2NoZW1hID0gbmV3IE1hcChbXHJcbiAgW0Jvb2ttYXJrUG9zdEluc3RydWN0aW9uLCB7XHJcbiAgICBraW5kOiAnc3RydWN0JyxcclxuICAgIGZpZWxkczogW1xyXG4gICAgICBbJ3Bvc3RfaWQnLCAndTY0J10sXHJcbiAgICBdLFxyXG4gIH1dLFxyXG5dKVxyXG5cclxuY29uc3QgcHJvZmlsZUFjY291bnRTY2hlbWEgPSBuZXcgTWFwKFtcclxuICBbUHJvZmlsZUFjY291bnQsIHtcclxuICAgIGtpbmQ6ICdzdHJ1Y3QnLFxyXG4gICAgZmllbGRzOiBbXHJcbiAgICAgIFsnaXNfaW5pdGlhbGl6ZWQnLCAndTgnXSwgIC8vIFJ1c3QgYm9vbCBpcyBzZXJpYWxpemVkIGFzIHU4XHJcbiAgICAgIFsnb3duZXInLCBbMzJdXSxcclxuICAgICAgWyd1c2VybmFtZScsICdzdHJpbmcnXSxcclxuICAgICAgWydiaW8nLCAnc3RyaW5nJ10sXHJcbiAgICAgIFsncHJvZmlsZV9pbWFnZScsICdzdHJpbmcnXSxcclxuICAgICAgWydjb3Zlcl9pbWFnZScsICdzdHJpbmcnXSxcclxuICAgICAgWydjcmVhdGVkX2F0JywgJ3U2NCddLFxyXG4gICAgICBbJ2ZvbGxvd2Vyc19jb3VudCcsICd1NjQnXSxcclxuICAgICAgWydmb2xsb3dpbmdfY291bnQnLCAndTY0J10sXHJcbiAgICAgIFsndXNlcl9jcmVkaXRfcmF0aW5nJywgJ2k2NCddLFxyXG4gICAgICBbJ3Bvc3RzX2NvdW50JywgJ3U2NCddLFxyXG4gICAgICBbJ2xhc3RfcG9zdF90aW1lc3RhbXAnLCAndTY0J10sXHJcbiAgICAgIFsnZGFpbHlfcG9zdF9jb3VudCcsICd1NjQnXSxcclxuICAgICAgWydpc192ZXJpZmllZCcsICd1OCddLCAgLy8gUnVzdCBib29sIGlzIHNlcmlhbGl6ZWQgYXMgdThcclxuICAgIF0sXHJcbiAgfV0sXHJcbl0pXHJcblxyXG5jb25zdCBwb3N0QWNjb3VudFNjaGVtYSA9IG5ldyBNYXAoW1xyXG4gIFtQb3N0QWNjb3VudCwge1xyXG4gICAga2luZDogJ3N0cnVjdCcsXHJcbiAgICBmaWVsZHM6IFtcclxuICAgICAgWydpc19pbml0aWFsaXplZCcsICd1OCddLCAgLy8gUnVzdCBib29sIGlzIHNlcmlhbGl6ZWQgYXMgdThcclxuICAgICAgWydpZCcsICd1NjQnXSxcclxuICAgICAgWydhdXRob3InLCBbMzJdXSxcclxuICAgICAgWydjb250ZW50JywgJ3N0cmluZyddLFxyXG4gICAgICBbJ3RpbWVzdGFtcCcsICd1NjQnXSxcclxuICAgICAgWydsaWtlcycsICd1NjQnXSxcclxuICAgICAgWydjb21tZW50cycsICd1NjQnXSxcclxuICAgICAgWydtaXJyb3JzJywgJ3U2NCddLFxyXG4gICAgICBbJ2ltYWdlcycsIFsnc3RyaW5nJ11dLFxyXG4gICAgICBbJ3JhdGluZycsICd1OCddLFxyXG4gICAgICBbJ2luX2tpbGxfem9uZScsICd1OCddLCAgLy8gUnVzdCBib29sIGlzIHNlcmlhbGl6ZWQgYXMgdThcclxuICAgIF0sXHJcbiAgfV0sXHJcbl0pXHJcblxyXG4vLyBDb21tdW5pdHkvU3ViQmxvY2sgaW50ZXJmYWNlXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ29tbXVuaXR5IHtcclxuICBpc0luaXRpYWxpemVkOiBib29sZWFuXHJcbiAgaWQ6IG51bWJlclxyXG4gIGNyZWF0b3I6IFB1YmxpY0tleVxyXG4gIG5hbWU6IHN0cmluZ1xyXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmdcclxuICBhdmF0YXI6IHN0cmluZ1xyXG4gIHJ1bGVzOiBzdHJpbmdbXVxyXG4gIG1lbWJlckNvdW50OiBudW1iZXJcclxuICBjcmVhdGVkQXQ6IG51bWJlclxyXG4gIGlzUHJpdmF0ZTogYm9vbGVhblxyXG59XHJcblxyXG4vLyBDb21tdW5pdHkgc3RydWN0IGZvciBkZXNlcmlhbGl6YXRpb25cclxuY2xhc3MgQ29tbXVuaXR5QWNjb3VudCB7XHJcbiAgaXNfaW5pdGlhbGl6ZWQ6IG51bWJlclxyXG4gIGlkOiBiaWdpbnRcclxuICBjcmVhdG9yOiBVaW50OEFycmF5XHJcbiAgbmFtZTogc3RyaW5nXHJcbiAgZGVzY3JpcHRpb246IHN0cmluZ1xyXG4gIGF2YXRhcjogc3RyaW5nXHJcbiAgcnVsZXM6IHN0cmluZ1tdXHJcbiAgbWVtYmVyX2NvdW50OiBiaWdpbnRcclxuICBjcmVhdGVkX2F0OiBiaWdpbnRcclxuICBpc19wcml2YXRlOiBudW1iZXJcclxuXHJcbiAgY29uc3RydWN0b3IoZmllbGRzOiBhbnkpIHtcclxuICAgIHRoaXMuaXNfaW5pdGlhbGl6ZWQgPSBmaWVsZHMuaXNfaW5pdGlhbGl6ZWRcclxuICAgIHRoaXMuaWQgPSBmaWVsZHMuaWRcclxuICAgIHRoaXMuY3JlYXRvciA9IGZpZWxkcy5jcmVhdG9yXHJcbiAgICB0aGlzLm5hbWUgPSBmaWVsZHMubmFtZVxyXG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IGZpZWxkcy5kZXNjcmlwdGlvblxyXG4gICAgdGhpcy5hdmF0YXIgPSBmaWVsZHMuYXZhdGFyXHJcbiAgICB0aGlzLnJ1bGVzID0gZmllbGRzLnJ1bGVzXHJcbiAgICB0aGlzLm1lbWJlcl9jb3VudCA9IGZpZWxkcy5tZW1iZXJfY291bnRcclxuICAgIHRoaXMuY3JlYXRlZF9hdCA9IGZpZWxkcy5jcmVhdGVkX2F0XHJcbiAgICB0aGlzLmlzX3ByaXZhdGUgPSBmaWVsZHMuaXNfcHJpdmF0ZVxyXG4gIH1cclxufVxyXG5cclxuLy8gQ3JlYXRlIENvbW11bml0eSBpbnN0cnVjdGlvblxyXG5jbGFzcyBDcmVhdGVDb21tdW5pdHlJbnN0cnVjdGlvbiB7XHJcbiAgbmFtZTogc3RyaW5nXHJcbiAgZGVzY3JpcHRpb246IHN0cmluZ1xyXG4gIGF2YXRhcjogc3RyaW5nXHJcbiAgcnVsZXM6IHN0cmluZ1tdXHJcblxyXG4gIGNvbnN0cnVjdG9yKGZpZWxkczoge1xyXG4gICAgbmFtZTogc3RyaW5nXHJcbiAgICBkZXNjcmlwdGlvbjogc3RyaW5nXHJcbiAgICBhdmF0YXI6IHN0cmluZ1xyXG4gICAgcnVsZXM6IHN0cmluZ1tdXHJcbiAgfSkge1xyXG4gICAgdGhpcy5uYW1lID0gZmllbGRzLm5hbWVcclxuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBmaWVsZHMuZGVzY3JpcHRpb25cclxuICAgIHRoaXMuYXZhdGFyID0gZmllbGRzLmF2YXRhclxyXG4gICAgdGhpcy5ydWxlcyA9IGZpZWxkcy5ydWxlc1xyXG4gIH1cclxufVxyXG5cclxuLy8gRm9sbG93IFByb2ZpbGUgaW5zdHJ1Y3Rpb25cclxuY2xhc3MgRm9sbG93UHJvZmlsZUluc3RydWN0aW9uIHtcclxuICBwcm9maWxlX2lkOiBVaW50OEFycmF5XHJcblxyXG4gIGNvbnN0cnVjdG9yKGZpZWxkczoge1xyXG4gICAgcHJvZmlsZV9pZDogUHVibGljS2V5XHJcbiAgfSkge1xyXG4gICAgdGhpcy5wcm9maWxlX2lkID0gZmllbGRzLnByb2ZpbGVfaWQudG9CdWZmZXIoKVxyXG4gIH1cclxufVxyXG5cclxuY29uc3QgY3JlYXRlQ29tbXVuaXR5U2NoZW1hID0gbmV3IE1hcChbXHJcbiAgW0NyZWF0ZUNvbW11bml0eUluc3RydWN0aW9uLCB7XHJcbiAgICBraW5kOiAnc3RydWN0JyxcclxuICAgIGZpZWxkczogW1xyXG4gICAgICBbJ25hbWUnLCAnc3RyaW5nJ10sXHJcbiAgICAgIFsnZGVzY3JpcHRpb24nLCAnc3RyaW5nJ10sXHJcbiAgICAgIFsnYXZhdGFyJywgJ3N0cmluZyddLFxyXG4gICAgICBbJ3J1bGVzJywgWydzdHJpbmcnXV0sXHJcbiAgICBdLFxyXG4gIH1dLFxyXG5dKVxyXG5cclxuY29uc3QgZm9sbG93UHJvZmlsZVNjaGVtYSA9IG5ldyBNYXAoW1xyXG4gIFtGb2xsb3dQcm9maWxlSW5zdHJ1Y3Rpb24sIHtcclxuICAgIGtpbmQ6ICdzdHJ1Y3QnLFxyXG4gICAgZmllbGRzOiBbXHJcbiAgICAgIFsncHJvZmlsZV9pZCcsIFszMl1dLFxyXG4gICAgXSxcclxuICB9XSxcclxuXSlcclxuXHJcbmNvbnN0IGNvbW11bml0eUFjY291bnRTY2hlbWEgPSBuZXcgTWFwKFtcclxuICBbQ29tbXVuaXR5QWNjb3VudCwge1xyXG4gICAga2luZDogJ3N0cnVjdCcsXHJcbiAgICBmaWVsZHM6IFtcclxuICAgICAgWydpc19pbml0aWFsaXplZCcsICd1OCddLFxyXG4gICAgICBbJ2lkJywgJ3U2NCddLFxyXG4gICAgICBbJ2NyZWF0b3InLCBbMzJdXSxcclxuICAgICAgWyduYW1lJywgJ3N0cmluZyddLFxyXG4gICAgICBbJ2Rlc2NyaXB0aW9uJywgJ3N0cmluZyddLFxyXG4gICAgICBbJ2F2YXRhcicsICdzdHJpbmcnXSxcclxuICAgICAgWydydWxlcycsIFsnc3RyaW5nJ11dLFxyXG4gICAgICBbJ21lbWJlcl9jb3VudCcsICd1NjQnXSxcclxuICAgICAgWydjcmVhdGVkX2F0JywgJ3U2NCddLFxyXG4gICAgICBbJ2lzX3ByaXZhdGUnLCAndTgnXSxcclxuICAgIF0sXHJcbiAgfV0sXHJcbl0pXHJcblxyXG4vLyBQcm9maWxlIGludGVyZmFjZVxyXG5leHBvcnQgaW50ZXJmYWNlIFByb2ZpbGUge1xyXG4gIGlzSW5pdGlhbGl6ZWQ6IGJvb2xlYW5cclxuICBvd25lcjogUHVibGljS2V5XHJcbiAgdXNlcm5hbWU6IHN0cmluZ1xyXG4gIGJpbzogc3RyaW5nXHJcbiAgcHJvZmlsZUltYWdlOiBzdHJpbmdcclxuICBjb3ZlckltYWdlOiBzdHJpbmdcclxuICBjcmVhdGVkQXQ6IG51bWJlclxyXG4gIGZvbGxvd2Vyc0NvdW50OiBudW1iZXJcclxuICBmb2xsb3dpbmdDb3VudDogbnVtYmVyXHJcbiAgdXNlckNyZWRpdFJhdGluZzogbnVtYmVyXHJcbiAgcG9zdHNDb3VudDogbnVtYmVyXHJcbiAgbGFzdFBvc3RUaW1lc3RhbXA6IG51bWJlclxyXG4gIGRhaWx5UG9zdENvdW50OiBudW1iZXJcclxuICBpc1ZlcmlmaWVkOiBib29sZWFuXHJcbn1cclxuXHJcbi8vIFBvc3QgaW50ZXJmYWNlXHJcbmV4cG9ydCBpbnRlcmZhY2UgUG9zdCB7XHJcbiAgaXNJbml0aWFsaXplZDogYm9vbGVhblxyXG4gIGlkOiBudW1iZXJcclxuICBhdXRob3I6IFB1YmxpY0tleVxyXG4gIGNvbnRlbnQ6IHN0cmluZ1xyXG4gIHRpbWVzdGFtcDogbnVtYmVyXHJcbiAgbGlrZXM6IG51bWJlclxyXG4gIGNvbW1lbnRzOiBudW1iZXJcclxuICBtaXJyb3JzOiBudW1iZXJcclxuICBpbWFnZXM6IHN0cmluZ1tdXHJcbiAgcmF0aW5nOiBQb3N0UmF0aW5nXHJcbiAgaW5LaWxsWm9uZTogYm9vbGVhblxyXG4gIHBhcmVudElkPzogbnVtYmVyXHJcbiAgaXNDb21tZW50PzogYm9vbGVhblxyXG59XHJcblxyXG4vLyBDYWNoZSBmb3IgcHJvZmlsZSBsb29rdXBzIHRvIGF2b2lkIHJlcGVhdGVkIGJsb2NrY2hhaW4gY2FsbHNcclxuY29uc3QgcHJvZmlsZUNhY2hlID0gbmV3IE1hcDxzdHJpbmcsIFByb2ZpbGUgfCBudWxsPigpXHJcbmNvbnN0IENBQ0hFX0RVUkFUSU9OID0gNjAwMDAgLy8gMSBtaW51dGUgZm9yIG1lbW9yeSBjYWNoZSAoaW5jcmVhc2VkIGZyb20gMzAgc2Vjb25kcylcclxuXHJcbi8vIFBvc3RzIGNhY2hlXHJcbmxldCBwb3N0c0NhY2hlOiB7IHBvc3RzOiBQb3N0W10sIHRpbWVzdGFtcDogbnVtYmVyIH0gfCBudWxsID0gbnVsbFxyXG5jb25zdCBQT1NUU19DQUNIRV9EVVJBVElPTiA9IDMwMDAwIC8vIDMwIHNlY29uZHMgZm9yIHBvc3RzIGNhY2hlIChpbmNyZWFzZWQgZnJvbSAxMCBzZWNvbmRzKVxyXG5cclxuLy8gbG9jYWxTdG9yYWdlIGNhY2hlIGNvbmZpZ3VyYXRpb24gLSBVcGRhdGVkIHRvIHN1cHBvcnQgbXVsdGlwbGUgcHJvZmlsZXNcclxuY29uc3QgTE9DQUxTVE9SQUdFX0NBQ0hFX1BSRUZJWCA9ICdibG9ja3NfcHJvZmlsZV8nXHJcbmNvbnN0IExPQ0FMU1RPUkFHRV9DQUNIRV9EVVJBVElPTiA9IDEwICogNjAgKiAxMDAwIC8vIDEwIG1pbnV0ZXMgZm9yIGxvY2FsU3RvcmFnZSBjYWNoZSAoaW5jcmVhc2VkIGZyb20gNSBtaW51dGVzKVxyXG5cclxuaW50ZXJmYWNlIENhY2hlZFByb2ZpbGUge1xyXG4gIHByb2ZpbGU6IFByb2ZpbGUgfCBudWxsXHJcbiAgdGltZXN0YW1wOiBudW1iZXJcclxuICB3YWxsZXRBZGRyZXNzOiBzdHJpbmdcclxufVxyXG5cclxuLy8gbG9jYWxTdG9yYWdlIGNhY2hlIHV0aWxpdGllcyAtIFVwZGF0ZWQgdG8gc3VwcG9ydCBtdWx0aXBsZSBwcm9maWxlc1xyXG5jb25zdCBzYXZlUHJvZmlsZVRvTG9jYWxTdG9yYWdlID0gKHdhbGxldEFkZHJlc3M6IHN0cmluZywgcHJvZmlsZTogUHJvZmlsZSB8IG51bGwpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgY2FjaGVLZXkgPSBgJHtMT0NBTFNUT1JBR0VfQ0FDSEVfUFJFRklYfSR7d2FsbGV0QWRkcmVzc31gXHJcbiAgICBjb25zdCBjYWNoZURhdGE6IENhY2hlZFByb2ZpbGUgPSB7XHJcbiAgICAgIHByb2ZpbGUsXHJcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgd2FsbGV0QWRkcmVzc1xyXG4gICAgfVxyXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oY2FjaGVLZXksIEpTT04uc3RyaW5naWZ5KGNhY2hlRGF0YSkpXHJcbiAgICBjb25zb2xlLmxvZyhg8J+SviBQcm9maWxlIGNhY2hlZCB0byBsb2NhbFN0b3JhZ2UgZm9yICR7d2FsbGV0QWRkcmVzcy5zbGljZSgwLCA4KX1gKVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBzYXZlIHByb2ZpbGUgdG8gbG9jYWxTdG9yYWdlOicsIGVycm9yKVxyXG4gIH1cclxufVxyXG5cclxuY29uc3QgZ2V0UHJvZmlsZUZyb21Mb2NhbFN0b3JhZ2UgPSAod2FsbGV0QWRkcmVzczogc3RyaW5nKTogUHJvZmlsZSB8IG51bGwgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBjYWNoZUtleSA9IGAke0xPQ0FMU1RPUkFHRV9DQUNIRV9QUkVGSVh9JHt3YWxsZXRBZGRyZXNzfWBcclxuICAgIGNvbnN0IGNhY2hlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGNhY2hlS2V5KVxyXG4gICAgaWYgKCFjYWNoZWQpIHJldHVybiBudWxsXHJcblxyXG4gICAgY29uc3QgY2FjaGVEYXRhOiBDYWNoZWRQcm9maWxlID0gSlNPTi5wYXJzZShjYWNoZWQpXHJcbiAgICBcclxuICAgIC8vIENoZWNrIGlmIGNhY2hlIGlzIGV4cGlyZWRcclxuICAgIGlmIChEYXRlLm5vdygpIC0gY2FjaGVEYXRhLnRpbWVzdGFtcCA+IExPQ0FMU1RPUkFHRV9DQUNIRV9EVVJBVElPTikge1xyXG4gICAgICBjb25zb2xlLmxvZyhg4o+wIENhY2hlIGV4cGlyZWQgZm9yICR7d2FsbGV0QWRkcmVzcy5zbGljZSgwLCA4KX0sIGNsZWFyaW5nYClcclxuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oY2FjaGVLZXkpXHJcbiAgICAgIHJldHVybiBudWxsXHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKGDimqEgVXNpbmcgY2FjaGVkIHByb2ZpbGUgZnJvbSBsb2NhbFN0b3JhZ2UgZm9yICR7d2FsbGV0QWRkcmVzcy5zbGljZSgwLCA4KX1gKVxyXG4gICAgcmV0dXJuIGNhY2hlRGF0YS5wcm9maWxlXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHJlYWQgcHJvZmlsZSBmcm9tIGxvY2FsU3RvcmFnZTonLCBlcnJvcilcclxuICAgIGNvbnN0IGNhY2hlS2V5ID0gYCR7TE9DQUxTVE9SQUdFX0NBQ0hFX1BSRUZJWH0ke3dhbGxldEFkZHJlc3N9YFxyXG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oY2FjaGVLZXkpXHJcbiAgICByZXR1cm4gbnVsbFxyXG4gIH1cclxufVxyXG5cclxuY29uc3QgY2xlYXJQcm9maWxlQ2FjaGUgPSAod2FsbGV0QWRkcmVzcz86IHN0cmluZykgPT4ge1xyXG4gIC8vIENsZWFyIG1lbW9yeSBjYWNoZVxyXG4gIGlmICh3YWxsZXRBZGRyZXNzKSB7XHJcbiAgICBwcm9maWxlQ2FjaGUuZGVsZXRlKHdhbGxldEFkZHJlc3MpXHJcbiAgICAvLyBDbGVhciBsb2NhbFN0b3JhZ2UgY2FjaGUgZm9yIHNwZWNpZmljIHVzZXJcclxuICAgIGNvbnN0IGNhY2hlS2V5ID0gYCR7TE9DQUxTVE9SQUdFX0NBQ0hFX1BSRUZJWH0ke3dhbGxldEFkZHJlc3N9YFxyXG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oY2FjaGVLZXkpXHJcbiAgfSBlbHNlIHtcclxuICAgIHByb2ZpbGVDYWNoZS5jbGVhcigpXHJcbiAgICAvLyBDbGVhciBhbGwgbG9jYWxTdG9yYWdlIHByb2ZpbGUgY2FjaGVzXHJcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobG9jYWxTdG9yYWdlKVxyXG4gICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChMT0NBTFNUT1JBR0VfQ0FDSEVfUFJFRklYKSkge1xyXG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSlcclxuICAgICAgfVxyXG4gICAgfSlcclxuICB9XHJcbiAgXHJcbiAgLy8gQ2xlYXIgcG9zdHMgY2FjaGVcclxuICBwb3N0c0NhY2hlID0gbnVsbFxyXG4gIFxyXG4gIGNvbnNvbGUubG9nKCfwn5eR77iPIFByb2ZpbGUgYW5kIHBvc3RzIGNhY2hlIGNsZWFyZWQnKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlQmxvY2tzUHJvZ3JhbSgpIHtcclxuICBjb25zdCB7IGNvbm5lY3Rpb24gfSA9IHVzZUNvbm5lY3Rpb24oKVxyXG4gIGNvbnN0IHsgcHVibGljS2V5LCBzZW5kVHJhbnNhY3Rpb24gfSA9IHVzZVdhbGxldCgpXHJcblxyXG4gIC8vIEdldCBwcm9maWxlIFBEQVxyXG4gIGNvbnN0IGdldFByb2ZpbGVQREEgPSBhc3luYyAodXNlclB1YmxpY0tleTogUHVibGljS2V5LCB1c2VybmFtZTogc3RyaW5nKTogUHJvbWlzZTxQdWJsaWNLZXk+ID0+IHtcclxuICAgIGNvbnN0IFtwcm9maWxlUERBXSA9IGF3YWl0IFB1YmxpY0tleS5maW5kUHJvZ3JhbUFkZHJlc3MoXHJcbiAgICAgIFt1c2VyUHVibGljS2V5LnRvQnVmZmVyKCksIEJ1ZmZlci5mcm9tKCdwcm9maWxlJyksIEJ1ZmZlci5mcm9tKHVzZXJuYW1lKV0sXHJcbiAgICAgIFBST0dSQU1fSURcclxuICAgIClcclxuICAgIHJldHVybiBwcm9maWxlUERBXHJcbiAgfVxyXG5cclxuICAvLyBHZXQgcG9zdCBQREFcclxuICBjb25zdCBnZXRQb3N0UERBID0gYXN5bmMgKHVzZXJQdWJsaWNLZXk6IFB1YmxpY0tleSwgcG9zdElkOiBudW1iZXIpOiBQcm9taXNlPFB1YmxpY0tleT4gPT4ge1xyXG4gICAgY29uc3QgW3Bvc3RQREFdID0gYXdhaXQgUHVibGljS2V5LmZpbmRQcm9ncmFtQWRkcmVzcyhcclxuICAgICAgW3VzZXJQdWJsaWNLZXkudG9CdWZmZXIoKSwgQnVmZmVyLmZyb20oJ3Bvc3QnKSwgQnVmZmVyLmZyb20ocG9zdElkLnRvU3RyaW5nKCkpXSxcclxuICAgICAgUFJPR1JBTV9JRFxyXG4gICAgKVxyXG4gICAgcmV0dXJuIHBvc3RQREFcclxuICB9XHJcblxyXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjaGVjayBpZiBwcm9ncmFtIGV4aXN0c1xyXG4gIGNvbnN0IGNoZWNrUHJvZ3JhbUV4aXN0cyA9IGFzeW5jICgpOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHByb2dyYW1JbmZvID0gYXdhaXQgY29ubmVjdGlvbi5nZXRBY2NvdW50SW5mbyhQUk9HUkFNX0lEKVxyXG4gICAgICByZXR1cm4gcHJvZ3JhbUluZm8gIT09IG51bGwgJiYgcHJvZ3JhbUluZm8uZXhlY3V0YWJsZVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgcHJvZ3JhbSBleGlzdGVuY2U6JywgZXJyb3IpXHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNoZWNrIFNPTCBiYWxhbmNlXHJcbiAgY29uc3QgY2hlY2tTT0xCYWxhbmNlID0gYXN5bmMgKCk6IFByb21pc2U8bnVtYmVyPiA9PiB7XHJcbiAgICBpZiAoIXB1YmxpY0tleSkgcmV0dXJuIDBcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBjb25uZWN0aW9uLmdldEJhbGFuY2UocHVibGljS2V5KVxyXG4gICAgICByZXR1cm4gYmFsYW5jZSAvIExBTVBPUlRTX1BFUl9TT0xcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIFNPTCBiYWxhbmNlOicsIGVycm9yKVxyXG4gICAgICByZXR1cm4gMFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQ29udmVydCBQcm9maWxlQWNjb3VudCB0byBQcm9maWxlIGludGVyZmFjZVxyXG4gIGNvbnN0IGNvbnZlcnRQcm9maWxlQWNjb3VudCA9IChwcm9maWxlQWNjb3VudDogUHJvZmlsZUFjY291bnQpOiBQcm9maWxlID0+IHtcclxuICAgIC8vIENhbGN1bGF0ZSBVQ1IgYmFzZWQgb24gYWN0aXZpdHlcclxuICAgIGNvbnN0IGNhbGN1bGF0ZVVDUiA9IChwcm9maWxlOiBQcm9maWxlQWNjb3VudCkgPT4ge1xyXG4gICAgICBjb25zdCBwb3N0c0NvdW50ID0gTnVtYmVyKHByb2ZpbGUucG9zdHNfY291bnQpXHJcbiAgICAgIGNvbnN0IGZvbGxvd2Vyc0NvdW50ID0gTnVtYmVyKHByb2ZpbGUuZm9sbG93ZXJzX2NvdW50KVxyXG4gICAgICBjb25zdCBmb2xsb3dpbmdDb3VudCA9IE51bWJlcihwcm9maWxlLmZvbGxvd2luZ19jb3VudClcclxuICAgICAgXHJcbiAgICAgIC8vIEJhc2UgVUNSIGNhbGN1bGF0aW9uIGFsZ29yaXRobVxyXG4gICAgICBsZXQgdWNyID0gMS4wIC8vIFN0YXJ0IHdpdGggYmFzZSByYXRpbmdcclxuICAgICAgXHJcbiAgICAgIC8vIFBvc3RzIGZhY3RvciAoMC4xIHBvaW50cyBwZXIgcG9zdCwgbWF4IDIuMCBwb2ludHMpXHJcbiAgICAgIGNvbnN0IHBvc3RzU2NvcmUgPSBNYXRoLm1pbihwb3N0c0NvdW50ICogMC4xLCAyLjApXHJcbiAgICAgIFxyXG4gICAgICAvLyBGb2xsb3dlcnMgZmFjdG9yICgwLjA1IHBvaW50cyBwZXIgZm9sbG93ZXIsIG1heCAxLjUgcG9pbnRzKVxyXG4gICAgICBjb25zdCBmb2xsb3dlcnNTY29yZSA9IE1hdGgubWluKGZvbGxvd2Vyc0NvdW50ICogMC4wNSwgMS41KVxyXG4gICAgICBcclxuICAgICAgLy8gRm9sbG93aW5nL2ZvbGxvd2VycyByYXRpbyAoaGVhbHRoeSByYXRpbyA9IGJvbnVzKVxyXG4gICAgICBsZXQgcmF0aW9Cb251cyA9IDBcclxuICAgICAgaWYgKGZvbGxvd2Vyc0NvdW50ID4gMCAmJiBmb2xsb3dpbmdDb3VudCA+IDApIHtcclxuICAgICAgICBjb25zdCByYXRpbyA9IGZvbGxvd2Vyc0NvdW50IC8gZm9sbG93aW5nQ291bnRcclxuICAgICAgICBpZiAocmF0aW8gPj0gMC41ICYmIHJhdGlvIDw9IDIuMCkgeyAvLyBIZWFsdGh5IHJhdGlvXHJcbiAgICAgICAgICByYXRpb0JvbnVzID0gMC4zXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBBY2NvdW50IGFnZSBmYWN0b3IgKG9sZGVyIGFjY291bnRzIGdldCBib251cylcclxuICAgICAgY29uc3QgYWNjb3VudEFnZSA9IERhdGUubm93KCkgLSBOdW1iZXIocHJvZmlsZS5jcmVhdGVkX2F0KSAqIDEwMDBcclxuICAgICAgY29uc3QgZGF5c09sZCA9IGFjY291bnRBZ2UgLyAoMTAwMCAqIDYwICogNjAgKiAyNClcclxuICAgICAgY29uc3QgYWdlQm9udXMgPSBNYXRoLm1pbihkYXlzT2xkIC8gMzAgKiAwLjIsIDEuMCkgLy8gMC4yIHBvaW50cyBwZXIgbW9udGgsIG1heCAxLjBcclxuICAgICAgXHJcbiAgICAgIC8vIFZlcmlmaWNhdGlvbiBib251c1xyXG4gICAgICBjb25zdCB2ZXJpZmljYXRpb25Cb251cyA9IHByb2ZpbGUuaXNfdmVyaWZpZWQgPT09IDEgPyAwLjUgOiAwXHJcbiAgICAgIFxyXG4gICAgICAvLyBBY3Rpdml0eSBmYWN0b3IgKHBvc3RpbmcgcmVndWxhcmx5KVxyXG4gICAgICBjb25zdCBsYXN0UG9zdEFnZSA9IERhdGUubm93KCkgLSBOdW1iZXIocHJvZmlsZS5sYXN0X3Bvc3RfdGltZXN0YW1wKSAqIDEwMDBcclxuICAgICAgY29uc3QgZGF5c1NpbmNlTGFzdFBvc3QgPSBsYXN0UG9zdEFnZSAvICgxMDAwICogNjAgKiA2MCAqIDI0KVxyXG4gICAgICBjb25zdCBhY3Rpdml0eUJvbnVzID0gZGF5c1NpbmNlTGFzdFBvc3QgPCA3ID8gMC4zIDogZGF5c1NpbmNlTGFzdFBvc3QgPCAzMCA/IDAuMSA6IDBcclxuICAgICAgXHJcbiAgICAgIHVjciA9IHVjciArIHBvc3RzU2NvcmUgKyBmb2xsb3dlcnNTY29yZSArIHJhdGlvQm9udXMgKyBhZ2VCb251cyArIHZlcmlmaWNhdGlvbkJvbnVzICsgYWN0aXZpdHlCb251c1xyXG4gICAgICBcclxuICAgICAgLy8gQ2FwIGF0IDUuMCBtYXhcclxuICAgICAgcmV0dXJuIE1hdGgubWluKHVjciwgNS4wKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlzSW5pdGlhbGl6ZWQ6IHByb2ZpbGVBY2NvdW50LmlzX2luaXRpYWxpemVkID09PSAxLFxyXG4gICAgICBvd25lcjogbmV3IFB1YmxpY0tleShwcm9maWxlQWNjb3VudC5vd25lciksXHJcbiAgICAgIHVzZXJuYW1lOiBwcm9maWxlQWNjb3VudC51c2VybmFtZSxcclxuICAgICAgYmlvOiBwcm9maWxlQWNjb3VudC5iaW8sXHJcbiAgICAgIHByb2ZpbGVJbWFnZTogcHJvZmlsZUFjY291bnQucHJvZmlsZV9pbWFnZSxcclxuICAgICAgY292ZXJJbWFnZTogcHJvZmlsZUFjY291bnQuY292ZXJfaW1hZ2UsXHJcbiAgICAgIGNyZWF0ZWRBdDogTnVtYmVyKHByb2ZpbGVBY2NvdW50LmNyZWF0ZWRfYXQpICogMTAwMCwgLy8gQ29udmVydCBzZWNvbmRzIHRvIG1pbGxpc2Vjb25kc1xyXG4gICAgICBmb2xsb3dlcnNDb3VudDogTnVtYmVyKHByb2ZpbGVBY2NvdW50LmZvbGxvd2Vyc19jb3VudCksXHJcbiAgICAgIGZvbGxvd2luZ0NvdW50OiBOdW1iZXIocHJvZmlsZUFjY291bnQuZm9sbG93aW5nX2NvdW50KSxcclxuICAgICAgdXNlckNyZWRpdFJhdGluZzogY2FsY3VsYXRlVUNSKHByb2ZpbGVBY2NvdW50KSwgLy8gVXNlIGNhbGN1bGF0ZWQgVUNSIGluc3RlYWQgb2Ygc3RvcmVkIHZhbHVlXHJcbiAgICAgIHBvc3RzQ291bnQ6IE51bWJlcihwcm9maWxlQWNjb3VudC5wb3N0c19jb3VudCksXHJcbiAgICAgIGxhc3RQb3N0VGltZXN0YW1wOiBOdW1iZXIocHJvZmlsZUFjY291bnQubGFzdF9wb3N0X3RpbWVzdGFtcCkgKiAxMDAwLCAvLyBDb252ZXJ0IHNlY29uZHMgdG8gbWlsbGlzZWNvbmRzXHJcbiAgICAgIGRhaWx5UG9zdENvdW50OiBOdW1iZXIocHJvZmlsZUFjY291bnQuZGFpbHlfcG9zdF9jb3VudCksXHJcbiAgICAgIGlzVmVyaWZpZWQ6IHByb2ZpbGVBY2NvdW50LmlzX3ZlcmlmaWVkID09PSAxLFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQ29udmVydCBQb3N0QWNjb3VudCB0byBQb3N0IGludGVyZmFjZVxyXG4gIGNvbnN0IGNvbnZlcnRQb3N0QWNjb3VudCA9IChwb3N0QWNjb3VudDogUG9zdEFjY291bnQpOiBQb3N0ID0+IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlzSW5pdGlhbGl6ZWQ6IHBvc3RBY2NvdW50LmlzX2luaXRpYWxpemVkID09PSAxLFxyXG4gICAgICBpZDogTnVtYmVyKHBvc3RBY2NvdW50LmlkKSxcclxuICAgICAgYXV0aG9yOiBuZXcgUHVibGljS2V5KHBvc3RBY2NvdW50LmF1dGhvciksXHJcbiAgICAgIGNvbnRlbnQ6IHBvc3RBY2NvdW50LmNvbnRlbnQsXHJcbiAgICAgIHRpbWVzdGFtcDogTnVtYmVyKHBvc3RBY2NvdW50LnRpbWVzdGFtcCkgKiAxMDAwLCAvLyBDb252ZXJ0IHNlY29uZHMgdG8gbWlsbGlzZWNvbmRzXHJcbiAgICAgIGxpa2VzOiBOdW1iZXIocG9zdEFjY291bnQubGlrZXMpLFxyXG4gICAgICBjb21tZW50czogTnVtYmVyKHBvc3RBY2NvdW50LmNvbW1lbnRzKSxcclxuICAgICAgbWlycm9yczogTnVtYmVyKHBvc3RBY2NvdW50Lm1pcnJvcnMpLFxyXG4gICAgICBpbWFnZXM6IHBvc3RBY2NvdW50LmltYWdlcyxcclxuICAgICAgcmF0aW5nOiBwb3N0QWNjb3VudC5yYXRpbmcgYXMgUG9zdFJhdGluZyxcclxuICAgICAgaW5LaWxsWm9uZTogcG9zdEFjY291bnQuaW5fa2lsbF96b25lID09PSAxLFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQ3JlYXRlIHVzZXIgcHJvZmlsZSAtIFJFQUwgSU1QTEVNRU5UQVRJT05cclxuICBjb25zdCBjcmVhdGVQcm9maWxlID0gYXN5bmMgKFxyXG4gICAgdXNlcm5hbWU6IHN0cmluZyxcclxuICAgIGJpbzogc3RyaW5nLFxyXG4gICAgcHJvZmlsZUltYWdlOiBzdHJpbmcsXHJcbiAgICBjb3ZlckltYWdlOiBzdHJpbmdcclxuICApID0+IHtcclxuICAgIGlmICghcHVibGljS2V5KSB0aHJvdyBuZXcgRXJyb3IoJ1dhbGxldCBub3QgY29ubmVjdGVkJylcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+UjSBSdW5uaW5nIHByZS1mbGlnaHQgY2hlY2tzLi4uJylcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBjaGVja1NPTEJhbGFuY2UoKVxyXG4gICAgICBjb25zb2xlLmxvZyhg8J+SsCBTT0wgQmFsYW5jZTogJHtiYWxhbmNlfWApXHJcbiAgICAgIGlmIChiYWxhbmNlIDwgMC4xKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN1ZmZpY2llbnQgU09MIGJhbGFuY2U6ICR7YmFsYW5jZX0uIFlvdSBuZWVkIGF0IGxlYXN0IDAuMSBTT0wgZm9yIHRyYW5zYWN0aW9uIGZlZXMgYW5kIGFjY291bnQgY3JlYXRpb24uYClcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgcHJvZ3JhbUV4aXN0cyA9IGF3YWl0IGNoZWNrUHJvZ3JhbUV4aXN0cygpXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OLIFByb2dyYW0gZXhpc3RzOiAke3Byb2dyYW1FeGlzdHN9YClcclxuICAgICAgaWYgKCFwcm9ncmFtRXhpc3RzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9ncmFtIG5vdCBmb3VuZCBhdCBhZGRyZXNzOiAke1BST0dSQU1fSUQudG9TdHJpbmcoKX0uIE1ha2Ugc3VyZSB0aGUgcHJvZ3JhbSBpcyBkZXBsb3llZCBvbiAke2NvbmZpZy5zb2xhbmEubmV0d29ya30uYClcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc29sZS5sb2coJ+KchSBQcmUtZmxpZ2h0IGNoZWNrcyBwYXNzZWQnKVxyXG5cclxuICAgICAgY29uc3QgcHJvZmlsZVBEQSA9IGF3YWl0IGdldFByb2ZpbGVQREEocHVibGljS2V5LCB1c2VybmFtZSlcclxuICAgICAgY29uc29sZS5sb2coYPCfk40gUHJvZmlsZSBQREE6ICR7cHJvZmlsZVBEQS50b1N0cmluZygpfWApXHJcblxyXG4gICAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSBuZXcgQ3JlYXRlUHJvZmlsZUluc3RydWN0aW9uKHtcclxuICAgICAgICB1c2VybmFtZSxcclxuICAgICAgICBiaW8sXHJcbiAgICAgICAgcHJvZmlsZV9pbWFnZTogcHJvZmlsZUltYWdlLFxyXG4gICAgICAgIGNvdmVyX2ltYWdlOiBjb3ZlckltYWdlLFxyXG4gICAgICB9KVxyXG5cclxuICAgICAgY29uc3QgY3JlYXRlUHJvZmlsZVZhcmlhbnQgPSBCdWZmZXIuZnJvbShbMF0pXHJcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWREYXRhID0gc2VyaWFsaXplKGNyZWF0ZVByb2ZpbGVTY2hlbWEsIGluc3RydWN0aW9uRGF0YSlcclxuICAgICAgY29uc3QgZnVsbEluc3RydWN0aW9uRGF0YSA9IEJ1ZmZlci5jb25jYXQoW2NyZWF0ZVByb2ZpbGVWYXJpYW50LCBCdWZmZXIuZnJvbShzZXJpYWxpemVkRGF0YSldKVxyXG5cclxuICAgICAgY29uc3QgaW5zdHJ1Y3Rpb24gPSBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XHJcbiAgICAgICAga2V5czogW1xyXG4gICAgICAgICAgeyBwdWJrZXk6IHB1YmxpY0tleSwgaXNTaWduZXI6IHRydWUsIGlzV3JpdGFibGU6IHRydWUgfSxcclxuICAgICAgICAgIHsgcHVia2V5OiBwcm9maWxlUERBLCBpc1NpZ25lcjogZmFsc2UsIGlzV3JpdGFibGU6IHRydWUgfSxcclxuICAgICAgICAgIHsgcHVia2V5OiBTeXN0ZW1Qcm9ncmFtLnByb2dyYW1JZCwgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiBmYWxzZSB9LFxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgcHJvZ3JhbUlkOiBQUk9HUkFNX0lELFxyXG4gICAgICAgIGRhdGE6IGZ1bGxJbnN0cnVjdGlvbkRhdGEsXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpLmFkZChpbnN0cnVjdGlvbilcclxuICAgICAgY29uc3QgeyBibG9ja2hhc2ggfSA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2toYXNoKCdwcm9jZXNzZWQnKVxyXG4gICAgICB0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBibG9ja2hhc2hcclxuICAgICAgdHJhbnNhY3Rpb24uZmVlUGF5ZXIgPSBwdWJsaWNLZXlcclxuXHJcbiAgICAgIGNvbnN0IHNpbXVsYXRpb24gPSBhd2FpdCBjb25uZWN0aW9uLnNpbXVsYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pXHJcbiAgICAgIGlmIChzaW11bGF0aW9uLnZhbHVlLmVycikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gc2ltdWxhdGlvbiBmYWlsZWQ6ICR7SlNPTi5zdHJpbmdpZnkoc2ltdWxhdGlvbi52YWx1ZS5lcnIpfWApXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgY29ubmVjdGlvbiwge1xyXG4gICAgICAgIHNraXBQcmVmbGlnaHQ6IGZhbHNlLFxyXG4gICAgICAgIHByZWZsaWdodENvbW1pdG1lbnQ6ICdwcm9jZXNzZWQnLFxyXG4gICAgICAgIG1heFJldHJpZXM6IDMsXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbih7XHJcbiAgICAgICAgc2lnbmF0dXJlLFxyXG4gICAgICAgIGJsb2NraGFzaCxcclxuICAgICAgICBsYXN0VmFsaWRCbG9ja0hlaWdodDogKGF3YWl0IGNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2toYXNoKCkpLmxhc3RWYWxpZEJsb2NrSGVpZ2h0LFxyXG4gICAgICB9LCAncHJvY2Vzc2VkJylcclxuICAgICAgXHJcbiAgICAgIC8vIEludmFsaWRhdGUgY2FjaGUgYWZ0ZXIgcHJvZmlsZSBjcmVhdGlvblxyXG4gICAgICBjbGVhclByb2ZpbGVDYWNoZShwdWJsaWNLZXkudG9TdHJpbmcoKSlcclxuICAgICAgXHJcbiAgICAgIHRvYXN0LnN1Y2Nlc3MoJ1Byb2ZpbGUgY3JlYXRlZCBzdWNjZXNzZnVsbHkhJylcclxuICAgICAgcmV0dXJuIHNpZ25hdHVyZVxyXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgUHJvZmlsZSBjcmVhdGlvbiBlcnJvcjonLCBlcnJvcilcclxuICAgICAgdG9hc3QuZXJyb3IoYFRyYW5zYWN0aW9uIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJ31gKVxyXG4gICAgICB0aHJvdyBlcnJvclxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gUHJvZHVjdGlvbi1yZWFkeSBwcm9maWxlIGRldGVjdGlvbiB3aXRoIGxvY2FsU3RvcmFnZSBjYWNoaW5nIC0gSW1wcm92ZWQgZm9yIG11bHRpcGxlIHVzZXJzXHJcbiAgY29uc3QgZ2V0UHJvZmlsZSA9IGFzeW5jICh1c2VyUHVibGljS2V5OiBQdWJsaWNLZXkpOiBQcm9taXNlPFByb2ZpbGUgfCBudWxsPiA9PiB7XHJcbiAgICBjb25zdCBjYWNoZUtleSA9IHVzZXJQdWJsaWNLZXkudG9TdHJpbmcoKVxyXG4gICAgXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyAxLiBDaGVjayBsb2NhbFN0b3JhZ2UgY2FjaGUgZmlyc3QgKGZhc3Rlc3QpXHJcbiAgICAgIGNvbnN0IGNhY2hlZFByb2ZpbGUgPSBnZXRQcm9maWxlRnJvbUxvY2FsU3RvcmFnZShjYWNoZUtleSlcclxuICAgICAgaWYgKGNhY2hlZFByb2ZpbGUgIT09IG51bGwpIHtcclxuICAgICAgICAvLyBBbHNvIHVwZGF0ZSBtZW1vcnkgY2FjaGVcclxuICAgICAgICBwcm9maWxlQ2FjaGUuc2V0KGNhY2hlS2V5LCBjYWNoZWRQcm9maWxlKVxyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcHJvZmlsZUNhY2hlLmRlbGV0ZShjYWNoZUtleSksIENBQ0hFX0RVUkFUSU9OKVxyXG4gICAgICAgIHJldHVybiBjYWNoZWRQcm9maWxlXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIDIuIENoZWNrIG1lbW9yeSBjYWNoZVxyXG4gICAgICBpZiAocHJvZmlsZUNhY2hlLmhhcyhjYWNoZUtleSkpIHtcclxuICAgICAgICBjb25zdCBjYWNoZWQgPSBwcm9maWxlQ2FjaGUuZ2V0KGNhY2hlS2V5KVxyXG4gICAgICAgIHJldHVybiBjYWNoZWQgPz8gbnVsbFxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyAzLiBGZXRjaCBmcm9tIGJsb2NrY2hhaW4gKHNsb3dlc3QpXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIEZldGNoaW5nIHByb2ZpbGUgZnJvbSBibG9ja2NoYWluIGZvcjogJHt1c2VyUHVibGljS2V5LnRvU3RyaW5nKCkuc2xpY2UoMCwgOCl9Li4uYClcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgY29ubmVjdGlvbi5nZXRQcm9ncmFtQWNjb3VudHMoUFJPR1JBTV9JRClcclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OKIEZvdW5kICR7YWNjb3VudHMubGVuZ3RofSBwcm9ncmFtIGFjY291bnRzIHRvIHNjYW4gZm9yIHByb2ZpbGVzYClcclxuXHJcbiAgICAgIGxldCBwcm9maWxlc0ZvdW5kID0gMFxyXG4gICAgICBcclxuICAgICAgLy8gU2NhbiB0aHJvdWdoIGFjY291bnRzIHRvIGZpbmQgdXNlcidzIHByb2ZpbGVcclxuICAgICAgZm9yIChjb25zdCB7IGFjY291bnQsIHB1YmtleSB9IG9mIGFjY291bnRzKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGlmIChhY2NvdW50LmRhdGEubGVuZ3RoID09PSAwKSBjb250aW51ZVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBUcnkgbWFudWFsIHBhcnNpbmcgZmlyc3RcclxuICAgICAgICAgIGNvbnN0IHByb2ZpbGVBY2NvdW50ID0gbWFudWFsUGFyc2VQcm9maWxlKGFjY291bnQuZGF0YSlcclxuICAgICAgICAgIGlmICghcHJvZmlsZUFjY291bnQpIGNvbnRpbnVlXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIHByb2ZpbGVzRm91bmQrK1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjb25zdCBhY2NvdW50T3duZXIgPSBuZXcgUHVibGljS2V5KHByb2ZpbGVBY2NvdW50Lm93bmVyKVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIHByb2ZpbGUgYmVsb25ncyB0byB0aGUgdXNlciB3ZSdyZSBsb29raW5nIGZvclxyXG4gICAgICAgICAgaWYgKHByb2ZpbGVBY2NvdW50LmlzX2luaXRpYWxpemVkID09PSAxICYmIGFjY291bnRPd25lci5lcXVhbHModXNlclB1YmxpY0tleSkpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYPCfjq8gRk9VTkQgUFJPRklMRSEgVXNlcm5hbWU6IFwiJHtwcm9maWxlQWNjb3VudC51c2VybmFtZX1cIiBmb3IgJHt1c2VyUHVibGljS2V5LnRvU3RyaW5nKCkuc2xpY2UoMCwgOCl9YClcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYPCfk7ggUHJvZmlsZSBJbWFnZSBVUkw6IFwiJHtwcm9maWxlQWNjb3VudC5wcm9maWxlX2ltYWdlfVwiYClcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYPCflrzvuI8gQ292ZXIgSW1hZ2UgVVJMOiBcIiR7cHJvZmlsZUFjY291bnQuY292ZXJfaW1hZ2V9XCJgKVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TiiBQcm9maWxlIERhdGE6YCwge1xyXG4gICAgICAgICAgICAgIHVzZXJuYW1lOiBwcm9maWxlQWNjb3VudC51c2VybmFtZSxcclxuICAgICAgICAgICAgICBiaW86IHByb2ZpbGVBY2NvdW50LmJpbyxcclxuICAgICAgICAgICAgICBwcm9maWxlSW1hZ2U6IHByb2ZpbGVBY2NvdW50LnByb2ZpbGVfaW1hZ2UsXHJcbiAgICAgICAgICAgICAgY292ZXJJbWFnZTogcHJvZmlsZUFjY291bnQuY292ZXJfaW1hZ2UsXHJcbiAgICAgICAgICAgICAgcG9zdHNDb3VudDogTnVtYmVyKHByb2ZpbGVBY2NvdW50LnBvc3RzX2NvdW50KSxcclxuICAgICAgICAgICAgICBmb2xsb3dlcnNDb3VudDogTnVtYmVyKHByb2ZpbGVBY2NvdW50LmZvbGxvd2Vyc19jb3VudCksXHJcbiAgICAgICAgICAgICAgaXNWZXJpZmllZDogcHJvZmlsZUFjY291bnQuaXNfdmVyaWZpZWQgPT09IDFcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgY29uc3QgcHJvZmlsZSA9IGNvbnZlcnRQcm9maWxlQWNjb3VudChwcm9maWxlQWNjb3VudClcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIENhY2hlIGluIGJvdGggbWVtb3J5IGFuZCBsb2NhbFN0b3JhZ2VcclxuICAgICAgICAgICAgcHJvZmlsZUNhY2hlLnNldChjYWNoZUtleSwgcHJvZmlsZSlcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBwcm9maWxlQ2FjaGUuZGVsZXRlKGNhY2hlS2V5KSwgQ0FDSEVfRFVSQVRJT04pXHJcbiAgICAgICAgICAgIHNhdmVQcm9maWxlVG9Mb2NhbFN0b3JhZ2UoY2FjaGVLZXksIHByb2ZpbGUpXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICByZXR1cm4gcHJvZmlsZVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAvLyBOb3QgYSBwcm9maWxlIGFjY291bnQgb3IgcGFyc2luZyBmYWlsZWQsIGNvbnRpbnVlXHJcbiAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc29sZS5sb2coYPCfk4ogU2Nhbm5lZCAke3Byb2ZpbGVzRm91bmR9IHByb2ZpbGVzLCBubyBtYXRjaCBmb3VuZCBmb3IgdXNlcjogJHt1c2VyUHVibGljS2V5LnRvU3RyaW5nKCkuc2xpY2UoMCwgOCl9YClcclxuXHJcbiAgICAgIC8vIE5vIHByb2ZpbGUgZm91bmQgLSBjYWNoZSBudWxsIHJlc3VsdCB0byBhdm9pZCByZXBlYXRlZCBzY2Fuc1xyXG4gICAgICBwcm9maWxlQ2FjaGUuc2V0KGNhY2hlS2V5LCBudWxsKVxyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHByb2ZpbGVDYWNoZS5kZWxldGUoY2FjaGVLZXkpLCBDQUNIRV9EVVJBVElPTilcclxuICAgICAgc2F2ZVByb2ZpbGVUb0xvY2FsU3RvcmFnZShjYWNoZUtleSwgbnVsbClcclxuICAgICAgXHJcbiAgICAgIHJldHVybiBudWxsXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBwcm9maWxlIGZvciAke3VzZXJQdWJsaWNLZXkudG9TdHJpbmcoKS5zbGljZSgwLCA4KX06YCwgZXJyb3IpXHJcbiAgICAgIHJldHVybiBudWxsXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBHZXQgcHJvZmlsZSBieSB1c2VybmFtZSAoZm9yIHNwZWNpZmljIGxvb2t1cHMpXHJcbiAgY29uc3QgZ2V0UHJvZmlsZUJ5VXNlcm5hbWUgPSBhc3luYyAodXNlclB1YmxpY0tleTogUHVibGljS2V5LCB1c2VybmFtZTogc3RyaW5nKTogUHJvbWlzZTxQcm9maWxlIHwgbnVsbD4gPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcHJvZmlsZVBEQSA9IGF3YWl0IGdldFByb2ZpbGVQREEodXNlclB1YmxpY0tleSwgdXNlcm5hbWUpXHJcbiAgICAgIGNvbnN0IGFjY291bnRJbmZvID0gYXdhaXQgY29ubmVjdGlvbi5nZXRBY2NvdW50SW5mbyhwcm9maWxlUERBKVxyXG4gICAgICBcclxuICAgICAgaWYgKCFhY2NvdW50SW5mbyB8fCAhYWNjb3VudEluZm8uZGF0YSB8fCBhY2NvdW50SW5mby5kYXRhLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBudWxsXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE5vdyB0cnkgbWFudWFsIHBhcnNpbmdcclxuICAgICAgY29uc3QgcHJvZmlsZUFjY291bnQgPSBtYW51YWxQYXJzZVByb2ZpbGUoYWNjb3VudEluZm8uZGF0YSlcclxuICAgICAgaWYgKHByb2ZpbGVBY2NvdW50KSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYOKchSBTdWNjZXNzZnVsbHkgbWFudWFsbHkgcGFyc2VkIHByb2ZpbGU6YCwge1xyXG4gICAgICAgICAgdXNlcm5hbWU6IHByb2ZpbGVBY2NvdW50LnVzZXJuYW1lLFxyXG4gICAgICAgICAgYmlvOiBwcm9maWxlQWNjb3VudC5iaW8sXHJcbiAgICAgICAgICBpc0luaXRpYWxpemVkOiBwcm9maWxlQWNjb3VudC5pc19pbml0aWFsaXplZCA9PT0gMSxcclxuICAgICAgICAgIG93bmVyOiBuZXcgUHVibGljS2V5KHByb2ZpbGVBY2NvdW50Lm93bmVyKS50b1N0cmluZygpLFxyXG4gICAgICAgICAgcHJvZmlsZUltYWdlOiBwcm9maWxlQWNjb3VudC5wcm9maWxlX2ltYWdlLFxyXG4gICAgICAgICAgY292ZXJJbWFnZTogcHJvZmlsZUFjY291bnQuY292ZXJfaW1hZ2UsXHJcbiAgICAgICAgICBwb3N0c0NvdW50OiBOdW1iZXIocHJvZmlsZUFjY291bnQucG9zdHNfY291bnQpXHJcbiAgICAgICAgfSlcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gY29udmVydFByb2ZpbGVBY2NvdW50KHByb2ZpbGVBY2NvdW50KVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGDinYwgTWFudWFsIHBhcnNpbmcgZmFpbGVkYClcclxuICAgICAgICByZXR1cm4gbnVsbFxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICByZXR1cm4gbnVsbFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gR2V0IHBvc3RzIC0gUkVBTCBJTVBMRU1FTlRBVElPTiB3aXRoIG1hbnVhbCBwYXJzaW5nIGFuZCBjYWNoaW5nXHJcbiAgY29uc3QgZ2V0UG9zdHMgPSBhc3luYyAoKTogUHJvbWlzZTxQb3N0W10+ID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIENoZWNrIGNhY2hlIGZpcnN0XHJcbiAgICAgIGlmIChwb3N0c0NhY2hlICYmIERhdGUubm93KCkgLSBwb3N0c0NhY2hlLnRpbWVzdGFtcCA8IFBPU1RTX0NBQ0hFX0RVUkFUSU9OKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ+KaoSBVc2luZyBjYWNoZWQgcG9zdHMnKVxyXG4gICAgICAgIHJldHVybiBwb3N0c0NhY2hlLnBvc3RzXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SNIEZldGNoaW5nIHBvc3RzIGZyb20gYmxvY2tjaGFpbi4uLicpXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0UHJvZ3JhbUFjY291bnRzKFBST0dSQU1fSUQpXHJcbiAgICAgIGNvbnN0IHBvc3RzOiBQb3N0W10gPSBbXVxyXG5cclxuICAgICAgY29uc29sZS5sb2coYPCfk4ogU2Nhbm5pbmcgJHthY2NvdW50cy5sZW5ndGh9IHByb2dyYW0gYWNjb3VudHMgZm9yIHBvc3RzLi4uYClcclxuXHJcbiAgICAgIGZvciAoY29uc3QgeyBhY2NvdW50LCBwdWJrZXkgfSBvZiBhY2NvdW50cykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBpZiAoYWNjb3VudC5kYXRhLmxlbmd0aCA9PT0gMCkgY29udGludWVcclxuXHJcbiAgICAgICAgICAvLyBUcnkgbWFudWFsIHBvc3QgcGFyc2luZyBmaXJzdFxyXG4gICAgICAgICAgY29uc3QgcG9zdEFjY291bnQgPSBtYW51YWxQYXJzZVBvc3QoYWNjb3VudC5kYXRhKVxyXG4gICAgICAgICAgaWYgKHBvc3RBY2NvdW50ICYmIHBvc3RBY2NvdW50LmlzX2luaXRpYWxpemVkID09PSAxICYmIHBvc3RBY2NvdW50LmNvbnRlbnQpIHtcclxuICAgICAgICAgICAgY29uc3QgcG9zdCA9IGNvbnZlcnRQb3N0QWNjb3VudChwb3N0QWNjb3VudClcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIE9ubHkgaW5jbHVkZSB0b3AtbGV2ZWwgcG9zdHMgKG5vdCBjb21tZW50cykgaW4gdGhlIG1haW4gZmVlZFxyXG4gICAgICAgICAgICAvLyBDb21tZW50cyB3aWxsIGJlIGZldGNoZWQgc2VwYXJhdGVseSBmb3IgZWFjaCBwb3N0XHJcbiAgICAgICAgICAgIGlmICghcG9zdC5pc0NvbW1lbnQpIHtcclxuICAgICAgICAgICAgICBwb3N0cy5wdXNoKHBvc3QpXHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCfk50gRm91bmQgcG9zdDogXCIke3Bvc3QuY29udGVudC5zdWJzdHJpbmcoMCwgNTApfS4uLlwiIGJ5ICR7cG9zdC5hdXRob3IudG9TdHJpbmcoKX1gKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIC8vIE5vdCBhIHBvc3QgYWNjb3VudCBvciBwYXJzaW5nIGZhaWxlZCwgY29udGludWVcclxuICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBwb3N0cy5zb3J0KChhLCBiKSA9PiBiLnRpbWVzdGFtcCAtIGEudGltZXN0YW1wKVxyXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIExvYWRlZCAke3Bvc3RzLmxlbmd0aH0gcG9zdHMgZnJvbSBibG9ja2NoYWluYClcclxuICAgICAgXHJcbiAgICAgIC8vIENhY2hlIHRoZSByZXN1bHRzXHJcbiAgICAgIHBvc3RzQ2FjaGUgPSB7IHBvc3RzLCB0aW1lc3RhbXA6IERhdGUubm93KCkgfVxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHBvc3RzXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwb3N0czonLCBlcnJvcilcclxuICAgICAgcmV0dXJuIFtdXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBHZXQgY29tbWVudHMgZm9yIGEgc3BlY2lmaWMgcG9zdFxyXG4gIGNvbnN0IGdldENvbW1lbnRzRm9yUG9zdCA9IGFzeW5jIChwb3N0SWQ6IG51bWJlcik6IFByb21pc2U8UG9zdFtdPiA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+UjSBGZXRjaGluZyBjb21tZW50cyBmb3IgcG9zdCBJRCAke3Bvc3RJZH0uLi5gKVxyXG4gICAgICBcclxuICAgICAgLy8gRm9yIG5vdywgdXNlIGxvY2FsU3RvcmFnZSB0byB0cmFjayBjb21tZW50cyBzaW5jZSB0aGUgUnVzdCBjb250cmFjdFxyXG4gICAgICAvLyBkb2Vzbid0IHByb3Blcmx5IHN0b3JlIHBhcmVudC1jaGlsZCByZWxhdGlvbnNoaXBzXHJcbiAgICAgIGNvbnN0IGNvbW1lbnRzS2V5ID0gYGNvbW1lbnRzXyR7cG9zdElkfWBcclxuICAgICAgY29uc3Qgc3RvcmVkQ29tbWVudHMgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShjb21tZW50c0tleSlcclxuICAgICAgXHJcbiAgICAgIGlmIChzdG9yZWRDb21tZW50cykge1xyXG4gICAgICAgIGNvbnN0IGNvbW1lbnRJZHM6IG51bWJlcltdID0gSlNPTi5wYXJzZShzdG9yZWRDb21tZW50cylcclxuICAgICAgICBjb25zb2xlLmxvZyhg8J+TnSBGb3VuZCAke2NvbW1lbnRJZHMubGVuZ3RofSBzdG9yZWQgY29tbWVudCBJRHMgZm9yIHBvc3QgJHtwb3N0SWR9YClcclxuICAgICAgICBcclxuICAgICAgICAvLyBHZXQgYWxsIHBvc3RzIGFuZCBmaWx0ZXIgdG8gY29tbWVudHNcclxuICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0UHJvZ3JhbUFjY291bnRzKFBST0dSQU1fSUQpXHJcbiAgICAgICAgY29uc3QgY29tbWVudHM6IFBvc3RbXSA9IFtdXHJcblxyXG4gICAgICAgIGZvciAoY29uc3QgeyBhY2NvdW50LCBwdWJrZXkgfSBvZiBhY2NvdW50cykge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGFjY291bnQuZGF0YS5sZW5ndGggPT09IDApIGNvbnRpbnVlXHJcblxyXG4gICAgICAgICAgICBjb25zdCBwb3N0QWNjb3VudCA9IG1hbnVhbFBhcnNlUG9zdChhY2NvdW50LmRhdGEpXHJcbiAgICAgICAgICAgIGlmIChwb3N0QWNjb3VudCAmJiBwb3N0QWNjb3VudC5pc19pbml0aWFsaXplZCA9PT0gMSAmJiBwb3N0QWNjb3VudC5jb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgcG9zdCA9IGNvbnZlcnRQb3N0QWNjb3VudChwb3N0QWNjb3VudClcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIHBvc3QgSUQgaXMgaW4gb3VyIGNvbW1lbnQgbGlzdFxyXG4gICAgICAgICAgICAgIGlmIChjb21tZW50SWRzLmluY2x1ZGVzKHBvc3QuaWQpKSB7XHJcbiAgICAgICAgICAgICAgICBjb21tZW50cy5wdXNoKHsgLi4ucG9zdCwgaXNDb21tZW50OiB0cnVlLCBwYXJlbnRJZDogcG9zdElkIH0pXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29tbWVudHMuc29ydCgoYSwgYikgPT4gYS50aW1lc3RhbXAgLSBiLnRpbWVzdGFtcClcclxuICAgICAgICBjb25zb2xlLmxvZyhg4pyFIExvYWRlZCAke2NvbW1lbnRzLmxlbmd0aH0gY29tbWVudHMgZm9yIHBvc3QgJHtwb3N0SWR9YClcclxuICAgICAgICByZXR1cm4gY29tbWVudHNcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coYPCfk50gTm8gY29tbWVudHMgZm91bmQgZm9yIHBvc3QgJHtwb3N0SWR9YClcclxuICAgICAgcmV0dXJuIFtdXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBjb21tZW50czonLCBlcnJvcilcclxuICAgICAgcmV0dXJuIFtdXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBTdG9yZSBjb21tZW50IHJlbGF0aW9uc2hpcCBpbiBsb2NhbFN0b3JhZ2VcclxuICBjb25zdCBzdG9yZUNvbW1lbnRSZWxhdGlvbnNoaXAgPSAocGFyZW50UG9zdElkOiBudW1iZXIsIGNvbW1lbnRQb3N0SWQ6IG51bWJlcikgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgY29tbWVudHNLZXkgPSBgY29tbWVudHNfJHtwYXJlbnRQb3N0SWR9YFxyXG4gICAgICBjb25zdCBleGlzdGluZ0NvbW1lbnRzID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oY29tbWVudHNLZXkpXHJcbiAgICAgIGNvbnN0IGNvbW1lbnRJZHM6IG51bWJlcltdID0gZXhpc3RpbmdDb21tZW50cyA/IEpTT04ucGFyc2UoZXhpc3RpbmdDb21tZW50cykgOiBbXVxyXG4gICAgICBcclxuICAgICAgaWYgKCFjb21tZW50SWRzLmluY2x1ZGVzKGNvbW1lbnRQb3N0SWQpKSB7XHJcbiAgICAgICAgY29tbWVudElkcy5wdXNoKGNvbW1lbnRQb3N0SWQpXHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oY29tbWVudHNLZXksIEpTT04uc3RyaW5naWZ5KGNvbW1lbnRJZHMpKVxyXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5K+IFN0b3JlZCBjb21tZW50IHJlbGF0aW9uc2hpcDogcG9zdCAke2NvbW1lbnRQb3N0SWR9IGlzIGNvbW1lbnQgb24gcG9zdCAke3BhcmVudFBvc3RJZH1gKVxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc3RvcmUgY29tbWVudCByZWxhdGlvbnNoaXA6JywgZXJyb3IpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBDcmVhdGUgcG9zdCAtIFJFQUwgSU1QTEVNRU5UQVRJT05cclxuICBjb25zdCBjcmVhdGVQb3N0ID0gYXN5bmMgKGNvbnRlbnQ6IHN0cmluZywgaW1hZ2VzOiBzdHJpbmdbXSA9IFtdKSA9PiB7XHJcbiAgICBpZiAoIXB1YmxpY0tleSkgdGhyb3cgbmV3IEVycm9yKCdXYWxsZXQgbm90IGNvbm5lY3RlZCcpXHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ/CflI0gQ3JlYXRpbmcgcG9zdCB3aXRoIGNvbnRlbnQ6JywgY29udGVudClcclxuICAgICAgXHJcbiAgICAgIC8vIENoZWNrIFNPTCBiYWxhbmNlXHJcbiAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBjaGVja1NPTEJhbGFuY2UoKVxyXG4gICAgICBpZiAoYmFsYW5jZSA8IDAuMDUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluc3VmZmljaWVudCBTT0wgYmFsYW5jZTogJHtiYWxhbmNlfS4gWW91IG5lZWQgYXQgbGVhc3QgMC4wNSBTT0wgZm9yIHRyYW5zYWN0aW9uIGZlZXMgYW5kIGFjY291bnQgY3JlYXRpb24uYClcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gR2V0IHVzZXIncyBwcm9maWxlIFBEQSAtIHdlIG5lZWQgdGhpcyBmb3IgdGhlIGluc3RydWN0aW9uXHJcbiAgICAgIGNvbnN0IHVzZXJQcm9maWxlID0gYXdhaXQgZ2V0UHJvZmlsZShwdWJsaWNLZXkpXHJcbiAgICAgIGlmICghdXNlclByb2ZpbGUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IGNyZWF0ZSBhIHByb2ZpbGUgYmVmb3JlIHBvc3RpbmcnKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBHZXQgdXNlcidzIGN1cnJlbnQgcG9zdCBjb3VudCB0byBnZW5lcmF0ZSB0aGUgY29ycmVjdCBwb3N0IElEXHJcbiAgICAgIC8vIFRoZSBSdXN0IGNvbnRyYWN0IGluY3JlbWVudHMgcG9zdHNfY291bnQgZmlyc3QsIHRoZW4gdXNlcyB0aGF0IGFzIHRoZSBwb3N0IElEXHJcbiAgICAgIGNvbnN0IHBvc3RJZCA9IHVzZXJQcm9maWxlLnBvc3RzQ291bnQgKyAxXHJcbiAgICAgIGNvbnN0IHBvc3RQREEgPSBhd2FpdCBnZXRQb3N0UERBKHB1YmxpY0tleSwgcG9zdElkKVxyXG4gICAgICBjb25zb2xlLmxvZyhg8J+TjSBQb3N0IFBEQTogJHtwb3N0UERBLnRvU3RyaW5nKCl9IGZvciBwb3N0IElEOiAke3Bvc3RJZH1gKVxyXG5cclxuICAgICAgLy8gR2VuZXJhdGUgYSBuZXcga2V5cGFpciBmb3IgdGhlIHBvc3QgYWNjb3VudFxyXG4gICAgICAvLyBUaGUgUnVzdCBjb250cmFjdCB1c2VzIGludm9rZSB3aXRoIHN5c3RlbV9pbnN0cnVjdGlvbjo6Y3JlYXRlX2FjY291bnRcclxuICAgICAgLy8gVGhpcyBtZWFucyB0aGUgcG9zdCBhY2NvdW50IE1VU1QgYmUgYSBrZXlwYWlyIHRoYXQgc2lnbnMgdGhlIHRyYW5zYWN0aW9uXHJcbiAgICAgIGNvbnN0IHBvc3RLZXlwYWlyID0gS2V5cGFpci5nZW5lcmF0ZSgpXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5ONIFBvc3QgQWNjb3VudDogJHtwb3N0S2V5cGFpci5wdWJsaWNLZXkudG9TdHJpbmcoKX1gKVxyXG5cclxuICAgICAgLy8gR2V0IHByb2ZpbGUgUERBIGZvciB0aGUgdXNlciAod2UgbmVlZCB0aGUgYWN0dWFsIHVzZXJuYW1lKVxyXG4gICAgICAvLyBUcnkgdG8gZmluZCB0aGUgcHJvZmlsZSBhY2NvdW50IGFtb25nIGFsbCBwcm9ncmFtIGFjY291bnRzXHJcbiAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgY29ubmVjdGlvbi5nZXRQcm9ncmFtQWNjb3VudHMoUFJPR1JBTV9JRClcclxuICAgICAgbGV0IHVzZXJQcm9maWxlUERBOiBQdWJsaWNLZXkgfCBudWxsID0gbnVsbFxyXG4gICAgICBcclxuICAgICAgZm9yIChjb25zdCB7IGFjY291bnQsIHB1YmtleSB9IG9mIGFjY291bnRzKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IHByb2ZpbGVBY2NvdW50ID0gbWFudWFsUGFyc2VQcm9maWxlKGFjY291bnQuZGF0YSlcclxuICAgICAgICAgIGlmIChwcm9maWxlQWNjb3VudCAmJiBcclxuICAgICAgICAgICAgICBwcm9maWxlQWNjb3VudC5pc19pbml0aWFsaXplZCA9PT0gMSAmJiBcclxuICAgICAgICAgICAgICBuZXcgUHVibGljS2V5KHByb2ZpbGVBY2NvdW50Lm93bmVyKS5lcXVhbHMocHVibGljS2V5KSkge1xyXG4gICAgICAgICAgICB1c2VyUHJvZmlsZVBEQSA9IHB1YmtleVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TjSBVc2VyIFByb2ZpbGUgUERBOiAke3VzZXJQcm9maWxlUERBLnRvU3RyaW5nKCl9YClcclxuICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgY29udGludWVcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghdXNlclByb2ZpbGVQREEpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIHlvdXIgcHJvZmlsZSBQREEuIFBsZWFzZSByZWZyZXNoIGFuZCB0cnkgYWdhaW4uJylcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0gbmV3IENyZWF0ZVBvc3RJbnN0cnVjdGlvbih7XHJcbiAgICAgICAgY29udGVudCxcclxuICAgICAgICBpbWFnZXMsXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBjb25zdCBjcmVhdGVQb3N0VmFyaWFudCA9IEJ1ZmZlci5mcm9tKFsyXSkgLy8gQ3JlYXRlUG9zdCBlbnVtIGluZGV4XHJcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWREYXRhID0gc2VyaWFsaXplKGNyZWF0ZVBvc3RTY2hlbWEsIGluc3RydWN0aW9uRGF0YSlcclxuICAgICAgY29uc3QgZnVsbEluc3RydWN0aW9uRGF0YSA9IEJ1ZmZlci5jb25jYXQoW2NyZWF0ZVBvc3RWYXJpYW50LCBCdWZmZXIuZnJvbShzZXJpYWxpemVkRGF0YSldKVxyXG5cclxuICAgICAgY29uc29sZS5sb2coYPCflKIgSW5zdHJ1Y3Rpb24gZGF0YSBsZW5ndGg6ICR7ZnVsbEluc3RydWN0aW9uRGF0YS5sZW5ndGh9IGJ5dGVzYClcclxuXHJcbiAgICAgIGNvbnN0IGluc3RydWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xyXG4gICAgICAgIGtleXM6IFtcclxuICAgICAgICAgIHsgcHVia2V5OiBwdWJsaWNLZXksIGlzU2lnbmVyOiB0cnVlLCBpc1dyaXRhYmxlOiB0cnVlIH0sIC8vIFVzZXIgYWNjb3VudCAocGF5ZXIpXHJcbiAgICAgICAgICB7IHB1YmtleTogcG9zdEtleXBhaXIucHVibGljS2V5LCBpc1NpZ25lcjogdHJ1ZSwgaXNXcml0YWJsZTogdHJ1ZSB9LCAvLyBQb3N0IGFjY291bnQgKG11c3QgYmUgc2lnbmVyKVxyXG4gICAgICAgICAgeyBwdWJrZXk6IHVzZXJQcm9maWxlUERBLCBpc1NpZ25lcjogZmFsc2UsIGlzV3JpdGFibGU6IHRydWUgfSwgLy8gVXNlciBwcm9maWxlIChmb3IgcG9zdCBjb3VudClcclxuICAgICAgICAgIHsgcHVia2V5OiBTeXN0ZW1Qcm9ncmFtLnByb2dyYW1JZCwgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiBmYWxzZSB9LCAvLyBTeXN0ZW0gcHJvZ3JhbVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgcHJvZ3JhbUlkOiBQUk9HUkFNX0lELFxyXG4gICAgICAgIGRhdGE6IGZ1bGxJbnN0cnVjdGlvbkRhdGEsXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBjb25zb2xlLmxvZygn8J+TnSBUcmFuc2FjdGlvbiBpbnN0cnVjdGlvbiBjcmVhdGVkJylcclxuICAgICAgY29uc29sZS5sb2coJ/CflJEgS2V5czonLCBpbnN0cnVjdGlvbi5rZXlzLm1hcChrID0+ICh7XHJcbiAgICAgICAgcHVia2V5OiBrLnB1YmtleS50b1N0cmluZygpLFxyXG4gICAgICAgIGlzU2lnbmVyOiBrLmlzU2lnbmVyLFxyXG4gICAgICAgIGlzV3JpdGFibGU6IGsuaXNXcml0YWJsZVxyXG4gICAgICB9KSkpXHJcblxyXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpLmFkZChpbnN0cnVjdGlvbilcclxuICAgICAgY29uc3QgeyBibG9ja2hhc2ggfSA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2toYXNoKCdwcm9jZXNzZWQnKVxyXG4gICAgICB0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBibG9ja2hhc2hcclxuICAgICAgdHJhbnNhY3Rpb24uZmVlUGF5ZXIgPSBwdWJsaWNLZXlcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5qAIFNlbmRpbmcgdHJhbnNhY3Rpb24uLi4nKVxyXG4gICAgICBcclxuICAgICAgLy8gU2lnbiB0cmFuc2FjdGlvbiBiZWZvcmUgc2ltdWxhdGlvblxyXG4gICAgICB0cmFuc2FjdGlvbi5wYXJ0aWFsU2lnbihwb3N0S2V5cGFpcilcclxuICAgICAgXHJcbiAgICAgIC8vIFNpbXVsYXRlIHRyYW5zYWN0aW9uIFxyXG4gICAgICBjb25zdCBzaW11bGF0aW9uID0gYXdhaXQgY29ubmVjdGlvbi5zaW11bGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKVxyXG4gICAgICBjb25zb2xlLmxvZygn8J+OryBUcmFuc2FjdGlvbiBzaW11bGF0aW9uOicsIHNpbXVsYXRpb24pXHJcbiAgICAgIFxyXG4gICAgICBpZiAoc2ltdWxhdGlvbi52YWx1ZS5lcnIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zYWN0aW9uIHNpbXVsYXRpb24gZmFpbGVkOiAke0pTT04uc3RyaW5naWZ5KHNpbXVsYXRpb24udmFsdWUuZXJyKX1gKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTZW5kIHRyYW5zYWN0aW9uIHdpdGggcG9zdCBrZXlwYWlyIGFzIGFkZGl0aW9uYWwgc2lnbmVyXHJcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgY29ubmVjdGlvbiwge1xyXG4gICAgICAgIHNraXBQcmVmbGlnaHQ6IGZhbHNlLFxyXG4gICAgICAgIHByZWZsaWdodENvbW1pdG1lbnQ6ICdwcm9jZXNzZWQnLFxyXG4gICAgICAgIG1heFJldHJpZXM6IDMsXHJcbiAgICAgICAgc2lnbmVyczogW3Bvc3RLZXlwYWlyXSwgLy8gUG9zdCBrZXlwYWlyIG11c3Qgc2lnbiB0aGUgdHJhbnNhY3Rpb25cclxuICAgICAgfSlcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OLIFRyYW5zYWN0aW9uIHNpZ25hdHVyZTogJHtzaWduYXR1cmV9YClcclxuICAgICAgXHJcbiAgICAgIGF3YWl0IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHtcclxuICAgICAgICBzaWduYXR1cmUsXHJcbiAgICAgICAgYmxvY2toYXNoLFxyXG4gICAgICAgIGxhc3RWYWxpZEJsb2NrSGVpZ2h0OiAoYXdhaXQgY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goKSkubGFzdFZhbGlkQmxvY2tIZWlnaHQsXHJcbiAgICAgIH0sICdwcm9jZXNzZWQnKVxyXG5cclxuICAgICAgLy8gSW52YWxpZGF0ZSBjYWNoZSBhZnRlciBwb3N0IGNyZWF0aW9uIChwcm9maWxlIHBvc3QgY291bnQgY2hhbmdlZClcclxuICAgICAgY2xlYXJQcm9maWxlQ2FjaGUocHVibGljS2V5LnRvU3RyaW5nKCkpXHJcbiAgICAgIHBvc3RzQ2FjaGUgPSBudWxsIC8vIEFsc28gY2xlYXIgcG9zdHMgY2FjaGUgdG8gc2hvdyBuZXcgcG9zdCBpbW1lZGlhdGVseVxyXG5cclxuICAgICAgY29uc29sZS5sb2coJ+KchSBQb3N0IGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5IScpXHJcbiAgICAgIHRvYXN0LnN1Y2Nlc3MoJ1Bvc3QgY3JlYXRlZCBzdWNjZXNzZnVsbHkhJylcclxuICAgICAgcmV0dXJuIHNpZ25hdHVyZVxyXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgUG9zdCBjcmVhdGlvbiBlcnJvcjonLCBlcnJvcilcclxuICAgICAgXHJcbiAgICAgIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnaW5zdWZmaWNpZW50IGZ1bmRzJykpIHtcclxuICAgICAgICBjb25zdCBiYWxhbmNlID0gYXdhaXQgY2hlY2tTT0xCYWxhbmNlKClcclxuICAgICAgICB0b2FzdC5lcnJvcihgSW5zdWZmaWNpZW50IFNPTDogJHtiYWxhbmNlLnRvRml4ZWQoNCl9IFNPTC4gTmVlZCBhdCBsZWFzdCAwLjA1IFNPTCBmb3IgZmVlcy5gKVxyXG4gICAgICB9IGVsc2UgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdzaW11bGF0aW9uIGZhaWxlZCcpKSB7XHJcbiAgICAgICAgdG9hc3QuZXJyb3IoJ1RyYW5zYWN0aW9uIHdvdWxkIGZhaWw6IENoZWNrIGFjY291bnQgc2V0dXAgYW5kIGJhbGFuY2UnKVxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1NpbXVsYXRpb24gZXJyb3IgZGV0YWlsczonLCBlcnJvci5tZXNzYWdlKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRvYXN0LmVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIHBvc3Q6ICR7ZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YClcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgdGhyb3cgZXJyb3JcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIExpa2UgcG9zdCAtIFJFQUwgSU1QTEVNRU5UQVRJT04gLSBGaXhlZCB0byBmaW5kIGFjdHVhbCBwb3N0IGFjY291bnRzXHJcbiAgY29uc3QgbGlrZVBvc3QgPSBhc3luYyAocG9zdElkOiBudW1iZXIsIHBvc3RBdXRob3I6IFB1YmxpY0tleSkgPT4ge1xyXG4gICAgaWYgKCFwdWJsaWNLZXkpIHRocm93IG5ldyBFcnJvcignV2FsbGV0IG5vdCBjb25uZWN0ZWQnKVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIEF0dGVtcHRpbmcgdG8gbGlrZSBwb3N0IElEICR7cG9zdElkfSBieSBhdXRob3IgJHtwb3N0QXV0aG9yLnRvU3RyaW5nKCkuc2xpY2UoMCwgOCl9Li4uYClcclxuICAgICAgXHJcbiAgICAgIC8vIENoZWNrIFNPTCBiYWxhbmNlIGZpcnN0XHJcbiAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBjaGVja1NPTEJhbGFuY2UoKVxyXG4gICAgICBjb25zb2xlLmxvZyhg8J+SsCBDdXJyZW50IFNPTCBiYWxhbmNlOiAke2JhbGFuY2V9YClcclxuICAgICAgaWYgKGJhbGFuY2UgPCAwLjAxKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN1ZmZpY2llbnQgU09MIGJhbGFuY2U6ICR7YmFsYW5jZX0uIE5lZWQgYXQgbGVhc3QgMC4wMSBTT0wgZm9yIHRyYW5zYWN0aW9uIGZlZXMuYClcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRmluZCB0aGUgYWN0dWFsIHBvc3QgYWNjb3VudCBhbmQgYXV0aG9yJ3MgcHJvZmlsZSBhY2NvdW50IGJ5IHNjYW5uaW5nIGFsbCBwcm9ncmFtIGFjY291bnRzXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIFNlYXJjaGluZyBmb3IgcG9zdCBJRCAke3Bvc3RJZH0gYnkgYXV0aG9yICR7cG9zdEF1dGhvci50b1N0cmluZygpLnNsaWNlKDAsIDgpfS4uLmApXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0UHJvZ3JhbUFjY291bnRzKFBST0dSQU1fSUQpXHJcbiAgICAgIGxldCBwb3N0QWNjb3VudEFkZHJlc3M6IFB1YmxpY0tleSB8IG51bGwgPSBudWxsXHJcbiAgICAgIGxldCBwb3N0QWNjb3VudDogUG9zdEFjY291bnQgfCBudWxsID0gbnVsbFxyXG4gICAgICBsZXQgYXV0aG9yUHJvZmlsZUFkZHJlc3M6IFB1YmxpY0tleSB8IG51bGwgPSBudWxsXHJcbiAgICAgIFxyXG4gICAgICAvLyBGaXJzdCBwYXNzOiBmaW5kIHRoZSBwb3N0IGFjY291bnRcclxuICAgICAgZm9yIChjb25zdCB7IGFjY291bnQsIHB1YmtleSB9IG9mIGFjY291bnRzKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IHBhcnNlZFBvc3QgPSBtYW51YWxQYXJzZVBvc3QoYWNjb3VudC5kYXRhKVxyXG4gICAgICAgICAgaWYgKHBhcnNlZFBvc3QgJiYgXHJcbiAgICAgICAgICAgICAgcGFyc2VkUG9zdC5pc19pbml0aWFsaXplZCA9PT0gMSAmJiBcclxuICAgICAgICAgICAgICBOdW1iZXIocGFyc2VkUG9zdC5pZCkgPT09IHBvc3RJZCAmJlxyXG4gICAgICAgICAgICAgIG5ldyBQdWJsaWNLZXkocGFyc2VkUG9zdC5hdXRob3IpLmVxdWFscyhwb3N0QXV0aG9yKSkge1xyXG4gICAgICAgICAgICBwb3N0QWNjb3VudEFkZHJlc3MgPSBwdWJrZXlcclxuICAgICAgICAgICAgcG9zdEFjY291bnQgPSBwYXJzZWRQb3N0XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn46vIEZvdW5kIHBvc3QgSUQgJHtwb3N0SWR9IGF0IGFkZHJlc3M6ICR7cHVia2V5LnRvU3RyaW5nKCl9YClcclxuICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgLy8gTm90IGEgcG9zdCBhY2NvdW50LCBjb250aW51ZVxyXG4gICAgICAgICAgY29udGludWVcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghcG9zdEFjY291bnRBZGRyZXNzIHx8ICFwb3N0QWNjb3VudCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9zdCBJRCAke3Bvc3RJZH0gYnkgYXV0aG9yICR7cG9zdEF1dGhvci50b1N0cmluZygpLnNsaWNlKDAsIDgpfSBub3QgZm91bmQgb24gYmxvY2tjaGFpbmApXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFNlY29uZCBwYXNzOiBmaW5kIHRoZSBhdXRob3IncyBwcm9maWxlIGFjY291bnRcclxuICAgICAgY29uc29sZS5sb2coYPCflI0gU2VhcmNoaW5nIGZvciBhdXRob3IncyBwcm9maWxlOiAke3Bvc3RBdXRob3IudG9TdHJpbmcoKS5zbGljZSgwLCA4KX0uLi5gKVxyXG4gICAgICBmb3IgKGNvbnN0IHsgYWNjb3VudCwgcHVia2V5IH0gb2YgYWNjb3VudHMpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgcGFyc2VkUHJvZmlsZSA9IG1hbnVhbFBhcnNlUHJvZmlsZShhY2NvdW50LmRhdGEpXHJcbiAgICAgICAgICBpZiAocGFyc2VkUHJvZmlsZSAmJiBcclxuICAgICAgICAgICAgICBwYXJzZWRQcm9maWxlLmlzX2luaXRpYWxpemVkID09PSAxICYmIFxyXG4gICAgICAgICAgICAgIG5ldyBQdWJsaWNLZXkocGFyc2VkUHJvZmlsZS5vd25lcikuZXF1YWxzKHBvc3RBdXRob3IpKSB7XHJcbiAgICAgICAgICAgIGF1dGhvclByb2ZpbGVBZGRyZXNzID0gcHVia2V5XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgRm91bmQgYXV0aG9yIHByb2ZpbGUgYWNjb3VudDogJHtwdWJrZXkudG9TdHJpbmcoKX1gKVxyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAvLyBOb3QgYSBwcm9maWxlIGFjY291bnQsIGNvbnRpbnVlXHJcbiAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFhdXRob3JQcm9maWxlQWRkcmVzcykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXV0aG9yJ3MgcHJvZmlsZSBub3QgZm91bmQgZm9yICR7cG9zdEF1dGhvci50b1N0cmluZygpLnNsaWNlKDAsIDgpfWApXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OdIFBvc3QgZGF0YSB2ZXJpZmllZDogXCIke3Bvc3RBY2NvdW50LmNvbnRlbnQuc2xpY2UoMCwgMzApfS4uLlwiIHdpdGggJHtOdW1iZXIocG9zdEFjY291bnQubGlrZXMpfSBsaWtlc2ApXHJcblxyXG4gICAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSBuZXcgTGlrZVBvc3RJbnN0cnVjdGlvbih7XHJcbiAgICAgICAgcG9zdF9pZDogQmlnSW50KHBvc3RJZCksXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBjb25zdCBsaWtlUG9zdFZhcmlhbnQgPSBCdWZmZXIuZnJvbShbM10pIC8vIExpa2VQb3N0IGluc3RydWN0aW9uIHZhcmlhbnRcclxuICAgICAgY29uc3Qgc2VyaWFsaXplZERhdGEgPSBzZXJpYWxpemUobGlrZVBvc3RTY2hlbWEsIGluc3RydWN0aW9uRGF0YSlcclxuICAgICAgY29uc3QgZnVsbEluc3RydWN0aW9uRGF0YSA9IEJ1ZmZlci5jb25jYXQoW2xpa2VQb3N0VmFyaWFudCwgQnVmZmVyLmZyb20oc2VyaWFsaXplZERhdGEpXSlcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SiIEluc3RydWN0aW9uIGRhdGE6IHZhcmlhbnQgWzNdLCBzZXJpYWxpemVkIGxlbmd0aDogJHtzZXJpYWxpemVkRGF0YS5sZW5ndGh9LCB0b3RhbDogJHtmdWxsSW5zdHJ1Y3Rpb25EYXRhLmxlbmd0aH0gYnl0ZXNgKVxyXG5cclxuICAgICAgY29uc3QgaW5zdHJ1Y3Rpb24gPSBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XHJcbiAgICAgICAga2V5czogW1xyXG4gICAgICAgICAgeyBwdWJrZXk6IHB1YmxpY0tleSwgaXNTaWduZXI6IHRydWUsIGlzV3JpdGFibGU6IGZhbHNlIH0sIC8vIFVzZXIgYWNjb3VudCAobGlrZXIpXHJcbiAgICAgICAgICB7IHB1YmtleTogcG9zdEFjY291bnRBZGRyZXNzLCBpc1NpZ25lcjogZmFsc2UsIGlzV3JpdGFibGU6IHRydWUgfSwgLy8gUG9zdCBhY2NvdW50ICh0byB1cGRhdGUgbGlrZXMpXHJcbiAgICAgICAgICB7IHB1YmtleTogYXV0aG9yUHJvZmlsZUFkZHJlc3MsIGlzU2lnbmVyOiBmYWxzZSwgaXNXcml0YWJsZTogdHJ1ZSB9LCAvLyBBdXRob3IgcHJvZmlsZSBhY2NvdW50ICh0byB1cGRhdGUgVUNSKVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgcHJvZ3JhbUlkOiBQUk9HUkFNX0lELFxyXG4gICAgICAgIGRhdGE6IGZ1bGxJbnN0cnVjdGlvbkRhdGEsXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBjb25zb2xlLmxvZygn8J+UkSBUcmFuc2FjdGlvbiBhY2NvdW50czonKVxyXG4gICAgICBjb25zb2xlLmxvZyhgICBVc2VyIChsaWtlcik6ICR7cHVibGljS2V5LnRvU3RyaW5nKCl9IChzaWduZXIsIHJlYWRvbmx5KWApXHJcbiAgICAgIGNvbnNvbGUubG9nKGAgIFBvc3Q6ICR7cG9zdEFjY291bnRBZGRyZXNzLnRvU3RyaW5nKCl9IChub3Qgc2lnbmVyLCB3cml0YWJsZSlgKVxyXG4gICAgICBjb25zb2xlLmxvZyhgICBBdXRob3IgUHJvZmlsZTogJHthdXRob3JQcm9maWxlQWRkcmVzcy50b1N0cmluZygpfSAobm90IHNpZ25lciwgd3JpdGFibGUpYClcclxuICAgICAgY29uc29sZS5sb2coYCAgUHJvZ3JhbTogJHtQUk9HUkFNX0lELnRvU3RyaW5nKCl9YClcclxuXHJcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKGluc3RydWN0aW9uKVxyXG4gICAgICBjb25zdCB7IGJsb2NraGFzaCB9ID0gYXdhaXQgY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goJ3Byb2Nlc3NlZCcpXHJcbiAgICAgIHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCA9IGJsb2NraGFzaFxyXG4gICAgICB0cmFuc2FjdGlvbi5mZWVQYXllciA9IHB1YmxpY0tleVxyXG5cclxuICAgICAgLy8gU2ltdWxhdGUgdHJhbnNhY3Rpb24gYmVmb3JlIHNlbmRpbmdcclxuICAgICAgY29uc29sZS5sb2coJ/Cfjq8gU2ltdWxhdGluZyB0cmFuc2FjdGlvbi4uLicpXHJcbiAgICAgIGNvbnN0IHNpbXVsYXRpb24gPSBhd2FpdCBjb25uZWN0aW9uLnNpbXVsYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pXHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OKIFNpbXVsYXRpb24gcmVzdWx0OicsIHNpbXVsYXRpb24pXHJcbiAgICAgIFxyXG4gICAgICBpZiAoc2ltdWxhdGlvbi52YWx1ZS5lcnIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zYWN0aW9uIHNpbXVsYXRpb24gZmFpbGVkOiAke0pTT04uc3RyaW5naWZ5KHNpbXVsYXRpb24udmFsdWUuZXJyKX1gKVxyXG4gICAgICB9XHJcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgVHJhbnNhY3Rpb24gc2ltdWxhdGlvbiBzdWNjZXNzZnVsJylcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5qAIFNlbmRpbmcgdHJhbnNhY3Rpb24uLi4nKVxyXG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIGNvbm5lY3Rpb24sIHtcclxuICAgICAgICBza2lwUHJlZmxpZ2h0OiBmYWxzZSxcclxuICAgICAgICBwcmVmbGlnaHRDb21taXRtZW50OiAncHJvY2Vzc2VkJyxcclxuICAgICAgICBtYXhSZXRyaWVzOiAzLFxyXG4gICAgICB9KVxyXG5cclxuICAgICAgY29uc29sZS5sb2coYPCfk4sgVHJhbnNhY3Rpb24gc2VudCB3aXRoIHNpZ25hdHVyZTogJHtzaWduYXR1cmV9YClcclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKCfij7MgQ29uZmlybWluZyB0cmFuc2FjdGlvbi4uLicpXHJcbiAgICAgIGF3YWl0IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHtcclxuICAgICAgICBzaWduYXR1cmUsXHJcbiAgICAgICAgYmxvY2toYXNoLFxyXG4gICAgICAgIGxhc3RWYWxpZEJsb2NrSGVpZ2h0OiAoYXdhaXQgY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goKSkubGFzdFZhbGlkQmxvY2tIZWlnaHQsXHJcbiAgICAgIH0sICdwcm9jZXNzZWQnKVxyXG5cclxuICAgICAgY29uc29sZS5sb2coJ+KchSBUcmFuc2FjdGlvbiBjb25maXJtZWQhIFBvc3QgbGlrZWQgc3VjY2Vzc2Z1bGx5IScpXHJcbiAgICAgIFxyXG4gICAgICAvLyBDbGVhciBwb3N0cyBjYWNoZSB0byBmb3JjZSByZWZyZXNoXHJcbiAgICAgIHBvc3RzQ2FjaGUgPSBudWxsXHJcbiAgICAgIFxyXG4gICAgICB0b2FzdC5zdWNjZXNzKCdQb3N0IGxpa2VkIScpXHJcbiAgICAgIHJldHVybiBzaWduYXR1cmVcclxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIExpa2UgcG9zdCBlcnJvcjonLCBlcnJvcilcclxuICAgICAgXHJcbiAgICAgIC8vIE1vcmUgc3BlY2lmaWMgZXJyb3IgbWVzc2FnZXNcclxuICAgICAgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdpbnN1ZmZpY2llbnQgZnVuZHMnKSkge1xyXG4gICAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBjaGVja1NPTEJhbGFuY2UoKVxyXG4gICAgICAgIHRvYXN0LmVycm9yKGBJbnN1ZmZpY2llbnQgU09MOiAke2JhbGFuY2UudG9GaXhlZCg0KX0gU09MLiBOZWVkIGF0IGxlYXN0IDAuMDEgU09MIGZvciBmZWVzLmApXHJcbiAgICAgIH0gZWxzZSBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ3NpbXVsYXRpb24gZmFpbGVkJykpIHtcclxuICAgICAgICB0b2FzdC5lcnJvcignVHJhbnNhY3Rpb24gd291bGQgZmFpbDogQ2hlY2sgcG9zdCBleGlzdHMgYW5kIHdhbGxldCBoYXMgcGVybWlzc2lvbicpXHJcbiAgICAgICAgY29uc29sZS5lcnJvcignU2ltdWxhdGlvbiBlcnJvciBkZXRhaWxzOicsIGVycm9yLm1lc3NhZ2UpXHJcbiAgICAgIH0gZWxzZSBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ25vdCBmb3VuZCBvbiBibG9ja2NoYWluJykpIHtcclxuICAgICAgICB0b2FzdC5lcnJvcignUG9zdCBub3QgZm91bmQgb24gYmxvY2tjaGFpbicpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdG9hc3QuZXJyb3IoYEZhaWxlZCB0byBsaWtlIHBvc3Q6ICR7ZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YClcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgdGhyb3cgZXJyb3JcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIENoZWNrIHNwZWNpZmljIHByb2ZpbGUgUERBIC0gZm9yIGRlYnVnZ2luZyBwcm9maWxlIGRldGVjdGlvbiBpc3N1ZXNcclxuICBjb25zdCBjaGVja1Byb2ZpbGVBdFBEQSA9IGFzeW5jIChwZGFBZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIENoZWNraW5nIHNwZWNpZmljIFBEQTogJHtwZGFBZGRyZXNzfWApXHJcbiAgICAgIGNvbnN0IHBkYSA9IG5ldyBQdWJsaWNLZXkocGRhQWRkcmVzcylcclxuICAgICAgY29uc3QgYWNjb3VudEluZm8gPSBhd2FpdCBjb25uZWN0aW9uLmdldEFjY291bnRJbmZvKHBkYSlcclxuICAgICAgXHJcbiAgICAgIGlmICghYWNjb3VudEluZm8pIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhg4p2MIE5vIGFjY291bnQgZm91bmQgYXQgUERBOiAke3BkYUFkZHJlc3N9YClcclxuICAgICAgICByZXR1cm5cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coYOKchSBBY2NvdW50IGV4aXN0cyEgT3duZXI6ICR7YWNjb3VudEluZm8ub3duZXIudG9TdHJpbmcoKX0sIFNpemU6ICR7YWNjb3VudEluZm8uZGF0YS5sZW5ndGh9IGJ5dGVzYClcclxuICAgICAgXHJcbiAgICAgIC8vIEluc3BlY3QgcmF3IGRhdGFcclxuICAgICAgY29uc29sZS5sb2coYPCflI0gUmF3IGRhdGEgKGZpcnN0IDEwMCBieXRlcyk6YCwgQXJyYXkuZnJvbShhY2NvdW50SW5mby5kYXRhLnNsaWNlKDAsIDEwMCkpKVxyXG4gICAgICBcclxuICAgICAgaWYgKGFjY291bnRJbmZvLm93bmVyLmVxdWFscyhQUk9HUkFNX0lEKSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGDinIUgQWNjb3VudCBpcyBvd25lZCBieSBvdXIgcHJvZ3JhbWApXHJcbiAgICAgICAgXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIC8vIFRyeSBtYW51YWwgcGFyc2luZyB0byB1bmRlcnN0YW5kIHRoZSBzdHJ1Y3R1cmVcclxuICAgICAgICAgIGxldCBvZmZzZXQgPSAwXHJcbiAgICAgICAgICBjb25zdCBpc19pbml0aWFsaXplZCA9IGFjY291bnRJbmZvLmRhdGFbb2Zmc2V0XVxyXG4gICAgICAgICAgb2Zmc2V0ICs9IDFcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OKIGlzX2luaXRpYWxpemVkOiAke2lzX2luaXRpYWxpemVkfWApXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGNvbnN0IG93bmVyID0gYWNjb3VudEluZm8uZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIDMyKVxyXG4gICAgICAgICAgb2Zmc2V0ICs9IDMyXHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TiiBvd25lcjogJHtuZXcgUHVibGljS2V5KG93bmVyKS50b1N0cmluZygpfWApXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIFRyeSB0byByZWFkIHRoZSB1c2VybmFtZSBsZW5ndGggKEJvcnNoIHN0cmluZyBmb3JtYXQ6IDQgYnl0ZXMgbGVuZ3RoICsgc3RyaW5nKVxyXG4gICAgICAgICAgY29uc3QgdXNlcm5hbWVMZW5ndGggPSBhY2NvdW50SW5mby5kYXRhLnJlYWRVSW50MzJMRShvZmZzZXQpXHJcbiAgICAgICAgICBvZmZzZXQgKz0gNFxyXG4gICAgICAgICAgY29uc29sZS5sb2coYPCfk4ogdXNlcm5hbWUgbGVuZ3RoOiAke3VzZXJuYW1lTGVuZ3RofWApXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmICh1c2VybmFtZUxlbmd0aCA+IDAgJiYgdXNlcm5hbWVMZW5ndGggPCAxMDApIHtcclxuICAgICAgICAgICAgY29uc3QgdXNlcm5hbWUgPSBhY2NvdW50SW5mby5kYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgdXNlcm5hbWVMZW5ndGgpLnRvU3RyaW5nKCd1dGY4JylcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYPCfk4ogdXNlcm5hbWU6IFwiJHt1c2VybmFtZX1cImApXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIE5vdyB0cnkgbWFudWFsIHBhcnNpbmdcclxuICAgICAgICAgIGNvbnN0IHByb2ZpbGVBY2NvdW50ID0gbWFudWFsUGFyc2VQcm9maWxlKGFjY291bnRJbmZvLmRhdGEpXHJcbiAgICAgICAgICBpZiAocHJvZmlsZUFjY291bnQpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBTdWNjZXNzZnVsbHkgbWFudWFsbHkgcGFyc2VkIHByb2ZpbGU6YCwge1xyXG4gICAgICAgICAgICAgIHVzZXJuYW1lOiBwcm9maWxlQWNjb3VudC51c2VybmFtZSxcclxuICAgICAgICAgICAgICBiaW86IHByb2ZpbGVBY2NvdW50LmJpbyxcclxuICAgICAgICAgICAgICBpc0luaXRpYWxpemVkOiBwcm9maWxlQWNjb3VudC5pc19pbml0aWFsaXplZCA9PT0gMSxcclxuICAgICAgICAgICAgICBvd25lcjogbmV3IFB1YmxpY0tleShwcm9maWxlQWNjb3VudC5vd25lcikudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgICBwcm9maWxlSW1hZ2U6IHByb2ZpbGVBY2NvdW50LnByb2ZpbGVfaW1hZ2UsXHJcbiAgICAgICAgICAgICAgY292ZXJJbWFnZTogcHJvZmlsZUFjY291bnQuY292ZXJfaW1hZ2UsXHJcbiAgICAgICAgICAgICAgcG9zdHNDb3VudDogTnVtYmVyKHByb2ZpbGVBY2NvdW50LnBvc3RzX2NvdW50KVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYOKdjCBNYW51YWwgcGFyc2luZyBmYWlsZWRgKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBBbHNvIHRyeSBCb3JzaCBmb3IgY29tcGFyaXNvblxyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcHJvZmlsZUFjY291bnQgPSBkZXNlcmlhbGl6ZShwcm9maWxlQWNjb3VudFNjaGVtYSwgUHJvZmlsZUFjY291bnQsIGFjY291bnRJbmZvLmRhdGEpIGFzIFByb2ZpbGVBY2NvdW50XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgQm9yc2ggZGVzZXJpYWxpemF0aW9uIGFsc28gd29ya2VkOmAsIHtcclxuICAgICAgICAgICAgICB1c2VybmFtZTogcHJvZmlsZUFjY291bnQudXNlcm5hbWUsXHJcbiAgICAgICAgICAgICAgYmlvOiBwcm9maWxlQWNjb3VudC5iaW8sXHJcbiAgICAgICAgICAgICAgaXNJbml0aWFsaXplZDogcHJvZmlsZUFjY291bnQuaXNfaW5pdGlhbGl6ZWQgPT09IDEsXHJcbiAgICAgICAgICAgICAgb3duZXI6IG5ldyBQdWJsaWNLZXkocHJvZmlsZUFjY291bnQub3duZXIpLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinYwgQm9yc2ggZGVzZXJpYWxpemF0aW9uIHN0aWxsIGZhaWxzOmAsIGVycm9yKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhg4p2MIEVycm9yIGNoZWNraW5nIFBEQTpgLCBlcnJvcilcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYOKdjCBBY2NvdW50IGlzIG93bmVkIGJ5IGRpZmZlcmVudCBwcm9ncmFtOiAke2FjY291bnRJbmZvLm93bmVyLnRvU3RyaW5nKCl9YClcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5sb2coYOKdjCBFcnJvciBjaGVja2luZyBQREE6YCwgZXJyb3IpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBNYW51YWwgcHJvZmlsZSBwYXJzZXIgLSBieXBhc3NlcyBCb3JzaCBkZXNlcmlhbGl6YXRpb24gaXNzdWVzXHJcbiAgY29uc3QgbWFudWFsUGFyc2VQcm9maWxlID0gKGRhdGE6IEJ1ZmZlcik6IFByb2ZpbGVBY2NvdW50IHwgbnVsbCA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBCYXNpYyB2YWxpZGF0aW9uIC0gcHJvZmlsZXMgc2hvdWxkIGhhdmUgYSBtaW5pbXVtIHNpemVcclxuICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgMTUwKSByZXR1cm4gbnVsbCAvLyBQcm9maWxlcyBuZWVkIGF0IGxlYXN0IDE1MCBieXRlcyBmb3IgYmFzaWMgc3RydWN0dXJlXHJcbiAgICAgIFxyXG4gICAgICBsZXQgb2Zmc2V0ID0gMFxyXG4gICAgICBcclxuICAgICAgLy8gUGFyc2UgZWFjaCBmaWVsZCBtYW51YWxseVxyXG4gICAgICBjb25zdCBpc19pbml0aWFsaXplZCA9IGRhdGFbb2Zmc2V0XVxyXG4gICAgICBpZiAoaXNfaW5pdGlhbGl6ZWQgIT09IDEpIHJldHVybiBudWxsIC8vIE11c3QgYmUgaW5pdGlhbGl6ZWRcclxuICAgICAgb2Zmc2V0ICs9IDFcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IG93bmVyID0gZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIDMyKVxyXG4gICAgICBvZmZzZXQgKz0gMzJcclxuICAgICAgXHJcbiAgICAgIC8vIFZhbGlkYXRlIHdlIGhhdmUgZW5vdWdoIGRhdGEgZm9yIHVzZXJuYW1lIGxlbmd0aFxyXG4gICAgICBpZiAob2Zmc2V0ICsgNCA+IGRhdGEubGVuZ3RoKSByZXR1cm4gbnVsbFxyXG4gICAgICBcclxuICAgICAgLy8gU3RyaW5nIGZpZWxkcyAodXNlcm5hbWUsIGJpbywgcHJvZmlsZV9pbWFnZSwgY292ZXJfaW1hZ2UpXHJcbiAgICAgIGNvbnN0IHVzZXJuYW1lTGVuZ3RoID0gZGF0YS5yZWFkVUludDMyTEUob2Zmc2V0KVxyXG4gICAgICBvZmZzZXQgKz0gNFxyXG4gICAgICBcclxuICAgICAgLy8gVmFsaWRhdGUgdXNlcm5hbWUgbGVuZ3RoIGlzIHJlYXNvbmFibGVcclxuICAgICAgaWYgKHVzZXJuYW1lTGVuZ3RoID4gMTAwIHx8IHVzZXJuYW1lTGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbFxyXG4gICAgICBpZiAob2Zmc2V0ICsgdXNlcm5hbWVMZW5ndGggPiBkYXRhLmxlbmd0aCkgcmV0dXJuIG51bGxcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHVzZXJuYW1lID0gZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIHVzZXJuYW1lTGVuZ3RoKS50b1N0cmluZygndXRmOCcpXHJcbiAgICAgIG9mZnNldCArPSB1c2VybmFtZUxlbmd0aFxyXG4gICAgICBcclxuICAgICAgLy8gVmFsaWRhdGUgd2UgaGF2ZSBlbm91Z2ggZGF0YSBmb3IgYmlvIGxlbmd0aFxyXG4gICAgICBpZiAob2Zmc2V0ICsgNCA+IGRhdGEubGVuZ3RoKSByZXR1cm4gbnVsbFxyXG4gICAgICBcclxuICAgICAgY29uc3QgYmlvTGVuZ3RoID0gZGF0YS5yZWFkVUludDMyTEUob2Zmc2V0KVxyXG4gICAgICBvZmZzZXQgKz0gNFxyXG4gICAgICBcclxuICAgICAgLy8gVmFsaWRhdGUgYmlvIGxlbmd0aCBpcyByZWFzb25hYmxlXHJcbiAgICAgIGlmIChiaW9MZW5ndGggPiAxMDAwKSByZXR1cm4gbnVsbFxyXG4gICAgICBpZiAob2Zmc2V0ICsgYmlvTGVuZ3RoID4gZGF0YS5sZW5ndGgpIHJldHVybiBudWxsXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBiaW8gPSBkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYmlvTGVuZ3RoKS50b1N0cmluZygndXRmOCcpXHJcbiAgICAgIG9mZnNldCArPSBiaW9MZW5ndGhcclxuICAgICAgXHJcbiAgICAgIC8vIFZhbGlkYXRlIHdlIGhhdmUgZW5vdWdoIGRhdGEgZm9yIHByb2ZpbGUgaW1hZ2UgbGVuZ3RoXHJcbiAgICAgIGlmIChvZmZzZXQgKyA0ID4gZGF0YS5sZW5ndGgpIHJldHVybiBudWxsXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBwcm9maWxlSW1hZ2VMZW5ndGggPSBkYXRhLnJlYWRVSW50MzJMRShvZmZzZXQpXHJcbiAgICAgIG9mZnNldCArPSA0XHJcbiAgICAgIFxyXG4gICAgICAvLyBWYWxpZGF0ZSBwcm9maWxlIGltYWdlIGxlbmd0aCBpcyByZWFzb25hYmxlXHJcbiAgICAgIGlmIChwcm9maWxlSW1hZ2VMZW5ndGggPiA1MDApIHJldHVybiBudWxsXHJcbiAgICAgIGlmIChvZmZzZXQgKyBwcm9maWxlSW1hZ2VMZW5ndGggPiBkYXRhLmxlbmd0aCkgcmV0dXJuIG51bGxcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHByb2ZpbGVfaW1hZ2UgPSBkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgcHJvZmlsZUltYWdlTGVuZ3RoKS50b1N0cmluZygndXRmOCcpXHJcbiAgICAgIG9mZnNldCArPSBwcm9maWxlSW1hZ2VMZW5ndGhcclxuICAgICAgXHJcbiAgICAgIC8vIFZhbGlkYXRlIHdlIGhhdmUgZW5vdWdoIGRhdGEgZm9yIGNvdmVyIGltYWdlIGxlbmd0aFxyXG4gICAgICBpZiAob2Zmc2V0ICsgNCA+IGRhdGEubGVuZ3RoKSByZXR1cm4gbnVsbFxyXG4gICAgICBcclxuICAgICAgY29uc3QgY292ZXJJbWFnZUxlbmd0aCA9IGRhdGEucmVhZFVJbnQzMkxFKG9mZnNldClcclxuICAgICAgb2Zmc2V0ICs9IDRcclxuICAgICAgXHJcbiAgICAgIC8vIFZhbGlkYXRlIGNvdmVyIGltYWdlIGxlbmd0aCBpcyByZWFzb25hYmxlXHJcbiAgICAgIGlmIChjb3ZlckltYWdlTGVuZ3RoID4gNTAwKSByZXR1cm4gbnVsbFxyXG4gICAgICBpZiAob2Zmc2V0ICsgY292ZXJJbWFnZUxlbmd0aCA+IGRhdGEubGVuZ3RoKSByZXR1cm4gbnVsbFxyXG4gICAgICBcclxuICAgICAgY29uc3QgY292ZXJfaW1hZ2UgPSBkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgY292ZXJJbWFnZUxlbmd0aCkudG9TdHJpbmcoJ3V0ZjgnKVxyXG4gICAgICBvZmZzZXQgKz0gY292ZXJJbWFnZUxlbmd0aFxyXG4gICAgICBcclxuICAgICAgLy8gVmFsaWRhdGUgd2UgaGF2ZSBlbm91Z2ggZGF0YSBmb3IgYWxsIHRoZSB1NjQgZmllbGRzICg4IGJ5dGVzIGVhY2ggKiA2IGZpZWxkcyA9IDQ4IGJ5dGVzKVxyXG4gICAgICBpZiAob2Zmc2V0ICsgNDggPiBkYXRhLmxlbmd0aCkgcmV0dXJuIG51bGxcclxuICAgICAgXHJcbiAgICAgIC8vIHU2NCBmaWVsZHNcclxuICAgICAgY29uc3QgY3JlYXRlZF9hdCA9IGRhdGEucmVhZEJpZ1VJbnQ2NExFKG9mZnNldClcclxuICAgICAgb2Zmc2V0ICs9IDhcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGZvbGxvd2Vyc19jb3VudCA9IGRhdGEucmVhZEJpZ1VJbnQ2NExFKG9mZnNldClcclxuICAgICAgb2Zmc2V0ICs9IDhcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGZvbGxvd2luZ19jb3VudCA9IGRhdGEucmVhZEJpZ1VJbnQ2NExFKG9mZnNldClcclxuICAgICAgb2Zmc2V0ICs9IDhcclxuICAgICAgXHJcbiAgICAgIC8vIGk2NCBmaWVsZFxyXG4gICAgICBjb25zdCB1c2VyX2NyZWRpdF9yYXRpbmcgPSBkYXRhLnJlYWRCaWdJbnQ2NExFKG9mZnNldClcclxuICAgICAgb2Zmc2V0ICs9IDhcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHBvc3RzX2NvdW50ID0gZGF0YS5yZWFkQmlnVUludDY0TEUob2Zmc2V0KVxyXG4gICAgICBvZmZzZXQgKz0gOFxyXG4gICAgICBcclxuICAgICAgY29uc3QgbGFzdF9wb3N0X3RpbWVzdGFtcCA9IGRhdGEucmVhZEJpZ1VJbnQ2NExFKG9mZnNldClcclxuICAgICAgb2Zmc2V0ICs9IDhcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGRhaWx5X3Bvc3RfY291bnQgPSBkYXRhLnJlYWRCaWdVSW50NjRMRShvZmZzZXQpXHJcbiAgICAgIG9mZnNldCArPSA4XHJcbiAgICAgIFxyXG4gICAgICAvLyBWYWxpZGF0ZSB3ZSBoYXZlIGVub3VnaCBkYXRhIGZvciB0aGUgZmluYWwgdTggZmllbGRcclxuICAgICAgaWYgKG9mZnNldCArIDEgPiBkYXRhLmxlbmd0aCkgcmV0dXJuIG51bGxcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGlzX3ZlcmlmaWVkID0gZGF0YVtvZmZzZXRdXHJcbiAgICAgIG9mZnNldCArPSAxXHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gbmV3IFByb2ZpbGVBY2NvdW50KHtcclxuICAgICAgICBpc19pbml0aWFsaXplZCxcclxuICAgICAgICBvd25lcjogbmV3IFVpbnQ4QXJyYXkob3duZXIpLFxyXG4gICAgICAgIHVzZXJuYW1lLFxyXG4gICAgICAgIGJpbyxcclxuICAgICAgICBwcm9maWxlX2ltYWdlLFxyXG4gICAgICAgIGNvdmVyX2ltYWdlLFxyXG4gICAgICAgIGNyZWF0ZWRfYXQsXHJcbiAgICAgICAgZm9sbG93ZXJzX2NvdW50LFxyXG4gICAgICAgIGZvbGxvd2luZ19jb3VudCxcclxuICAgICAgICB1c2VyX2NyZWRpdF9yYXRpbmcsXHJcbiAgICAgICAgcG9zdHNfY291bnQsXHJcbiAgICAgICAgbGFzdF9wb3N0X3RpbWVzdGFtcCxcclxuICAgICAgICBkYWlseV9wb3N0X2NvdW50LFxyXG4gICAgICAgIGlzX3ZlcmlmaWVkXHJcbiAgICAgIH0pXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAvLyBTaWxlbnQgZmFpbHVyZSAtIG5vdCBhIHByb2ZpbGUgYWNjb3VudCBvciBpbnZhbGlkIGRhdGFcclxuICAgICAgcmV0dXJuIG51bGxcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIE1hbnVhbCBwb3N0IHBhcnNlciAtIGJ5cGFzc2VzIEJvcnNoIGRlc2VyaWFsaXphdGlvbiBpc3N1ZXNcclxuICBjb25zdCBtYW51YWxQYXJzZVBvc3QgPSAoZGF0YTogQnVmZmVyKTogUG9zdEFjY291bnQgfCBudWxsID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFF1aWNrIHZhbGlkYXRpb246IHBvc3RzIHNob3VsZCBoYXZlIHNwZWNpZmljIHNpemUgYW5kIHN0cnVjdHVyZVxyXG4gICAgICBpZiAoZGF0YS5sZW5ndGggPCAxMDApIHJldHVybiBudWxsIC8vIFBvc3RzIHNob3VsZCBiZSBsYXJnZXIgdGhhbiBwcm9maWxlc1xyXG4gICAgICBcclxuICAgICAgbGV0IG9mZnNldCA9IDBcclxuICAgICAgXHJcbiAgICAgIC8vIFBhcnNlIGVhY2ggZmllbGQgbWFudWFsbHlcclxuICAgICAgY29uc3QgaXNfaW5pdGlhbGl6ZWQgPSBkYXRhW29mZnNldF1cclxuICAgICAgaWYgKGlzX2luaXRpYWxpemVkICE9PSAxKSByZXR1cm4gbnVsbCAvLyBNdXN0IGJlIGluaXRpYWxpemVkXHJcbiAgICAgIG9mZnNldCArPSAxXHJcbiAgICAgIFxyXG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGxvb2tzIGxpa2UgYSBwb3N0IHZzIHByb2ZpbGUgYnkgZXhhbWluaW5nIHRoZSBzdHJ1Y3R1cmVcclxuICAgICAgLy8gUG9zdHMgc3RhcnQgd2l0aDogdTggKGluaXQpLCB1NjQgKGlkKSwgWzMyXXU4IChhdXRob3IpLCBzdHJpbmcgKGNvbnRlbnQpXHJcbiAgICAgIC8vIFByb2ZpbGVzIHN0YXJ0IHdpdGg6IHU4IChpbml0KSwgWzMyXXU4IChvd25lciksIHN0cmluZyAodXNlcm5hbWUpXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBpZCA9IGRhdGEucmVhZEJpZ1VJbnQ2NExFKG9mZnNldClcclxuICAgICAgb2Zmc2V0ICs9IDhcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGF1dGhvciA9IGRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyAzMilcclxuICAgICAgb2Zmc2V0ICs9IDMyXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gZGF0YS5yZWFkVUludDMyTEUob2Zmc2V0KVxyXG4gICAgICBvZmZzZXQgKz0gNFxyXG4gICAgICBcclxuICAgICAgLy8gVmFsaWRhdGUgY29udGVudCBsZW5ndGggaXMgcmVhc29uYWJsZSAobm90IHRvbyBsYXJnZSlcclxuICAgICAgaWYgKGNvbnRlbnRMZW5ndGggPiAxMDAwMCB8fCBjb250ZW50TGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbFxyXG4gICAgICBpZiAob2Zmc2V0ICsgY29udGVudExlbmd0aCA+IGRhdGEubGVuZ3RoKSByZXR1cm4gbnVsbFxyXG4gICAgICBcclxuICAgICAgY29uc3QgY29udGVudCA9IGRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBjb250ZW50TGVuZ3RoKS50b1N0cmluZygndXRmOCcpXHJcbiAgICAgIG9mZnNldCArPSBjb250ZW50TGVuZ3RoXHJcbiAgICAgIFxyXG4gICAgICAvLyBFbnN1cmUgd2UgaGF2ZSBlbm91Z2ggcmVtYWluaW5nIGRhdGEgZm9yIHRoZSByZXN0IG9mIHRoZSBwb3N0IHN0cnVjdHVyZVxyXG4gICAgICBpZiAob2Zmc2V0ICsgNDAgPiBkYXRhLmxlbmd0aCkgcmV0dXJuIG51bGwgLy8gTmVlZCBhdCBsZWFzdCA0MCBtb3JlIGJ5dGVzIGZvciB0aW1lc3RhbXBzIGFuZCBjb3VudHNcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IGRhdGEucmVhZEJpZ1VJbnQ2NExFKG9mZnNldClcclxuICAgICAgb2Zmc2V0ICs9IDhcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGxpa2VzID0gZGF0YS5yZWFkQmlnVUludDY0TEUob2Zmc2V0KVxyXG4gICAgICBvZmZzZXQgKz0gOFxyXG4gICAgICBcclxuICAgICAgY29uc3QgY29tbWVudHMgPSBkYXRhLnJlYWRCaWdVSW50NjRMRShvZmZzZXQpXHJcbiAgICAgIG9mZnNldCArPSA4XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBtaXJyb3JzID0gZGF0YS5yZWFkQmlnVUludDY0TEUob2Zmc2V0KVxyXG4gICAgICBvZmZzZXQgKz0gOFxyXG4gICAgICBcclxuICAgICAgLy8gUGFyc2UgaW1hZ2VzIGFycmF5IGxlbmd0aFxyXG4gICAgICBpZiAob2Zmc2V0ICsgNCA+IGRhdGEubGVuZ3RoKSByZXR1cm4gbnVsbFxyXG4gICAgICBjb25zdCBpbWFnZXNMZW5ndGggPSBkYXRhLnJlYWRVSW50MzJMRShvZmZzZXQpXHJcbiAgICAgIG9mZnNldCArPSA0XHJcbiAgICAgIGNvbnN0IGltYWdlczogc3RyaW5nW10gPSBbXVxyXG4gICAgICBcclxuICAgICAgLy8gUGFyc2UgaW1hZ2VzIGFycmF5IC0gZWFjaCBpbWFnZSBpcyBhIGxlbmd0aC1wcmVmaXhlZCBzdHJpbmdcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbWFnZXNMZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChvZmZzZXQgKyA0ID4gZGF0YS5sZW5ndGgpIHJldHVybiBudWxsXHJcbiAgICAgICAgY29uc3QgaW1hZ2VMZW5ndGggPSBkYXRhLnJlYWRVSW50MzJMRShvZmZzZXQpXHJcbiAgICAgICAgb2Zmc2V0ICs9IDRcclxuICAgICAgICBpZiAob2Zmc2V0ICsgaW1hZ2VMZW5ndGggPiBkYXRhLmxlbmd0aCkgcmV0dXJuIG51bGxcclxuICAgICAgICBjb25zdCBpbWFnZSA9IGRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBpbWFnZUxlbmd0aCkudG9TdHJpbmcoJ3V0ZjgnKVxyXG4gICAgICAgIG9mZnNldCArPSBpbWFnZUxlbmd0aFxyXG4gICAgICAgIGltYWdlcy5wdXNoKGltYWdlKVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBFbnN1cmUgd2UgaGF2ZSBlbm91Z2ggZGF0YSBmb3IgcmF0aW5nIGFuZCBraWxsIHpvbmVcclxuICAgICAgaWYgKG9mZnNldCArIDIgPiBkYXRhLmxlbmd0aCkgcmV0dXJuIG51bGxcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHJhdGluZyA9IGRhdGFbb2Zmc2V0XVxyXG4gICAgICBvZmZzZXQgKz0gMVxyXG4gICAgICBcclxuICAgICAgY29uc3QgaW5fa2lsbF96b25lID0gZGF0YVtvZmZzZXRdXHJcbiAgICAgIG9mZnNldCArPSAxXHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gbmV3IFBvc3RBY2NvdW50KHtcclxuICAgICAgICBpc19pbml0aWFsaXplZCxcclxuICAgICAgICBpZCxcclxuICAgICAgICBhdXRob3I6IG5ldyBVaW50OEFycmF5KGF1dGhvciksXHJcbiAgICAgICAgY29udGVudCxcclxuICAgICAgICB0aW1lc3RhbXAsXHJcbiAgICAgICAgbGlrZXMsXHJcbiAgICAgICAgY29tbWVudHMsXHJcbiAgICAgICAgbWlycm9ycyxcclxuICAgICAgICBpbWFnZXMsXHJcbiAgICAgICAgcmF0aW5nLFxyXG4gICAgICAgIGluX2tpbGxfem9uZVxyXG4gICAgICB9KVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgLy8gU2lsZW50IGZhaWx1cmUgLSBub3QgYSBwb3N0IGFjY291bnRcclxuICAgICAgcmV0dXJuIG51bGxcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIENvbnZlcnQgQ29tbXVuaXR5QWNjb3VudCB0byBDb21tdW5pdHkgaW50ZXJmYWNlXHJcbiAgY29uc3QgY29udmVydENvbW11bml0eUFjY291bnQgPSAoY29tbXVuaXR5QWNjb3VudDogQ29tbXVuaXR5QWNjb3VudCk6IENvbW11bml0eSA9PiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBpc0luaXRpYWxpemVkOiBjb21tdW5pdHlBY2NvdW50LmlzX2luaXRpYWxpemVkID09PSAxLFxyXG4gICAgICBpZDogTnVtYmVyKGNvbW11bml0eUFjY291bnQuaWQpLFxyXG4gICAgICBjcmVhdG9yOiBuZXcgUHVibGljS2V5KGNvbW11bml0eUFjY291bnQuY3JlYXRvciksXHJcbiAgICAgIG5hbWU6IGNvbW11bml0eUFjY291bnQubmFtZSxcclxuICAgICAgZGVzY3JpcHRpb246IGNvbW11bml0eUFjY291bnQuZGVzY3JpcHRpb24sXHJcbiAgICAgIGF2YXRhcjogY29tbXVuaXR5QWNjb3VudC5hdmF0YXIsXHJcbiAgICAgIHJ1bGVzOiBjb21tdW5pdHlBY2NvdW50LnJ1bGVzLFxyXG4gICAgICBtZW1iZXJDb3VudDogTnVtYmVyKGNvbW11bml0eUFjY291bnQubWVtYmVyX2NvdW50KSxcclxuICAgICAgY3JlYXRlZEF0OiBOdW1iZXIoY29tbXVuaXR5QWNjb3VudC5jcmVhdGVkX2F0KSAqIDEwMDAsIC8vIENvbnZlcnQgc2Vjb25kcyB0byBtaWxsaXNlY29uZHNcclxuICAgICAgaXNQcml2YXRlOiBjb21tdW5pdHlBY2NvdW50LmlzX3ByaXZhdGUgPT09IDEsXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBDcmVhdGUgQ29tbXVuaXR5XHJcbiAgY29uc3QgY3JlYXRlQ29tbXVuaXR5ID0gYXN5bmMgKFxyXG4gICAgbmFtZTogc3RyaW5nLFxyXG4gICAgZGVzY3JpcHRpb246IHN0cmluZyxcclxuICAgIGF2YXRhcjogc3RyaW5nLFxyXG4gICAgcnVsZXM6IHN0cmluZ1tdID0gW11cclxuICApID0+IHtcclxuICAgIGlmICghcHVibGljS2V5KSB0aHJvdyBuZXcgRXJyb3IoJ1dhbGxldCBub3QgY29ubmVjdGVkJylcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+PmO+4jyBDcmVhdGluZyBjb21tdW5pdHk6JywgbmFtZSlcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBjaGVja1NPTEJhbGFuY2UoKVxyXG4gICAgICBpZiAoYmFsYW5jZSA8IDAuMDUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluc3VmZmljaWVudCBTT0wgYmFsYW5jZTogJHtiYWxhbmNlfS4gTmVlZCBhdCBsZWFzdCAwLjA1IFNPTC5gKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBHZW5lcmF0ZSBhIGtleXBhaXIgZm9yIHRoZSBjb21tdW5pdHkgYWNjb3VudFxyXG4gICAgICBjb25zdCBjb21tdW5pdHlLZXlwYWlyID0gS2V5cGFpci5nZW5lcmF0ZSgpXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5ONIENvbW11bml0eSBBY2NvdW50OiAke2NvbW11bml0eUtleXBhaXIucHVibGljS2V5LnRvU3RyaW5nKCl9YClcclxuXHJcbiAgICAgIGNvbnN0IGluc3RydWN0aW9uRGF0YSA9IG5ldyBDcmVhdGVDb21tdW5pdHlJbnN0cnVjdGlvbih7XHJcbiAgICAgICAgbmFtZSxcclxuICAgICAgICBkZXNjcmlwdGlvbixcclxuICAgICAgICBhdmF0YXIsXHJcbiAgICAgICAgcnVsZXMsXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBjb25zdCBjcmVhdGVDb21tdW5pdHlWYXJpYW50ID0gQnVmZmVyLmZyb20oWzddKSAvLyBDcmVhdGVDb21tdW5pdHkgZW51bSBpbmRleFxyXG4gICAgICBjb25zdCBzZXJpYWxpemVkRGF0YSA9IHNlcmlhbGl6ZShjcmVhdGVDb21tdW5pdHlTY2hlbWEsIGluc3RydWN0aW9uRGF0YSlcclxuICAgICAgY29uc3QgZnVsbEluc3RydWN0aW9uRGF0YSA9IEJ1ZmZlci5jb25jYXQoW2NyZWF0ZUNvbW11bml0eVZhcmlhbnQsIEJ1ZmZlci5mcm9tKHNlcmlhbGl6ZWREYXRhKV0pXHJcblxyXG4gICAgICBjb25zdCBpbnN0cnVjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcclxuICAgICAgICBrZXlzOiBbXHJcbiAgICAgICAgICB7IHB1YmtleTogcHVibGljS2V5LCBpc1NpZ25lcjogdHJ1ZSwgaXNXcml0YWJsZTogdHJ1ZSB9LCAvLyBDcmVhdG9yIGFjY291bnRcclxuICAgICAgICAgIHsgcHVia2V5OiBjb21tdW5pdHlLZXlwYWlyLnB1YmxpY0tleSwgaXNTaWduZXI6IHRydWUsIGlzV3JpdGFibGU6IHRydWUgfSwgLy8gQ29tbXVuaXR5IGFjY291bnRcclxuICAgICAgICAgIHsgcHVia2V5OiBTeXN0ZW1Qcm9ncmFtLnByb2dyYW1JZCwgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiBmYWxzZSB9LCAvLyBTeXN0ZW0gcHJvZ3JhbVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgcHJvZ3JhbUlkOiBQUk9HUkFNX0lELFxyXG4gICAgICAgIGRhdGE6IGZ1bGxJbnN0cnVjdGlvbkRhdGEsXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpLmFkZChpbnN0cnVjdGlvbilcclxuICAgICAgY29uc3QgeyBibG9ja2hhc2ggfSA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2toYXNoKCdwcm9jZXNzZWQnKVxyXG4gICAgICB0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBibG9ja2hhc2hcclxuICAgICAgdHJhbnNhY3Rpb24uZmVlUGF5ZXIgPSBwdWJsaWNLZXlcclxuXHJcbiAgICAgIC8vIFNpZ24gd2l0aCBjb21tdW5pdHkga2V5cGFpclxyXG4gICAgICB0cmFuc2FjdGlvbi5wYXJ0aWFsU2lnbihjb21tdW5pdHlLZXlwYWlyKVxyXG5cclxuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBjb25uZWN0aW9uLCB7XHJcbiAgICAgICAgc2tpcFByZWZsaWdodDogZmFsc2UsXHJcbiAgICAgICAgcHJlZmxpZ2h0Q29tbWl0bWVudDogJ3Byb2Nlc3NlZCcsXHJcbiAgICAgICAgbWF4UmV0cmllczogMyxcclxuICAgICAgICBzaWduZXJzOiBbY29tbXVuaXR5S2V5cGFpcl0sXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbih7XHJcbiAgICAgICAgc2lnbmF0dXJlLFxyXG4gICAgICAgIGJsb2NraGFzaCxcclxuICAgICAgICBsYXN0VmFsaWRCbG9ja0hlaWdodDogKGF3YWl0IGNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2toYXNoKCkpLmxhc3RWYWxpZEJsb2NrSGVpZ2h0LFxyXG4gICAgICB9LCAncHJvY2Vzc2VkJylcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgQ29tbXVuaXR5IGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5IScpXHJcbiAgICAgIHRvYXN0LnN1Y2Nlc3MoYENvbW11bml0eSBcIiR7bmFtZX1cIiBjcmVhdGVkIHN1Y2Nlc3NmdWxseSFgKVxyXG4gICAgICByZXR1cm4gc2lnbmF0dXJlXHJcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBDb21tdW5pdHkgY3JlYXRpb24gZXJyb3I6JywgZXJyb3IpXHJcbiAgICAgIHRvYXN0LmVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIGNvbW11bml0eTogJHtlcnJvci5tZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJ31gKVxyXG4gICAgICB0aHJvdyBlcnJvclxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gRm9sbG93IFByb2ZpbGVcclxuICBjb25zdCBmb2xsb3dQcm9maWxlID0gYXN5bmMgKHByb2ZpbGVQdWJsaWNLZXk6IFB1YmxpY0tleSkgPT4ge1xyXG4gICAgaWYgKCFwdWJsaWNLZXkpIHRocm93IG5ldyBFcnJvcignV2FsbGV0IG5vdCBjb25uZWN0ZWQnKVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5GlIEZvbGxvd2luZyBwcm9maWxlOicsIHByb2ZpbGVQdWJsaWNLZXkudG9TdHJpbmcoKSlcclxuXHJcbiAgICAgIC8vIEZpbmQgdGhlIGZvbGxvd2VyJ3MgcHJvZmlsZSBhY2NvdW50IChjdXJyZW50IHVzZXIncyBwcm9maWxlKVxyXG4gICAgICBjb25zb2xlLmxvZyhg8J+UjSBTZWFyY2hpbmcgZm9yIGZvbGxvd2VyIHByb2ZpbGU6ICR7cHVibGljS2V5LnRvU3RyaW5nKCkuc2xpY2UoMCwgOCl9Li4uYClcclxuICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBjb25uZWN0aW9uLmdldFByb2dyYW1BY2NvdW50cyhQUk9HUkFNX0lEKVxyXG4gICAgICBsZXQgZm9sbG93ZXJQcm9maWxlQWRkcmVzczogUHVibGljS2V5IHwgbnVsbCA9IG51bGxcclxuICAgICAgXHJcbiAgICAgIGZvciAoY29uc3QgeyBhY2NvdW50LCBwdWJrZXkgfSBvZiBhY2NvdW50cykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCBwYXJzZWRQcm9maWxlID0gbWFudWFsUGFyc2VQcm9maWxlKGFjY291bnQuZGF0YSlcclxuICAgICAgICAgIGlmIChwYXJzZWRQcm9maWxlICYmIFxyXG4gICAgICAgICAgICAgIHBhcnNlZFByb2ZpbGUuaXNfaW5pdGlhbGl6ZWQgPT09IDEgJiYgXHJcbiAgICAgICAgICAgICAgbmV3IFB1YmxpY0tleShwYXJzZWRQcm9maWxlLm93bmVyKS5lcXVhbHMocHVibGljS2V5KSkge1xyXG4gICAgICAgICAgICBmb2xsb3dlclByb2ZpbGVBZGRyZXNzID0gcHVia2V5XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgRm91bmQgZm9sbG93ZXIgcHJvZmlsZSBhY2NvdW50OiAke3B1YmtleS50b1N0cmluZygpfWApXHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIC8vIFNpbGVudCBmYWlsdXJlIC0gbm90IGEgcHJvZmlsZSBhY2NvdW50XHJcbiAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFmb2xsb3dlclByb2ZpbGVBZGRyZXNzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBjcmVhdGUgYSBwcm9maWxlIGJlZm9yZSBmb2xsb3dpbmcgb3RoZXJzJylcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0gbmV3IEZvbGxvd1Byb2ZpbGVJbnN0cnVjdGlvbih7XHJcbiAgICAgICAgcHJvZmlsZV9pZDogcHJvZmlsZVB1YmxpY0tleSxcclxuICAgICAgfSlcclxuXHJcbiAgICAgIGNvbnN0IGZvbGxvd1Byb2ZpbGVWYXJpYW50ID0gQnVmZmVyLmZyb20oWzVdKSAvLyBGb2xsb3dQcm9maWxlIGVudW0gaW5kZXhcclxuICAgICAgY29uc3Qgc2VyaWFsaXplZERhdGEgPSBzZXJpYWxpemUoZm9sbG93UHJvZmlsZVNjaGVtYSwgaW5zdHJ1Y3Rpb25EYXRhKVxyXG4gICAgICBjb25zdCBmdWxsSW5zdHJ1Y3Rpb25EYXRhID0gQnVmZmVyLmNvbmNhdChbZm9sbG93UHJvZmlsZVZhcmlhbnQsIEJ1ZmZlci5mcm9tKHNlcmlhbGl6ZWREYXRhKV0pXHJcblxyXG4gICAgICBjb25zdCBpbnN0cnVjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcclxuICAgICAgICBrZXlzOiBbXHJcbiAgICAgICAgICB7IHB1YmtleTogcHVibGljS2V5LCBpc1NpZ25lcjogdHJ1ZSwgaXNXcml0YWJsZTogZmFsc2UgfSwgLy8gRm9sbG93ZXIgYWNjb3VudFxyXG4gICAgICAgICAgeyBwdWJrZXk6IHByb2ZpbGVQdWJsaWNLZXksIGlzU2lnbmVyOiBmYWxzZSwgaXNXcml0YWJsZTogdHJ1ZSB9LCAvLyBQcm9maWxlIHRvIGZvbGxvd1xyXG4gICAgICAgICAgeyBwdWJrZXk6IGZvbGxvd2VyUHJvZmlsZUFkZHJlc3MsIGlzU2lnbmVyOiBmYWxzZSwgaXNXcml0YWJsZTogdHJ1ZSB9LCAvLyBGb2xsb3dlcidzIHByb2ZpbGUgYWNjb3VudFxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgcHJvZ3JhbUlkOiBQUk9HUkFNX0lELFxyXG4gICAgICAgIGRhdGE6IGZ1bGxJbnN0cnVjdGlvbkRhdGEsXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpLmFkZChpbnN0cnVjdGlvbilcclxuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBjb25uZWN0aW9uKVxyXG5cclxuICAgICAgYXdhaXQgY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oc2lnbmF0dXJlLCAncHJvY2Vzc2VkJylcclxuICAgICAgXHJcbiAgICAgIC8vIENsZWFyIHByb2ZpbGUgY2FjaGUgdG8gZm9yY2UgcmVmcmVzaCBvZiBmb2xsb3dlciBjb3VudHNcclxuICAgICAgY2xlYXJQcm9maWxlQ2FjaGUoKVxyXG4gICAgICBcclxuICAgICAgdG9hc3Quc3VjY2VzcygnUHJvZmlsZSBmb2xsb3dlZCEnKVxyXG4gICAgICByZXR1cm4gc2lnbmF0dXJlXHJcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZvbGxvdyBlcnJvcjonLCBlcnJvcilcclxuICAgICAgdG9hc3QuZXJyb3IoJ0ZhaWxlZCB0byBmb2xsb3cgcHJvZmlsZScpXHJcbiAgICAgIHRocm93IGVycm9yXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBVbmZvbGxvdyBQcm9maWxlXHJcbiAgY29uc3QgdW5mb2xsb3dQcm9maWxlID0gYXN5bmMgKHByb2ZpbGVQdWJsaWNLZXk6IFB1YmxpY0tleSkgPT4ge1xyXG4gICAgaWYgKCFwdWJsaWNLZXkpIHRocm93IG5ldyBFcnJvcignV2FsbGV0IG5vdCBjb25uZWN0ZWQnKVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5GlIFVuZm9sbG93aW5nIHByb2ZpbGU6JywgcHJvZmlsZVB1YmxpY0tleS50b1N0cmluZygpKVxyXG5cclxuICAgICAgLy8gRmluZCB0aGUgZm9sbG93ZXIncyBwcm9maWxlIGFjY291bnQgKGN1cnJlbnQgdXNlcidzIHByb2ZpbGUpXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIFNlYXJjaGluZyBmb3IgZm9sbG93ZXIgcHJvZmlsZTogJHtwdWJsaWNLZXkudG9TdHJpbmcoKS5zbGljZSgwLCA4KX0uLi5gKVxyXG4gICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0UHJvZ3JhbUFjY291bnRzKFBST0dSQU1fSUQpXHJcbiAgICAgIGxldCBmb2xsb3dlclByb2ZpbGVBZGRyZXNzOiBQdWJsaWNLZXkgfCBudWxsID0gbnVsbFxyXG4gICAgICBcclxuICAgICAgZm9yIChjb25zdCB7IGFjY291bnQsIHB1YmtleSB9IG9mIGFjY291bnRzKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IHBhcnNlZFByb2ZpbGUgPSBtYW51YWxQYXJzZVByb2ZpbGUoYWNjb3VudC5kYXRhKVxyXG4gICAgICAgICAgaWYgKHBhcnNlZFByb2ZpbGUgJiYgXHJcbiAgICAgICAgICAgICAgcGFyc2VkUHJvZmlsZS5pc19pbml0aWFsaXplZCA9PT0gMSAmJiBcclxuICAgICAgICAgICAgICBuZXcgUHVibGljS2V5KHBhcnNlZFByb2ZpbGUub3duZXIpLmVxdWFscyhwdWJsaWNLZXkpKSB7XHJcbiAgICAgICAgICAgIGZvbGxvd2VyUHJvZmlsZUFkZHJlc3MgPSBwdWJrZXlcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBGb3VuZCBmb2xsb3dlciBwcm9maWxlIGFjY291bnQ6ICR7cHVia2V5LnRvU3RyaW5nKCl9YClcclxuICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgLy8gU2lsZW50IGZhaWx1cmUgLSBub3QgYSBwcm9maWxlIGFjY291bnRcclxuICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIWZvbGxvd2VyUHJvZmlsZUFkZHJlc3MpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IGNyZWF0ZSBhIHByb2ZpbGUgYmVmb3JlIHVuZm9sbG93aW5nIG90aGVycycpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGluc3RydWN0aW9uRGF0YSA9IG5ldyBGb2xsb3dQcm9maWxlSW5zdHJ1Y3Rpb24oe1xyXG4gICAgICAgIHByb2ZpbGVfaWQ6IHByb2ZpbGVQdWJsaWNLZXksXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBjb25zdCB1bmZvbGxvd1Byb2ZpbGVWYXJpYW50ID0gQnVmZmVyLmZyb20oWzZdKSAvLyBVbmZvbGxvd1Byb2ZpbGUgZW51bSBpbmRleFxyXG4gICAgICBjb25zdCBzZXJpYWxpemVkRGF0YSA9IHNlcmlhbGl6ZShmb2xsb3dQcm9maWxlU2NoZW1hLCBpbnN0cnVjdGlvbkRhdGEpXHJcbiAgICAgIGNvbnN0IGZ1bGxJbnN0cnVjdGlvbkRhdGEgPSBCdWZmZXIuY29uY2F0KFt1bmZvbGxvd1Byb2ZpbGVWYXJpYW50LCBCdWZmZXIuZnJvbShzZXJpYWxpemVkRGF0YSldKVxyXG5cclxuICAgICAgY29uc3QgaW5zdHJ1Y3Rpb24gPSBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XHJcbiAgICAgICAga2V5czogW1xyXG4gICAgICAgICAgeyBwdWJrZXk6IHB1YmxpY0tleSwgaXNTaWduZXI6IHRydWUsIGlzV3JpdGFibGU6IGZhbHNlIH0sIC8vIEZvbGxvd2VyIGFjY291bnRcclxuICAgICAgICAgIHsgcHVia2V5OiBwcm9maWxlUHVibGljS2V5LCBpc1NpZ25lcjogZmFsc2UsIGlzV3JpdGFibGU6IHRydWUgfSwgLy8gUHJvZmlsZSB0byB1bmZvbGxvd1xyXG4gICAgICAgICAgeyBwdWJrZXk6IGZvbGxvd2VyUHJvZmlsZUFkZHJlc3MsIGlzU2lnbmVyOiBmYWxzZSwgaXNXcml0YWJsZTogdHJ1ZSB9LCAvLyBGb2xsb3dlcidzIHByb2ZpbGUgYWNjb3VudFxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgcHJvZ3JhbUlkOiBQUk9HUkFNX0lELFxyXG4gICAgICAgIGRhdGE6IGZ1bGxJbnN0cnVjdGlvbkRhdGEsXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpLmFkZChpbnN0cnVjdGlvbilcclxuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBjb25uZWN0aW9uKVxyXG5cclxuICAgICAgYXdhaXQgY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oc2lnbmF0dXJlLCAncHJvY2Vzc2VkJylcclxuICAgICAgXHJcbiAgICAgIC8vIENsZWFyIHByb2ZpbGUgY2FjaGUgdG8gZm9yY2UgcmVmcmVzaCBvZiBmb2xsb3dlciBjb3VudHNcclxuICAgICAgY2xlYXJQcm9maWxlQ2FjaGUoKVxyXG4gICAgICBcclxuICAgICAgdG9hc3Quc3VjY2VzcygnUHJvZmlsZSB1bmZvbGxvd2VkIScpXHJcbiAgICAgIHJldHVybiBzaWduYXR1cmVcclxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignVW5mb2xsb3cgZXJyb3I6JywgZXJyb3IpXHJcbiAgICAgIHRvYXN0LmVycm9yKCdGYWlsZWQgdG8gdW5mb2xsb3cgcHJvZmlsZScpXHJcbiAgICAgIHRocm93IGVycm9yXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBVcGRhdGUgUHJvZmlsZVxyXG4gIGNvbnN0IHVwZGF0ZVByb2ZpbGUgPSBhc3luYyAoXHJcbiAgICB1c2VybmFtZTogc3RyaW5nLFxyXG4gICAgYmlvOiBzdHJpbmcsXHJcbiAgICBwcm9maWxlSW1hZ2U6IHN0cmluZyxcclxuICAgIGNvdmVySW1hZ2U6IHN0cmluZ1xyXG4gICkgPT4ge1xyXG4gICAgaWYgKCFwdWJsaWNLZXkpIHRocm93IG5ldyBFcnJvcignV2FsbGV0IG5vdCBjb25uZWN0ZWQnKVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SEIFVwZGF0aW5nIHByb2ZpbGU6JywgdXNlcm5hbWUpXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSBuZXcgQ3JlYXRlUHJvZmlsZUluc3RydWN0aW9uKHtcclxuICAgICAgICB1c2VybmFtZSxcclxuICAgICAgICBiaW8sXHJcbiAgICAgICAgcHJvZmlsZV9pbWFnZTogcHJvZmlsZUltYWdlLFxyXG4gICAgICAgIGNvdmVyX2ltYWdlOiBjb3ZlckltYWdlLFxyXG4gICAgICB9KVxyXG5cclxuICAgICAgY29uc3QgdXBkYXRlUHJvZmlsZVZhcmlhbnQgPSBCdWZmZXIuZnJvbShbMV0pIC8vIFVwZGF0ZVByb2ZpbGUgZW51bSBpbmRleCAoc2FtZSBhcyBDcmVhdGVQcm9maWxlKVxyXG4gICAgICBjb25zdCBzZXJpYWxpemVkRGF0YSA9IHNlcmlhbGl6ZShjcmVhdGVQcm9maWxlU2NoZW1hLCBpbnN0cnVjdGlvbkRhdGEpXHJcbiAgICAgIGNvbnN0IGZ1bGxJbnN0cnVjdGlvbkRhdGEgPSBCdWZmZXIuY29uY2F0KFt1cGRhdGVQcm9maWxlVmFyaWFudCwgQnVmZmVyLmZyb20oc2VyaWFsaXplZERhdGEpXSlcclxuXHJcbiAgICAgIGNvbnN0IGluc3RydWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xyXG4gICAgICAgIGtleXM6IFtcclxuICAgICAgICAgIHsgcHVia2V5OiBwdWJsaWNLZXksIGlzU2lnbmVyOiB0cnVlLCBpc1dyaXRhYmxlOiB0cnVlIH0sIC8vIFByb2ZpbGUgb3duZXIgYWNjb3VudFxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgcHJvZ3JhbUlkOiBQUk9HUkFNX0lELFxyXG4gICAgICAgIGRhdGE6IGZ1bGxJbnN0cnVjdGlvbkRhdGEsXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpLmFkZChpbnN0cnVjdGlvbilcclxuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBjb25uZWN0aW9uKVxyXG5cclxuICAgICAgYXdhaXQgY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oc2lnbmF0dXJlLCAncHJvY2Vzc2VkJylcclxuICAgICAgY29uc29sZS5sb2coJ+KchSBQcm9maWxlIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5IScpXHJcbiAgICAgIFxyXG4gICAgICAvLyBDbGVhciBjYWNoZSB0byBmb3JjZSByZWZyZXNoXHJcbiAgICAgIHByb2ZpbGVDYWNoZS5kZWxldGUocHVibGljS2V5LnRvU3RyaW5nKCkpXHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gc2lnbmF0dXJlXHJcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBVcGRhdGUgcHJvZmlsZSBlcnJvcjonLCBlcnJvcilcclxuICAgICAgdGhyb3cgZXJyb3JcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIENvbW1lbnQgb24gUG9zdFxyXG4gIGNvbnN0IGNvbW1lbnRPblBvc3QgPSBhc3luYyAocG9zdElkOiBudW1iZXIsIGNvbnRlbnQ6IHN0cmluZywgcG9zdEF1dGhvcjogUHVibGljS2V5KSA9PiB7XHJcbiAgICBpZiAoIXB1YmxpY0tleSkgdGhyb3cgbmV3IEVycm9yKCdXYWxsZXQgbm90IGNvbm5lY3RlZCcpXHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coYPCfkqwgQ29tbWVudGluZyBvbiBwb3N0IElEICR7cG9zdElkfS4uLmApXHJcbiAgICAgIFxyXG4gICAgICAvLyBDaGVjayBTT0wgYmFsYW5jZSBmaXJzdFxyXG4gICAgICBjb25zdCBiYWxhbmNlID0gYXdhaXQgY2hlY2tTT0xCYWxhbmNlKClcclxuICAgICAgaWYgKGJhbGFuY2UgPCAwLjAxKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN1ZmZpY2llbnQgU09MIGJhbGFuY2U6ICR7YmFsYW5jZX0uIE5lZWQgYXQgbGVhc3QgMC4wMSBTT0wgZm9yIHRyYW5zYWN0aW9uIGZlZXMuYClcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRmluZCB0aGUgYWN0dWFsIHBvc3QgYWNjb3VudCBieSBzY2FubmluZyBhbGwgcHJvZ3JhbSBhY2NvdW50c1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+UjSBTZWFyY2hpbmcgZm9yIHBvc3QgSUQgJHtwb3N0SWR9IGJ5IGF1dGhvciAke3Bvc3RBdXRob3IudG9TdHJpbmcoKS5zbGljZSgwLCA4KX0uLi5gKVxyXG4gICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0UHJvZ3JhbUFjY291bnRzKFBST0dSQU1fSUQpXHJcbiAgICAgIGxldCBwb3N0QWRkcmVzczogUHVibGljS2V5IHwgbnVsbCA9IG51bGxcclxuICAgICAgbGV0IHVzZXJQcm9maWxlQWRkcmVzczogUHVibGljS2V5IHwgbnVsbCA9IG51bGxcclxuICAgICAgXHJcbiAgICAgIC8vIEZpcnN0IHBhc3M6IGZpbmQgdGhlIHBvc3QgYWNjb3VudFxyXG4gICAgICBmb3IgKGNvbnN0IHsgYWNjb3VudCwgcHVia2V5IH0gb2YgYWNjb3VudHMpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgcGFyc2VkUG9zdCA9IG1hbnVhbFBhcnNlUG9zdChhY2NvdW50LmRhdGEpXHJcbiAgICAgICAgICBpZiAocGFyc2VkUG9zdCAmJiBcclxuICAgICAgICAgICAgICBwYXJzZWRQb3N0LmlzX2luaXRpYWxpemVkID09PSAxICYmIFxyXG4gICAgICAgICAgICAgIE51bWJlcihwYXJzZWRQb3N0LmlkKSA9PT0gcG9zdElkICYmXHJcbiAgICAgICAgICAgICAgbmV3IFB1YmxpY0tleShwYXJzZWRQb3N0LmF1dGhvcikuZXF1YWxzKHBvc3RBdXRob3IpKSB7XHJcbiAgICAgICAgICAgIHBvc3RBZGRyZXNzID0gcHVia2V5XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgRm91bmQgcG9zdCBhY2NvdW50OiAke3B1YmtleS50b1N0cmluZygpfWApXHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIC8vIFNpbGVudCBmYWlsdXJlIC0gbm90IGEgcG9zdCBhY2NvdW50XHJcbiAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFwb3N0QWRkcmVzcykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9zdCB3aXRoIElEICR7cG9zdElkfSBub3QgZm91bmRgKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTZWNvbmQgcGFzczogZmluZCB0aGUgY29tbWVudGVyJ3MgcHJvZmlsZSBhY2NvdW50XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIFNlYXJjaGluZyBmb3IgY29tbWVudGVyIHByb2ZpbGU6ICR7cHVibGljS2V5LnRvU3RyaW5nKCkuc2xpY2UoMCwgOCl9Li4uYClcclxuICAgICAgZm9yIChjb25zdCB7IGFjY291bnQsIHB1YmtleSB9IG9mIGFjY291bnRzKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IHBhcnNlZFByb2ZpbGUgPSBtYW51YWxQYXJzZVByb2ZpbGUoYWNjb3VudC5kYXRhKVxyXG4gICAgICAgICAgaWYgKHBhcnNlZFByb2ZpbGUgJiYgXHJcbiAgICAgICAgICAgICAgcGFyc2VkUHJvZmlsZS5pc19pbml0aWFsaXplZCA9PT0gMSAmJiBcclxuICAgICAgICAgICAgICBuZXcgUHVibGljS2V5KHBhcnNlZFByb2ZpbGUub3duZXIpLmVxdWFscyhwdWJsaWNLZXkpKSB7XHJcbiAgICAgICAgICAgIHVzZXJQcm9maWxlQWRkcmVzcyA9IHB1YmtleVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEZvdW5kIGNvbW1lbnRlciBwcm9maWxlIGFjY291bnQ6ICR7cHVia2V5LnRvU3RyaW5nKCl9YClcclxuICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgLy8gU2lsZW50IGZhaWx1cmUgLSBub3QgYSBwcm9maWxlIGFjY291bnRcclxuICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXVzZXJQcm9maWxlQWRkcmVzcykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgY3JlYXRlIGEgcHJvZmlsZSBiZWZvcmUgY29tbWVudGluZycpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEdlbmVyYXRlIGEgbmV3IGtleXBhaXIgZm9yIHRoZSBjb21tZW50IGFjY291bnRcclxuICAgICAgY29uc3QgY29tbWVudEtleXBhaXIgPSBLZXlwYWlyLmdlbmVyYXRlKClcclxuICAgICAgY29uc29sZS5sb2coYPCfk40gQ29tbWVudCBBY2NvdW50OiAke2NvbW1lbnRLZXlwYWlyLnB1YmxpY0tleS50b1N0cmluZygpfWApXHJcblxyXG4gICAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSBuZXcgQ29tbWVudE9uUG9zdEluc3RydWN0aW9uKHtcclxuICAgICAgICBjb250ZW50LFxyXG4gICAgICAgIHBhcmVudF9pZDogQmlnSW50KHBvc3RJZCksXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBjb25zdCBjb21tZW50VmFyaWFudCA9IEJ1ZmZlci5mcm9tKFs0XSkgLy8gQ29tbWVudE9uUG9zdCBlbnVtIGluZGV4XHJcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWREYXRhID0gc2VyaWFsaXplKGNvbW1lbnRPblBvc3RTY2hlbWEsIGluc3RydWN0aW9uRGF0YSlcclxuICAgICAgY29uc3QgZnVsbEluc3RydWN0aW9uRGF0YSA9IEJ1ZmZlci5jb25jYXQoW2NvbW1lbnRWYXJpYW50LCBCdWZmZXIuZnJvbShzZXJpYWxpemVkRGF0YSldKVxyXG5cclxuICAgICAgY29uc3QgaW5zdHJ1Y3Rpb24gPSBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XHJcbiAgICAgICAga2V5czogW1xyXG4gICAgICAgICAgeyBwdWJrZXk6IHB1YmxpY0tleSwgaXNTaWduZXI6IHRydWUsIGlzV3JpdGFibGU6IHRydWUgfSwgLy8gVXNlciBhY2NvdW50IChjb21tZW50ZXIpXHJcbiAgICAgICAgICB7IHB1YmtleTogY29tbWVudEtleXBhaXIucHVibGljS2V5LCBpc1NpZ25lcjogdHJ1ZSwgaXNXcml0YWJsZTogdHJ1ZSB9LCAvLyBDb21tZW50IGFjY291bnQgKG5ldylcclxuICAgICAgICAgIHsgcHVia2V5OiBwb3N0QWRkcmVzcywgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiB0cnVlIH0sIC8vIFBhcmVudCBwb3N0IGFjY291bnRcclxuICAgICAgICAgIHsgcHVia2V5OiB1c2VyUHJvZmlsZUFkZHJlc3MsIGlzU2lnbmVyOiBmYWxzZSwgaXNXcml0YWJsZTogdHJ1ZSB9LCAvLyBVc2VyIHByb2ZpbGUgYWNjb3VudFxyXG4gICAgICAgICAgeyBwdWJrZXk6IFN5c3RlbVByb2dyYW0ucHJvZ3JhbUlkLCBpc1NpZ25lcjogZmFsc2UsIGlzV3JpdGFibGU6IGZhbHNlIH0sIC8vIFN5c3RlbSBwcm9ncmFtXHJcbiAgICAgICAgXSxcclxuICAgICAgICBwcm9ncmFtSWQ6IFBST0dSQU1fSUQsXHJcbiAgICAgICAgZGF0YTogZnVsbEluc3RydWN0aW9uRGF0YSxcclxuICAgICAgfSlcclxuXHJcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKGluc3RydWN0aW9uKVxyXG4gICAgICBjb25zdCB7IGJsb2NraGFzaCB9ID0gYXdhaXQgY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goJ3Byb2Nlc3NlZCcpXHJcbiAgICAgIHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCA9IGJsb2NraGFzaFxyXG4gICAgICB0cmFuc2FjdGlvbi5mZWVQYXllciA9IHB1YmxpY0tleVxyXG5cclxuICAgICAgLy8gU2lnbiB3aXRoIGNvbW1lbnQga2V5cGFpclxyXG4gICAgICB0cmFuc2FjdGlvbi5wYXJ0aWFsU2lnbihjb21tZW50S2V5cGFpcilcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn46vIFNpbXVsYXRpbmcgdHJhbnNhY3Rpb24uLi4nKVxyXG4gICAgICBjb25zdCBzaW11bGF0aW9uID0gYXdhaXQgY29ubmVjdGlvbi5zaW11bGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKVxyXG4gICAgICBjb25zb2xlLmxvZygn8J+TiiBTaW11bGF0aW9uIHJlc3VsdDonLCBzaW11bGF0aW9uKVxyXG5cclxuICAgICAgaWYgKHNpbXVsYXRpb24udmFsdWUuZXJyKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIFNpbXVsYXRpb24gZmFpbGVkOicsIHNpbXVsYXRpb24udmFsdWUuZXJyKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gc2ltdWxhdGlvbiBmYWlsZWQ6ICR7SlNPTi5zdHJpbmdpZnkoc2ltdWxhdGlvbi52YWx1ZS5lcnIpfWApXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgY29ubmVjdGlvbiwge1xyXG4gICAgICAgIHNraXBQcmVmbGlnaHQ6IGZhbHNlLFxyXG4gICAgICAgIHByZWZsaWdodENvbW1pdG1lbnQ6ICdwcm9jZXNzZWQnLFxyXG4gICAgICAgIG1heFJldHJpZXM6IDMsXHJcbiAgICAgICAgc2lnbmVyczogW2NvbW1lbnRLZXlwYWlyXSwgLy8gQ29tbWVudCBrZXlwYWlyIG11c3Qgc2lnbiB0aGUgdHJhbnNhY3Rpb25cclxuICAgICAgfSlcclxuXHJcbiAgICAgIGF3YWl0IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHtcclxuICAgICAgICBzaWduYXR1cmUsXHJcbiAgICAgICAgYmxvY2toYXNoLFxyXG4gICAgICAgIGxhc3RWYWxpZEJsb2NrSGVpZ2h0OiAoYXdhaXQgY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goKSkubGFzdFZhbGlkQmxvY2tIZWlnaHQsXHJcbiAgICAgIH0sICdwcm9jZXNzZWQnKVxyXG5cclxuICAgICAgY29uc29sZS5sb2coJ+KchSBDb21tZW50IHBvc3RlZCBzdWNjZXNzZnVsbHkhJylcclxuICAgICAgXHJcbiAgICAgIC8vIFN0b3JlIHRoZSBjb21tZW50IHJlbGF0aW9uc2hpcCBpbiBsb2NhbFN0b3JhZ2VcclxuICAgICAgLy8gV2UgbmVlZCB0byBnZXQgdGhlIGNvbW1lbnQncyBwb3N0IElEIGZyb20gdGhlIHVzZXIncyBwcm9maWxlXHJcbiAgICAgIGNvbnN0IHVzZXJQcm9maWxlID0gYXdhaXQgZ2V0UHJvZmlsZShwdWJsaWNLZXkpXHJcbiAgICAgIGlmICh1c2VyUHJvZmlsZSkge1xyXG4gICAgICAgIHN0b3JlQ29tbWVudFJlbGF0aW9uc2hpcChwb3N0SWQsIHVzZXJQcm9maWxlLnBvc3RzQ291bnQpXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIENsZWFyIHBvc3RzIGNhY2hlIHRvIGZvcmNlIHJlZnJlc2hcclxuICAgICAgcG9zdHNDYWNoZSA9IG51bGxcclxuICAgICAgXHJcbiAgICAgIHRvYXN0LnN1Y2Nlc3MoJ0NvbW1lbnQgcG9zdGVkIScpXHJcbiAgICAgIHJldHVybiBzaWduYXR1cmVcclxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIENvbW1lbnQgcG9zdCBlcnJvcjonLCBlcnJvcilcclxuICAgICAgdG9hc3QuZXJyb3IoYEZhaWxlZCB0byBjb21tZW50OiAke2Vycm9yLm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InfWApXHJcbiAgICAgIHRocm93IGVycm9yXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBCb29rbWFyayBQb3N0ICh1c2luZyBsb2NhbFN0b3JhZ2Ugc2luY2Ugd2UgZG9uJ3QgaGF2ZSBib29rbWFyayBmdW5jdGlvbmFsaXR5KVxyXG4gIGNvbnN0IGJvb2ttYXJrUG9zdCA9IGFzeW5jIChwb3N0SWQ6IG51bWJlcikgPT4ge1xyXG4gICAgaWYgKCFwdWJsaWNLZXkpIHRocm93IG5ldyBFcnJvcignV2FsbGV0IG5vdCBjb25uZWN0ZWQnKVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SWIEJvb2ttYXJraW5nIHBvc3QgSUQgJHtwb3N0SWR9Li4uYClcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGJvb2ttYXJrc0tleSA9IGBib29rbWFya3NfJHtwdWJsaWNLZXkudG9TdHJpbmcoKX1gXHJcbiAgICAgIGNvbnN0IGV4aXN0aW5nQm9va21hcmtzID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oYm9va21hcmtzS2V5KVxyXG4gICAgICBjb25zdCBib29rbWFya3M6IG51bWJlcltdID0gZXhpc3RpbmdCb29rbWFya3MgPyBKU09OLnBhcnNlKGV4aXN0aW5nQm9va21hcmtzKSA6IFtdXHJcbiAgICAgIFxyXG4gICAgICBpZiAoYm9va21hcmtzLmluY2x1ZGVzKHBvc3RJZCkpIHtcclxuICAgICAgICAvLyBSZW1vdmUgYm9va21hcmtcclxuICAgICAgICBjb25zdCB1cGRhdGVkQm9va21hcmtzID0gYm9va21hcmtzLmZpbHRlcihpZCA9PiBpZCAhPT0gcG9zdElkKVxyXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGJvb2ttYXJrc0tleSwgSlNPTi5zdHJpbmdpZnkodXBkYXRlZEJvb2ttYXJrcykpXHJcbiAgICAgICAgdG9hc3Quc3VjY2VzcygnQm9va21hcmsgcmVtb3ZlZCEnKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEFkZCBib29rbWFya1xyXG4gICAgICAgIGJvb2ttYXJrcy5wdXNoKHBvc3RJZClcclxuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShib29rbWFya3NLZXksIEpTT04uc3RyaW5naWZ5KGJvb2ttYXJrcykpXHJcbiAgICAgICAgdG9hc3Quc3VjY2VzcygnUG9zdCBib29rbWFya2VkIScpXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHJldHVybiAnYm9va21hcmtlZCdcclxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIEJvb2ttYXJrIGVycm9yOicsIGVycm9yKVxyXG4gICAgICB0b2FzdC5lcnJvcignRmFpbGVkIHRvIGJvb2ttYXJrIHBvc3QnKVxyXG4gICAgICB0aHJvdyBlcnJvclxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gR2V0IHVzZXIgYm9va21hcmtzXHJcbiAgY29uc3QgZ2V0VXNlckJvb2ttYXJrcyA9ICgpOiBudW1iZXJbXSA9PiB7XHJcbiAgICBpZiAoIXB1YmxpY0tleSkgcmV0dXJuIFtdXHJcbiAgICBcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGJvb2ttYXJrc0tleSA9IGBib29rbWFya3NfJHtwdWJsaWNLZXkudG9TdHJpbmcoKX1gXHJcbiAgICAgIGNvbnN0IGV4aXN0aW5nQm9va21hcmtzID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oYm9va21hcmtzS2V5KVxyXG4gICAgICByZXR1cm4gZXhpc3RpbmdCb29rbWFya3MgPyBKU09OLnBhcnNlKGV4aXN0aW5nQm9va21hcmtzKSA6IFtdXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IGJvb2ttYXJrczonLCBlcnJvcilcclxuICAgICAgcmV0dXJuIFtdXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBDaGVjayBpZiBwb3N0IGlzIGJvb2ttYXJrZWRcclxuICBjb25zdCBpc1Bvc3RCb29rbWFya2VkID0gKHBvc3RJZDogbnVtYmVyKTogYm9vbGVhbiA9PiB7XHJcbiAgICBjb25zdCBib29rbWFya3MgPSBnZXRVc2VyQm9va21hcmtzKClcclxuICAgIHJldHVybiBib29rbWFya3MuaW5jbHVkZXMocG9zdElkKVxyXG4gIH1cclxuXHJcbiAgLy8gVXRpbGl0eSBmdW5jdGlvbiB0byBwcmVsb2FkIHByb2ZpbGUgb24gd2FsbGV0IGNvbm5lY3Rpb25cclxuICBjb25zdCBwcmVsb2FkUHJvZmlsZSA9IGFzeW5jICgpID0+IHtcclxuICAgIGlmICghcHVibGljS2V5KSByZXR1cm5cclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coJ/CfmoAgUHJlbG9hZGluZyBwcm9maWxlIG9uIHdhbGxldCBjb25uZWN0aW9uLi4uJylcclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IGdldFByb2ZpbGUocHVibGljS2V5KVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gcHJlbG9hZCBwcm9maWxlOicsIGVycm9yKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gRm9yY2UgcmVmcmVzaCBhbGwgZGF0YSAtIGNsZWFycyBhbGwgY2FjaGVzXHJcbiAgY29uc3QgcmVmcmVzaERhdGEgPSAoKSA9PiB7XHJcbiAgICBjb25zb2xlLmxvZygn8J+UhCBGb3JjZSByZWZyZXNoaW5nIGFsbCBkYXRhLi4uJylcclxuICAgIGNsZWFyUHJvZmlsZUNhY2hlKClcclxuICAgIHBvc3RzQ2FjaGUgPSBudWxsXHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgY3JlYXRlUHJvZmlsZSxcclxuICAgIGNyZWF0ZVBvc3QsXHJcbiAgICBsaWtlUG9zdCxcclxuICAgIGdldFByb2ZpbGUsXHJcbiAgICBnZXRQcm9maWxlQnlVc2VybmFtZSxcclxuICAgIGdldFBvc3RzLFxyXG4gICAgZ2V0UHJvZmlsZVBEQSxcclxuICAgIGdldFBvc3RQREEsXHJcbiAgICBjaGVja1Byb2ZpbGVBdFBEQSxcclxuICAgIHByZWxvYWRQcm9maWxlLFxyXG4gICAgY2xlYXJQcm9maWxlQ2FjaGUsXHJcbiAgICByZWZyZXNoRGF0YSxcclxuICAgIGNyZWF0ZUNvbW11bml0eSxcclxuICAgIGZvbGxvd1Byb2ZpbGUsXHJcbiAgICB1bmZvbGxvd1Byb2ZpbGUsXHJcbiAgICB1cGRhdGVQcm9maWxlLFxyXG4gICAgY29tbWVudE9uUG9zdCxcclxuICAgIGJvb2ttYXJrUG9zdCxcclxuICAgIGdldFVzZXJCb29rbWFya3MsXHJcbiAgICBpc1Bvc3RCb29rbWFya2VkLFxyXG4gICAgZ2V0Q29tbWVudHNGb3JQb3N0LFxyXG4gICAgc3RvcmVDb21tZW50UmVsYXRpb25zaGlwLFxyXG4gIH1cclxufSJdLCJuYW1lcyI6WyJ1c2VDb25uZWN0aW9uIiwidXNlV2FsbGV0IiwiUHVibGljS2V5IiwiVHJhbnNhY3Rpb24iLCJUcmFuc2FjdGlvbkluc3RydWN0aW9uIiwiU3lzdGVtUHJvZ3JhbSIsIkxBTVBPUlRTX1BFUl9TT0wiLCJLZXlwYWlyIiwic2VyaWFsaXplIiwiZGVzZXJpYWxpemUiLCJ0b2FzdCIsImNvbmZpZyIsIlBST0dSQU1fSUQiLCJzb2xhbmEiLCJwcm9ncmFtSWQiLCJERUJVR19NT0RFIiwicHJvY2VzcyIsIkNvbnRyYWN0SW5zdHJ1Y3Rpb24iLCJQb3N0UmF0aW5nIiwiQ3JlYXRlUHJvZmlsZUluc3RydWN0aW9uIiwiY29uc3RydWN0b3IiLCJmaWVsZHMiLCJ1c2VybmFtZSIsImJpbyIsInByb2ZpbGVfaW1hZ2UiLCJjb3Zlcl9pbWFnZSIsIkNyZWF0ZVBvc3RJbnN0cnVjdGlvbiIsImNvbnRlbnQiLCJpbWFnZXMiLCJMaWtlUG9zdEluc3RydWN0aW9uIiwicG9zdF9pZCIsIkNvbW1lbnRPblBvc3RJbnN0cnVjdGlvbiIsInBhcmVudF9pZCIsIkJvb2ttYXJrUG9zdEluc3RydWN0aW9uIiwiUHJvZmlsZUFjY291bnQiLCJpc19pbml0aWFsaXplZCIsIm93bmVyIiwiY3JlYXRlZF9hdCIsImZvbGxvd2Vyc19jb3VudCIsImZvbGxvd2luZ19jb3VudCIsInVzZXJfY3JlZGl0X3JhdGluZyIsInBvc3RzX2NvdW50IiwibGFzdF9wb3N0X3RpbWVzdGFtcCIsImRhaWx5X3Bvc3RfY291bnQiLCJpc192ZXJpZmllZCIsIlBvc3RBY2NvdW50IiwiaWQiLCJhdXRob3IiLCJ0aW1lc3RhbXAiLCJsaWtlcyIsImNvbW1lbnRzIiwibWlycm9ycyIsInJhdGluZyIsImluX2tpbGxfem9uZSIsImNyZWF0ZVByb2ZpbGVTY2hlbWEiLCJNYXAiLCJraW5kIiwiY3JlYXRlUG9zdFNjaGVtYSIsImxpa2VQb3N0U2NoZW1hIiwiY29tbWVudE9uUG9zdFNjaGVtYSIsImJvb2ttYXJrUG9zdFNjaGVtYSIsInByb2ZpbGVBY2NvdW50U2NoZW1hIiwicG9zdEFjY291bnRTY2hlbWEiLCJDb21tdW5pdHlBY2NvdW50IiwiY3JlYXRvciIsIm5hbWUiLCJkZXNjcmlwdGlvbiIsImF2YXRhciIsInJ1bGVzIiwibWVtYmVyX2NvdW50IiwiaXNfcHJpdmF0ZSIsIkNyZWF0ZUNvbW11bml0eUluc3RydWN0aW9uIiwiRm9sbG93UHJvZmlsZUluc3RydWN0aW9uIiwicHJvZmlsZV9pZCIsInRvQnVmZmVyIiwiY3JlYXRlQ29tbXVuaXR5U2NoZW1hIiwiZm9sbG93UHJvZmlsZVNjaGVtYSIsImNvbW11bml0eUFjY291bnRTY2hlbWEiLCJwcm9maWxlQ2FjaGUiLCJDQUNIRV9EVVJBVElPTiIsInBvc3RzQ2FjaGUiLCJQT1NUU19DQUNIRV9EVVJBVElPTiIsIkxPQ0FMU1RPUkFHRV9DQUNIRV9QUkVGSVgiLCJMT0NBTFNUT1JBR0VfQ0FDSEVfRFVSQVRJT04iLCJzYXZlUHJvZmlsZVRvTG9jYWxTdG9yYWdlIiwid2FsbGV0QWRkcmVzcyIsInByb2ZpbGUiLCJjYWNoZUtleSIsImNhY2hlRGF0YSIsIkRhdGUiLCJub3ciLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwiSlNPTiIsInN0cmluZ2lmeSIsImNvbnNvbGUiLCJsb2ciLCJzbGljZSIsImVycm9yIiwid2FybiIsImdldFByb2ZpbGVGcm9tTG9jYWxTdG9yYWdlIiwiY2FjaGVkIiwiZ2V0SXRlbSIsInBhcnNlIiwicmVtb3ZlSXRlbSIsImNsZWFyUHJvZmlsZUNhY2hlIiwiZGVsZXRlIiwiY2xlYXIiLCJrZXlzIiwiT2JqZWN0IiwiZm9yRWFjaCIsImtleSIsInN0YXJ0c1dpdGgiLCJ1c2VCbG9ja3NQcm9ncmFtIiwiY29ubmVjdGlvbiIsInB1YmxpY0tleSIsInNlbmRUcmFuc2FjdGlvbiIsImdldFByb2ZpbGVQREEiLCJ1c2VyUHVibGljS2V5IiwicHJvZmlsZVBEQSIsImZpbmRQcm9ncmFtQWRkcmVzcyIsIkJ1ZmZlciIsImZyb20iLCJnZXRQb3N0UERBIiwicG9zdElkIiwicG9zdFBEQSIsInRvU3RyaW5nIiwiY2hlY2tQcm9ncmFtRXhpc3RzIiwicHJvZ3JhbUluZm8iLCJnZXRBY2NvdW50SW5mbyIsImV4ZWN1dGFibGUiLCJjaGVja1NPTEJhbGFuY2UiLCJiYWxhbmNlIiwiZ2V0QmFsYW5jZSIsImNvbnZlcnRQcm9maWxlQWNjb3VudCIsInByb2ZpbGVBY2NvdW50IiwiY2FsY3VsYXRlVUNSIiwicG9zdHNDb3VudCIsIk51bWJlciIsImZvbGxvd2Vyc0NvdW50IiwiZm9sbG93aW5nQ291bnQiLCJ1Y3IiLCJwb3N0c1Njb3JlIiwiTWF0aCIsIm1pbiIsImZvbGxvd2Vyc1Njb3JlIiwicmF0aW9Cb251cyIsInJhdGlvIiwiYWNjb3VudEFnZSIsImRheXNPbGQiLCJhZ2VCb251cyIsInZlcmlmaWNhdGlvbkJvbnVzIiwibGFzdFBvc3RBZ2UiLCJkYXlzU2luY2VMYXN0UG9zdCIsImFjdGl2aXR5Qm9udXMiLCJpc0luaXRpYWxpemVkIiwicHJvZmlsZUltYWdlIiwiY292ZXJJbWFnZSIsImNyZWF0ZWRBdCIsInVzZXJDcmVkaXRSYXRpbmciLCJsYXN0UG9zdFRpbWVzdGFtcCIsImRhaWx5UG9zdENvdW50IiwiaXNWZXJpZmllZCIsImNvbnZlcnRQb3N0QWNjb3VudCIsInBvc3RBY2NvdW50IiwiaW5LaWxsWm9uZSIsImNyZWF0ZVByb2ZpbGUiLCJFcnJvciIsInByb2dyYW1FeGlzdHMiLCJuZXR3b3JrIiwiaW5zdHJ1Y3Rpb25EYXRhIiwiY3JlYXRlUHJvZmlsZVZhcmlhbnQiLCJzZXJpYWxpemVkRGF0YSIsImZ1bGxJbnN0cnVjdGlvbkRhdGEiLCJjb25jYXQiLCJpbnN0cnVjdGlvbiIsInB1YmtleSIsImlzU2lnbmVyIiwiaXNXcml0YWJsZSIsImRhdGEiLCJ0cmFuc2FjdGlvbiIsImFkZCIsImJsb2NraGFzaCIsImdldExhdGVzdEJsb2NraGFzaCIsInJlY2VudEJsb2NraGFzaCIsImZlZVBheWVyIiwic2ltdWxhdGlvbiIsInNpbXVsYXRlVHJhbnNhY3Rpb24iLCJ2YWx1ZSIsImVyciIsInNpZ25hdHVyZSIsInNraXBQcmVmbGlnaHQiLCJwcmVmbGlnaHRDb21taXRtZW50IiwibWF4UmV0cmllcyIsImNvbmZpcm1UcmFuc2FjdGlvbiIsImxhc3RWYWxpZEJsb2NrSGVpZ2h0Iiwic3VjY2VzcyIsIm1lc3NhZ2UiLCJnZXRQcm9maWxlIiwiY2FjaGVkUHJvZmlsZSIsInNldCIsInNldFRpbWVvdXQiLCJoYXMiLCJnZXQiLCJhY2NvdW50cyIsImdldFByb2dyYW1BY2NvdW50cyIsImxlbmd0aCIsInByb2ZpbGVzRm91bmQiLCJhY2NvdW50IiwibWFudWFsUGFyc2VQcm9maWxlIiwiYWNjb3VudE93bmVyIiwiZXF1YWxzIiwiZ2V0UHJvZmlsZUJ5VXNlcm5hbWUiLCJhY2NvdW50SW5mbyIsImdldFBvc3RzIiwicG9zdHMiLCJtYW51YWxQYXJzZVBvc3QiLCJwb3N0IiwiaXNDb21tZW50IiwicHVzaCIsInN1YnN0cmluZyIsInNvcnQiLCJhIiwiYiIsImdldENvbW1lbnRzRm9yUG9zdCIsImNvbW1lbnRzS2V5Iiwic3RvcmVkQ29tbWVudHMiLCJjb21tZW50SWRzIiwiaW5jbHVkZXMiLCJwYXJlbnRJZCIsInN0b3JlQ29tbWVudFJlbGF0aW9uc2hpcCIsInBhcmVudFBvc3RJZCIsImNvbW1lbnRQb3N0SWQiLCJleGlzdGluZ0NvbW1lbnRzIiwiY3JlYXRlUG9zdCIsInVzZXJQcm9maWxlIiwicG9zdEtleXBhaXIiLCJnZW5lcmF0ZSIsInVzZXJQcm9maWxlUERBIiwiY3JlYXRlUG9zdFZhcmlhbnQiLCJtYXAiLCJrIiwicGFydGlhbFNpZ24iLCJzaWduZXJzIiwidG9GaXhlZCIsImxpa2VQb3N0IiwicG9zdEF1dGhvciIsInBvc3RBY2NvdW50QWRkcmVzcyIsImF1dGhvclByb2ZpbGVBZGRyZXNzIiwicGFyc2VkUG9zdCIsInBhcnNlZFByb2ZpbGUiLCJCaWdJbnQiLCJsaWtlUG9zdFZhcmlhbnQiLCJjaGVja1Byb2ZpbGVBdFBEQSIsInBkYUFkZHJlc3MiLCJwZGEiLCJBcnJheSIsIm9mZnNldCIsInVzZXJuYW1lTGVuZ3RoIiwicmVhZFVJbnQzMkxFIiwiYmlvTGVuZ3RoIiwicHJvZmlsZUltYWdlTGVuZ3RoIiwiY292ZXJJbWFnZUxlbmd0aCIsInJlYWRCaWdVSW50NjRMRSIsInJlYWRCaWdJbnQ2NExFIiwiVWludDhBcnJheSIsImNvbnRlbnRMZW5ndGgiLCJpbWFnZXNMZW5ndGgiLCJpIiwiaW1hZ2VMZW5ndGgiLCJpbWFnZSIsImNvbnZlcnRDb21tdW5pdHlBY2NvdW50IiwiY29tbXVuaXR5QWNjb3VudCIsIm1lbWJlckNvdW50IiwiaXNQcml2YXRlIiwiY3JlYXRlQ29tbXVuaXR5IiwiY29tbXVuaXR5S2V5cGFpciIsImNyZWF0ZUNvbW11bml0eVZhcmlhbnQiLCJmb2xsb3dQcm9maWxlIiwicHJvZmlsZVB1YmxpY0tleSIsImZvbGxvd2VyUHJvZmlsZUFkZHJlc3MiLCJmb2xsb3dQcm9maWxlVmFyaWFudCIsInVuZm9sbG93UHJvZmlsZSIsInVuZm9sbG93UHJvZmlsZVZhcmlhbnQiLCJ1cGRhdGVQcm9maWxlIiwidXBkYXRlUHJvZmlsZVZhcmlhbnQiLCJjb21tZW50T25Qb3N0IiwicG9zdEFkZHJlc3MiLCJ1c2VyUHJvZmlsZUFkZHJlc3MiLCJjb21tZW50S2V5cGFpciIsImNvbW1lbnRWYXJpYW50IiwiYm9va21hcmtQb3N0IiwiYm9va21hcmtzS2V5IiwiZXhpc3RpbmdCb29rbWFya3MiLCJib29rbWFya3MiLCJ1cGRhdGVkQm9va21hcmtzIiwiZmlsdGVyIiwiZ2V0VXNlckJvb2ttYXJrcyIsImlzUG9zdEJvb2ttYXJrZWQiLCJwcmVsb2FkUHJvZmlsZSIsInJlZnJlc2hEYXRhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useBlocksProgram.ts\n"));

/***/ })

});